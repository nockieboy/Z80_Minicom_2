0001   0000             ;==================================================================================
0002   0000             ; Contents of this file are copyright Jonathan Nock
0003   0000             ; Serial IO and CPM routines copyright Grant Searle.
0004   0000             ; HEX routines from Joel Owens.
0005   0000             ;
0006   0000             ; http://searle.hostei.com/grant/index.html
0007   0000             ; eMail: home.micros01@btinternet.com
0008   0000             ;
0009   0000             ;==================================================================================
0010   0000             
0011   0000             ;------------------------------------------------------------------------------
0012   0000             ;
0013   0000             ; Z80 Minicom II - Monitor Rom v1.3 (PIO & I2C)
0014   0000             ;
0015   0000             ; 1.3 - PIO & I2C
0016   0000             ; 1.2 - CTC Routines
0017   0000             ; 1.1 - PSG Routines
0018   0000             ;------------------------------------------------------------------------------
0019   0000             
0020   0000             ;------------------------------------------------------------------------------
0021   0000             ; General Equates
0022   0000             ;------------------------------------------------------------------------------
0023   0000             MCLS            .EQU     	0CH             ; Clear screen
0024   0000             EOS         	.EQU    	$0            	; End of string
0025   0000             CR            	.EQU     	0DH				; Carriage Return
0026   0000             LF              .EQU     	0AH				; Line Feed
0027   0000             CS              .EQU     	0CH            	; Clear screen
0028   0000             
0029   0000             ;------------------------------------------------------------------------------
0030   0000             ; PIO Addresses & Equates
0031   0000             ;------------------------------------------------------------------------------
0032   0000             PIO_A_D			.EQU		20H				; A Channel Data
0033   0000             PIO_A_C			.EQU		22H				; A Channel Commands
0034   0000             PIO_B_D			.EQU		21H				; B Channel Data
0035   0000             PIO_B_C			.EQU		23H				; B Channel Commands
0036   0000             
0037   0000             ;------------------------------------------------------------------------------
0038   0000             ; CTC Channel Addresses
0039   0000             ;------------------------------------------------------------------------------
0040   0000             CTC_0			.EQU		18H
0041   0000             CTC_1			.EQU		19H
0042   0000             CTC_2			.EQU		1AH
0043   0000             CTC_3			.EQU		1BH
0044   0000             
0045   0000             ;------------------------------------------------------------------------------
0046   0000             ; Support Module (ATmega168) Addresses
0047   0000             ;------------------------------------------------------------------------------
0048   0000             SM_C			.EQU		28H				; IO port for the ATmega168 (TEST)
0049   0000             
0050   0000             ;------------------------------------------------------------------------------
0051   0000             ; AY-3-8912 PSG IN/OUT addresses for commands
0052   0000             ;------------------------------------------------------------------------------
0053   0000             AY_IO_ADDR		.EQU		0EH				; AY-3-8912 IOA address
0054   0000             AY_WRITE		.EQU		09H				; AY-3-8912 OUT write address
0055   0000             AY_READ			.EQU		08H				; AY-3-8912 IN read address
0056   0000             AY_LATCH		.EQU		08H				; AY-3-8912 OUT latch address
0057   0000             AY_OUTPUT		.EQU		40H				; Value to set IO to OUTPUT
0058   0000             
0059   0000             ;------------------------------------------------------------------------------
0060   0000             ; CF registers
0061   0000             ;------------------------------------------------------------------------------
0062   0000             CF_DATA			.EQU		$10
0063   0000             CF_FEATURES		.EQU		$11
0064   0000             CF_ERROR		.EQU		$11
0065   0000             CF_SECCOUNT		.EQU		$12
0066   0000             CF_SECTOR		.EQU		$13
0067   0000             CF_CYL_LOW		.EQU		$14
0068   0000             CF_CYL_HI		.EQU		$15
0069   0000             CF_HEAD			.EQU		$16
0070   0000             CF_STATUS		.EQU		$17
0071   0000             CF_COMMAND		.EQU		$17
0072   0000             CF_LBA0			.EQU		$13
0073   0000             CF_LBA1			.EQU		$14
0074   0000             CF_LBA2			.EQU		$15
0075   0000             CF_LBA3			.EQU		$16
0076   0000             
0077   0000             ;------------------------------------------------------------------------------
0078   0000             ;CF Features
0079   0000             ;------------------------------------------------------------------------------
0080   0000             CF_8BIT			.EQU		1
0081   0000             CF_NOCACHE		.EQU		082H
0082   0000             
0083   0000             ;------------------------------------------------------------------------------
0084   0000             ;CF Commands
0085   0000             ;------------------------------------------------------------------------------
0086   0000             CF_READ_SEC		.EQU		020H
0087   0000             CF_WRITE_SEC	.EQU		030H
0088   0000             CF_SET_FEAT		.EQU 		0EFH
0089   0000             
0090   0000             
0091   0000             loadAddr		.EQU		0D000h				; CP/M load address
0092   0000             numSecs			.EQU		24					; Number of 512 sectors to be loaded
0093   0000             
0094   0000             ;------------------------------------------------------------------------------
0095   0000             ;BASIC cold and warm entry points
0096   0000             ;------------------------------------------------------------------------------
0097   0000             BASCLD			.EQU		$2000
0098   0000             BASWRM			.EQU		$2003
0099   0000             
0100   0000             SER_BUFSIZE		.EQU		40H
0101   0000             SER_FULLSIZE	.EQU		30H
0102   0000             SER_EMPTYSIZE	.EQU		5
0103   0000             
0104   0000             RTS_HIGH		.EQU		0E8H
0105   0000             RTS_LOW			.EQU		0EAH
0106   0000             
0107   0000             SIOA_D			.EQU		$00
0108   0000             SIOA_C			.EQU		$02
0109   0000             SIOB_D			.EQU		$01
0110   0000             SIOB_C			.EQU		$03
0111   0000             
0112   4000             		.ORG	$4000
0113   4000             ;------------------------------------------------------------------------------
0114   4000             serABuf			.ds			SER_BUFSIZE
0115   4040             serAInPtr		.ds			2
0116   4042             serARdPtr		.ds			2
0117   4044             serABufUsed		.ds			1
0118   4045             ;------------------------------------------------------------------------------
0119   4045             serBBuf			.ds			SER_BUFSIZE
0120   4085             serBInPtr		.ds			2
0121   4087             serBRdPtr		.ds			2
0122   4089             serBBufUsed		.ds			1
0123   408A             ;------------------------------------------------------------------------------
0124   408A             basicStarted	.ds			1
0125   408B             IO_ADDR  		.ds    		1		; 1-byte space to store IO port for IO command
0126   408C             CHRBUF			.ds			2		; PHEX character buffer
0127   408E             CLKMEM			.ds			2		; Seconds-since-boot memory location
0128   4090             LZ_FLAG			.ds			1		; Flag to determine whether zeros should be shown in DECHL
0129   4091             ;------------------------------------------------------------------------------
0130   4091             PIO_A_MODE		.ds			1		; Holds current PIO A mode
0131   4092             PIO_A_IO_CONF	.ds			1		; Holds current IO config for PIO A
0132   4093             PIO_B_MODE		.ds			1		; Holds current PIO B mode
0133   4094             PIO_B_IO_CONF	.ds			1		; Holds current IO config for PIO B
0134   4095             ;------------------------------------------------------------------------------
0135   4095             I2C_BUFF		.ds			1		; Holds counter for iterations with I2C
0136   4096             ;------------------------------------------------------------------------------
0137   4096             primaryIO		.ds			1
0138   4097             secNo			.ds			1
0139   4098             dmaAddr			.ds			2
0140   409A             ;------------------------------------------------------------------------------
0141   409A             stackSpace		.ds			64
0142   40DA             MSTACK   		.EQU    	$					; Stack top
0143   40DA             ;------------------------------------------------------------------------------
0144   40DA             ;                         START OF MONITOR ROM
0145   40DA             ;------------------------------------------------------------------------------
0146   0000             MON		.ORG	$0000							; MONITOR ROM RESET VECTOR
0147   0000             ;------------------------------------------------------------------------------
0148   0000             ; Reset
0149   0000             ;------------------------------------------------------------------------------
0150   0000 F3          RST00			DI								;Disable INTerrupts
0151   0001 C3 AE 01    				JP			MINIT				;Initialize Hardware and go
0152   0004 00          				NOP
0153   0005 00          				NOP
0154   0006 00          				NOP
0155   0007 00          				NOP
0156   0008             ;------------------------------------------------------------------------------
0157   0008             ; TX a character over serial, wait for TXDONE first.
0158   0008             ;------------------------------------------------------------------------------
0159   0008 C3 48 01    RST08			JP			conout
0160   000B 00          				NOP
0161   000C 00          				NOP
0162   000D 00          				NOP
0163   000E 00          				NOP
0164   000F 00          				NOP
0165   0010             ;------------------------------------------------------------------------------
0166   0010             ; RX a character from buffer wait until char ready.
0167   0010             ;------------------------------------------------------------------------------
0168   0010 C3 DB 00    RST10			JP			conin
0169   0013 00          				NOP
0170   0014 00          				NOP
0171   0015 00          				NOP
0172   0016 00          				NOP
0173   0017 00          				NOP
0174   0018             ;------------------------------------------------------------------------------
0175   0018             ; Check input buffer status
0176   0018             ;------------------------------------------------------------------------------
0177   0018 C3 78 01    RST18			JP			CKINCHAR
0178   001B             
0179   001B             ;------------------------------------------------------------------------------
0180   001B             ; CTC Interrupt vector table starting at Vector 58
0181   001B             ;------------------------------------------------------------------------------
0182   0058              		.ORG	$0058
0183   0058 C0 00       		.DW		CTC_Int					; CTC channel 0 Vector in table
0184   005A C0 00       		.DW		CTC_Int					; CTC channel 1 Vector in table
0185   005C C0 00       		.DW		CTC_Int					; CTC channel 2 Vector in table
0186   005E CD 00       		.DW		CTC_CLK					; CTC channel 3 Vector in table
0187   0060             
0188   0060             ;------------------------------------------------------------------------------
0189   0060             ; SIO Vector = 0x60
0190   0060             ;------------------------------------------------------------------------------
0191   0060 62 00       		.DW		serialInt
0192   0062             		
0193   0062             ;------------------------------------------------------------------------------
0194   0062             ; Start of NMI interrupt
0195   0062             ;------------------------------------------------------------------------------
0196   0062             		;.ORG 	$0066
0197   0062             
0198   0062             		;.ORG 	$0070
0199   0062             
0200   0062             ;------------------------------------------------------------------------------
0201   0062             ; Serial interrupt handlers
0202   0062             ; Same interrupt called if either of the inputs receives a character
0203   0062             ; so need to check the status of each SIO input.
0204   0062             ;------------------------------------------------------------------------------
0205   0062 F5          serialInt:		PUSH		AF
0206   0063 E5          				PUSH		HL
0207   0064             				; Check if there is a char in channel A
0208   0064             				; If not, there is a char in channel B
0209   0064 97          				SUB			A
0210   0065 D3 02       				OUT 		(SIOA_C),A
0211   0067 DB 02       				IN			A,(SIOA_C)			; Status byte D2=TX Buff Empty, D0=RX char ready	
0212   0069 0F          				RRCA							; Rotates RX status into Carry Flag,	
0213   006A 30 2A       				JR			NC,serialIntB
0214   006C             ; Serial Port A - Character received
0215   006C 2A 40 40    serialIntA:		LD			HL,(serAInPtr)
0216   006F 23          				INC			HL
0217   0070 7D          				LD			A,L
0218   0071 FE 40       				CP			(serABuf+SER_BUFSIZE) & $FF
0219   0073 20 03       				JR			NZ,notAWrap
0220   0075 21 00 40    				LD			HL,serABuf
0221   0078 22 40 40    notAWrap:		LD			(serAInPtr),HL
0222   007B DB 00       				IN			A,(SIOA_D)
0223   007D 77          				LD			(HL),A
0224   007E 3A 44 40    				LD			A,(serABufUsed)
0225   0081 3C          				INC			A
0226   0082 32 44 40    				LD			(serABufUsed),A
0227   0085 FE 30       				CP			SER_FULLSIZE
0228   0087 38 08       				JR			C,rtsA0
0229   0089 3E 05       				LD			A,$05
0230   008B D3 02       				OUT  		(SIOA_C),A
0231   008D 3E E8       				LD			A,RTS_HIGH
0232   008F D3 02       				OUT  		(SIOA_C),A
0233   0091 E1          rtsA0:			POP			HL
0234   0092 F1          				POP			AF
0235   0093 FB          				EI
0236   0094 ED 4D       				RETI
0237   0096             				
0238   0096             ; Serial Port B - Character received
0239   0096 2A 85 40    serialIntB:		LD			HL,(serBInPtr)
0240   0099 23          				INC			HL
0241   009A 7D          				LD			A,L
0242   009B FE 85       				CP			(serBBuf+SER_BUFSIZE) & $FF
0243   009D 20 03       				JR			NZ,notBWrap
0244   009F 21 45 40    				LD			HL,serBBuf
0245   00A2 22 85 40    notBWrap:		LD			(serBInPtr),HL
0246   00A5 DB 01       				IN			A,(SIOB_D)				; Get char from Port B
0247   00A7 77          				LD			(HL),A					; Load it into the serial buffer
0248   00A8 3A 89 40    				LD			A,(serBBufUsed)			; Get serial buffer size
0249   00AB 3C          				INC			A						; Increment it
0250   00AC 32 89 40    				LD			(serBBufUsed),A			; Update with incremented value
0251   00AF FE 30       				CP			SER_FULLSIZE			; Check if buffer is full
0252   00B1 38 08       				JR			C,rtsB0					; No, go to exit
0253   00B3 3E 05       				LD			A,$05					; Yes, hold RTS HIGH
0254   00B5 D3 03       				OUT  		(SIOB_C),A
0255   00B7 3E E8       				LD			A,RTS_HIGH
0256   00B9 D3 03       				OUT  		(SIOB_C),A
0257   00BB E1          rtsB0:			POP			HL
0258   00BC F1          				POP			AF
0259   00BD FB          				EI
0260   00BE ED 4D       				RETI
0261   00C0             
0262   00C0             ;------------------------------------------------------------------------------
0263   00C0             ; CTC Null Interrupt Handler
0264   00C0             ; This is called when an unhandled interrupt from the CTC is triggered
0265   00C0             ;------------------------------------------------------------------------------
0266   00C0 F5          CTC_Int:		PUSH		AF
0267   00C1 E5          				PUSH		HL
0268   00C2             				
0269   00C2 21 6C 0B    				LD			HL,INTERR
0270   00C5 CD 0C 03    				CALL		MPRINT
0271   00C8             				
0272   00C8 E1          				POP			HL
0273   00C9 F1          				POP			AF
0274   00CA FB          				EI
0275   00CB ED 4D       				RETI
0276   00CD             				
0277   00CD             ;------------------------------------------------------------------------------
0278   00CD             ; CTC CLOCK Interrupt Handler
0279   00CD             ; This is called every second and increments a 16-bit value in (MEMCLK)
0280   00CD             ;------------------------------------------------------------------------------
0281   00CD F5          CTC_CLK:		PUSH		AF
0282   00CE E5          				PUSH		HL
0283   00CF             				
0284   00CF 2A 8E 40    				LD			HL,(CLKMEM)			; Load 16-bit value into HL
0285   00D2 23          				INC			HL					; Increment by 1
0286   00D3 22 8E 40    				LD			(CLKMEM),HL			; Write the result back
0287   00D6             				
0288   00D6 E1          				POP			HL
0289   00D7 F1          				POP			AF
0290   00D8 FB          				EI
0291   00D9 ED 4D       				RETI
0292   00DB             
0293   00DB             ;------------------------------------------------------------------------------
0294   00DB             ; Console input routine
0295   00DB             ; Check port contents to determine which input port to monitor.
0296   00DB             ;------------------------------------------------------------------------------
0297   00DB             RXA:
0298   00DB E5          conin:			PUSH		HL
0299   00DC             				; Check if there is a char in channel A
0300   00DC             				; or channel B - keep looping til one is found
0301   00DC 3A 44 40    waitForChar:	LD			A,(serABufUsed)
0302   00DF FE 00       				CP			$00
0303   00E1 20 10       				JR			NZ,gotCharA
0304   00E3 3A 89 40    				LD			A,(serBBufUsed)
0305   00E6 FE 00       				CP			$00
0306   00E8 20 37       				JR			NZ,gotCharB
0307   00EA 18 F0       				JR			waitForChar
0308   00EC             coninA:
0309   00EC 3A 44 40    waitForCharA:	LD			A,(serABufUsed)
0310   00EF FE 00       				CP			$00
0311   00F1 28 F9       				JR			Z, waitForCharA
0312   00F3 2A 42 40    gotCharA:		LD			HL,(serARdPtr)
0313   00F6 23          				INC			HL
0314   00F7 7D          				LD			A,L
0315   00F8 FE 40       				CP			(serABuf+SER_BUFSIZE) & $FF
0316   00FA 20 03       				JR			NZ, notRdWrapA
0317   00FC 21 00 40    				LD			HL,serABuf
0318   00FF             
0319   00FF F3          notRdWrapA:		DI
0320   0100 22 42 40    				LD			(serARdPtr),HL
0321   0103 3A 44 40    				LD			A,(serABufUsed)
0322   0106 3D          				DEC			A
0323   0107 32 44 40    				LD			(serABufUsed),A
0324   010A FE 05       				CP			SER_EMPTYSIZE
0325   010C 30 08       				JR			NC,rtsA1
0326   010E 3E 05       				LD   		A,$05
0327   0110 D3 02       				OUT  		(SIOA_C),A
0328   0112 3E EA       				LD   		A,RTS_LOW
0329   0114 D3 02       				OUT  		(SIOA_C),A
0330   0116             
0331   0116 7E          rtsA1:			LD			A,(HL)
0332   0117 FB          				EI
0333   0118 E1          				POP			HL
0334   0119 C9          				RET												; Char ready in A
0335   011A             
0336   011A             RXB:
0337   011A             coninB:
0338   011A 3A 89 40    waitForCharB:	LD			A,(serBBufUsed)
0339   011D FE 00       				CP			$00
0340   011F 28 F9       				JR			Z, waitForCharB
0341   0121 2A 87 40    gotCharB:		LD			HL,(serBRdPtr)
0342   0124 23          				INC			HL
0343   0125 7D          				LD			A,L
0344   0126 FE 85       				CP			(serBBuf+SER_BUFSIZE) & $FF
0345   0128 20 03       				JR			NZ, notRdWrapB
0346   012A 21 45 40    				LD			HL,serBBuf
0347   012D             
0348   012D F3          notRdWrapB:		DI
0349   012E 22 87 40    				LD			(serBRdPtr),HL
0350   0131 3A 89 40    				LD			A,(serBBufUsed)
0351   0134 3D          				DEC			A
0352   0135 32 89 40    				LD			(serBBufUsed),A
0353   0138 FE 05       				CP			SER_EMPTYSIZE
0354   013A 30 08       				JR			NC,rtsB1
0355   013C 3E 05       				LD   		A,$05
0356   013E D3 03       				OUT  		(SIOB_C),A
0357   0140 3E EA       				LD   		A,RTS_LOW
0358   0142 D3 03       				OUT  		(SIOB_C),A
0359   0144             
0360   0144 7E          rtsB1:			LD			A,(HL)
0361   0145 FB          				EI
0362   0146 E1          				POP			HL
0363   0147 C9          				RET												; Char ready in A
0364   0148             
0365   0148             ;------------------------------------------------------------------------------
0366   0148             ; Console output routine
0367   0148             ; Use the "primaryIO" flag to determine which output port to send a character.
0368   0148             ;------------------------------------------------------------------------------
0369   0148             TXA:
0370   0148 F5          conout:			PUSH		AF						; Store character
0371   0149 3A 96 40    				LD			A,(primaryIO)
0372   014C FE 00       				CP			0
0373   014E 20 0D       				JR			NZ,conoutB1
0374   0150 18 01       				JR			conoutA1
0375   0152             
0376   0152 F5          conoutA:		PUSH		AF
0377   0153 CD 66 01    conoutA1:		CALL		CKSIOA					; See if SIO channel A is finished transmitting
0378   0156 28 FB       				JR			Z,conoutA1				; Loop until SIO flag signals ready
0379   0158 F1          				POP			AF						; RETrieve character
0380   0159 D3 00       				OUT			(SIOA_D),A				; OUTput the character
0381   015B C9          				RET
0382   015C             
0383   015C             TXB:
0384   015C F5          conoutB:		PUSH		AF
0385   015D CD 6F 01    conoutB1:		CALL		CKSIOB					; See if SIO channel B is finished transmitting
0386   0160 28 FB       				JR			Z,conoutB1				; Loop until SIO flag signals ready
0387   0162 F1          				POP			AF						; RETrieve character
0388   0163 D3 01       				OUT			(SIOB_D),A				; OUTput the character
0389   0165 C9          				RET
0390   0166             
0391   0166             ;------------------------------------------------------------------------------
0392   0166             ; I/O status check routine
0393   0166             ; Use the "primaryIO" flag to determine which port to check.
0394   0166             ;------------------------------------------------------------------------------
0395   0166             CKSIOA:
0396   0166 97          				SUB			A
0397   0167 D3 02       				OUT 		(SIOA_C),A
0398   0169 DB 02       				IN		   	A,(SIOA_C)				; Status byte D2=TX Buff Empty, D0=RX char ready	
0399   016B 0F          				RRCA								; Rotates RX status into Carry Flag,	
0400   016C CB 4F       				BIT		  	1,A						; Set Zero flag if still transmitting character	
0401   016E C9          				RET
0402   016F             
0403   016F             CKSIOB:
0404   016F 97          				SUB			A
0405   0170 D3 03       				OUT 		(SIOB_C),A
0406   0172 DB 03       				IN   		A,(SIOB_C)				; Status byte D2=TX Buff Empty, D0=RX char ready	
0407   0174 0F          				RRCA								; Rotates RX status into Carry Flag,	
0408   0175 CB 4F       				BIT  		1,A						; Set Zero flag if still transmitting character	
0409   0177 C9          				RET
0410   0178             
0411   0178             ;------------------------------------------------------------------------------
0412   0178             ; Check if there is a character in the input buffer
0413   0178             ; Use the "primaryIO" flag to determine which port to check.
0414   0178             ;------------------------------------------------------------------------------
0415   0178             CKINCHAR:
0416   0178 3A 96 40    				LD			A,(primaryIO)
0417   017B FE 00       				CP			0
0418   017D 20 06       				JR			NZ,ckincharB
0419   017F 3A 44 40    ckincharA:		LD			A,(serABufUsed)
0420   0182 FE 00       				CP			$0
0421   0184 C9          				RET
0422   0185             ckincharB:
0423   0185 3A 89 40    				LD			A,(serBBufUsed)
0424   0188 FE 00       				CP			$0
0425   018A C9          				RET
0426   018B             
0427   018B             ;------------------------------------------------------------------------------
0428   018B             ; Filtered Character I/O
0429   018B             ;------------------------------------------------------------------------------
0430   018B             RDCHR:
0431   018B D7          				RST			10H
0432   018C FE 0A       				CP			LF
0433   018E 28 FB       				JR			Z,RDCHR						; Ignore LF
0434   0190 FE 1B       				CP			ESC
0435   0192 20 02       				JR			NZ,RDCHR1
0436   0194 3E 03       				LD			A,CTRLC						; Change ESC to CTRL-C
0437   0196 C9          RDCHR1:			RET
0438   0197             
0439   0197             WRCHR:
0440   0197 FE 0D       				CP			CR
0441   0199 28 0A       				JR			Z,WRCRLF					; When CR, write CRLF
0442   019B FE 0C       				CP			MCLS
0443   019D 28 04       				JR			Z,WR						; Allow write of "MCLS"
0444   019F FE 20       				CP			' '							; Don't write out any other control codes
0445   01A1 38 01       				JR			C,NOWR						; ie. < space
0446   01A3 CF          WR:				RST			08H
0447   01A4 C9          NOWR:			RET
0448   01A5             
0449   01A5             WRCRLF:
0450   01A5 3E 0D       				LD			A,CR
0451   01A7 CF          				RST			08H
0452   01A8 3E 0A       				LD			A,LF
0453   01AA CF          				RST			08H
0454   01AB 3E 0D       				LD			A,CR
0455   01AD C9          				RET
0456   01AE             
0457   01AE             ;------------------------------------------------------------------------------
0458   01AE             ; Initialise hardware and start main loop
0459   01AE             ;------------------------------------------------------------------------------
0460   01AE             MINIT:
0461   01AE 31 DA 40    				LD   		SP,MSTACK					; Set the Stack Pointer
0462   01B1 21 00 40    				LD			HL,serABuf
0463   01B4 22 40 40    				LD			(serAInPtr),HL
0464   01B7 22 42 40    				LD			(serARdPtr),HL
0465   01BA 21 45 40    				LD			HL,serBBuf
0466   01BD 22 85 40    				LD			(serBInPtr),HL
0467   01C0 22 87 40    				LD			(serBRdPtr),HL
0468   01C3 AF          				XOR			A							;0 to accumulator
0469   01C4 32 44 40    				LD			(serABufUsed),A
0470   01C7 32 89 40    				LD			(serBBufUsed),A
0471   01CA CD D0 01    				CALL		INIT_CTC
0472   01CD C3 DB 01    				JP			INIT_PIO
0473   01D0             				
0474   01D0             ;------------------------------------------------------------------------------
0475   01D0             ;   Initialise CTC with all channels on hold
0476   01D0             ;------------------------------------------------------------------------------
0477   01D0             INIT_CTC:
0478   01D0 3E 03       				LD			A,00000011b			; int off, timer on, prescaler=16, don't care
0479   01D2             												; ext. TRG edge, start timer on loading constant,
0480   01D2             												; no time constant follows, sw-rst active, this
0481   01D2             												; is a control command
0482   01D2 D3 18       				OUT			(CTC_0),A			; Channel 0 is on hold now
0483   01D4 D3 19       				OUT			(CTC_1),A			; Channel 1 is on hold now
0484   01D6 D3 1A       				OUT			(CTC_2),A			; Channel 2 is on hold now
0485   01D8 D3 1B       				OUT			(CTC_3),A			; Channel 3 is on hold now
0486   01DA             				
0487   01DA C9          				RET
0488   01DB             
0489   01DB             ;------------------------------------------------------------------------------
0490   01DB             ;	Initialise PIO Port B for I2C
0491   01DB             ;------------------------------------------------------------------------------
0492   01DB             INIT_PIO:
0493   01DB 3E CF       				LD			A,0CFh				; Set PIO B to bit mode
0494   01DD 32 93 40    				LD			(PIO_B_MODE),A		; Update global PIO B mode status variable
0495   01E0 D3 23       				OUT			(PIO_B_C),A
0496   01E2             				
0497   01E2 3E FF       				LD			A,0FFh				; Set D7-D0 to input mode
0498   01E4 32 94 40    				LD			(PIO_B_IO_CONF),A	; Update global PIO B IO status variable
0499   01E7 D3 23       				OUT			(PIO_B_C),A			; Write IO configuration into PIO B
0500   01E9             				
0501   01E9 3E FC       				LD			A,0FCh				; If direction of B1 or B0 changes to output
0502   01EB             												; the pin will drive L
0503   01EB D3 21       				OUT			(PIO_B_D),A			; Load PIO B output register
0504   01ED             
0505   01ED             ;------------------------------------------------------------------------------
0506   01ED             ;	Initialise SIO - Port A
0507   01ED             ;------------------------------------------------------------------------------
0508   01ED             INIT_SIO:
0509   01ED 3E 00       				LD			A,$00
0510   01EF D3 02       				OUT			(SIOA_C),A
0511   01F1 3E 18       				LD			A,$18			; Write into WR0: channel reset
0512   01F3 D3 02       				OUT			(SIOA_C),A
0513   01F5             
0514   01F5 3E 04       				LD			A,$04			; Select Write Register 4
0515   01F7 D3 02       				OUT			(SIOA_C),A
0516   01F9 3E C4       				LD			A,$C4			; CLK/64, 1 stop bit, no parity
0517   01FB D3 02       				OUT			(SIOA_C),A
0518   01FD             
0519   01FD 3E 01       				LD			A,$01			; Select Write Register 1
0520   01FF D3 02       				OUT			(SIOA_C),A
0521   0201 3E 18       				LD			A,$18			; Interrupt on all Rx chars
0522   0203 D3 02       				OUT			(SIOA_C),A
0523   0205             
0524   0205 3E 03       				LD			A,$03			; Select Write Register 3
0525   0207 D3 02       				OUT			(SIOA_C),A
0526   0209 3E E1       				LD			A,$E1			; Rx 8 bits/char, Rx enable
0527   020B D3 02       				OUT			(SIOA_C),A
0528   020D             
0529   020D 3E 05       				LD			A,$05			; Select Write Register 5
0530   020F D3 02       				OUT			(SIOA_C),A
0531   0211 3E EA       				LD			A,RTS_LOW		; DTR, Tx 8 bits/char, Tx enable
0532   0213 D3 02       				OUT			(SIOA_C),A
0533   0215             
0534   0215             ;------------------------------------------------------------------------------
0535   0215             ; Initialise SIO - Port B
0536   0215             ;------------------------------------------------------------------------------
0537   0215 3E 00       				LD			A,$00			; Select Write Register 0
0538   0217 D3 03       				OUT			(SIOB_C),A		;
0539   0219 3E 18       				LD			A,$18			; Channel reset
0540   021B D3 03       				OUT			(SIOB_C),A		;
0541   021D             
0542   021D 3E 04       				LD			A,$04			; Select Write Register 4
0543   021F D3 03       				OUT			(SIOB_C),A		;
0544   0221 3E C4       				LD			A,$C4			; CLK/64, 1 stop bit, no parity
0545   0223 D3 03       				OUT			(SIOB_C),A		;
0546   0225             
0547   0225 3E 01       				LD			A,$01			; Select Write Register 1
0548   0227 D3 03       				OUT			(SIOB_C),A		;
0549   0229 3E 18       				LD			A,$18			; Interrupt on all Rx chars
0550   022B D3 03       				OUT			(SIOB_C),A		;
0551   022D             
0552   022D 3E 02       				LD			A,$02			; Select Write Register 2
0553   022F D3 03       				OUT			(SIOB_C),A		;
0554   0231 3E 60       				LD			A,$60			; INTERRUPT VECTOR
0555   0233 D3 03       				OUT			(SIOB_C),A		;
0556   0235             	
0557   0235 3E 03       				LD			A,$03			; Select Write Register 3
0558   0237 D3 03       				OUT			(SIOB_C),A		;
0559   0239 3E E1       				LD			A,$E1			; Rx 8 bits/char, Rx enable
0560   023B D3 03       				OUT			(SIOB_C),A		;
0561   023D             
0562   023D 3E 05       				LD			A,$05			; Select Write Register 5
0563   023F D3 03       				OUT			(SIOB_C),A		;
0564   0241 3E EA       				LD			A,RTS_LOW		; DTR, Tx 8 bits/char, Tx enable
0565   0243 D3 03       				OUT			(SIOB_C),A		;
0566   0245             
0567   0245             ;------------------------------------------------------------------------------
0568   0245             ;	Set up the CPU to run in Interrupt Mode 2
0569   0245             ;------------------------------------------------------------------------------
0570   0245 3E 00       				LD			A,$00
0571   0247 ED 47       				LD			I,A							; Load I reg with zero
0572   0249 ED 5E       				IM			2							; Set int mode 2
0573   024B FB          				EI										; Enable interrupt
0574   024C             
0575   024C CD F9 03    				CALL		CTCCLK						; Initialise the seconds-since-boot
0576   024F             														; counter
0577   024F             
0578   024F             ;------------------------------------------------------------------------------
0579   024F             ; Display the "Press space to start" message on both consoles and wait for input
0580   024F             ;------------------------------------------------------------------------------
0581   024F 3E 00       				LD			A,$00
0582   0251 32 96 40    				LD			(primaryIO),A				; Set Port A as primary IO
0583   0254             				;LD   		HL,MINITTXTA
0584   0254             				;CALL 		MPRINT
0585   0254             				;LD			A,$01
0586   0254             				;LD			(primaryIO),A
0587   0254             				;LD   		HL,MINITTXTB
0588   0254             				;CALL 		MPRINT
0589   0254             				; Wait until space is in one of the buffers to determine the active console
0590   0254             waitForSpace:	;CALL 		ckincharA
0591   0254             				;JR			Z,notInA
0592   0254             				;LD			A,$00
0593   0254             				;LD			(primaryIO),A
0594   0254             				;CALL		conin
0595   0254             				;CP			' '
0596   0254             				;JP			NZ, waitForSpace
0597   0254             				;JR			spacePressed
0598   0254             
0599   0254             notInA:			;CALL		ckincharB
0600   0254             				;JR			Z,waitForSpace
0601   0254             				;LD			A,$01
0602   0254             				;LD			(primaryIO),A
0603   0254             				;CALL		conin
0604   0254             				;CP			' '
0605   0254             				;JP			NZ, waitForSpace
0606   0254             				;JR			spacePressed
0607   0254             
0608   0254             spacePressed:
0609   0254             				; Clear message on both consoles
0610   0254             				;LD			A,MCLS
0611   0254             				;CALL		conoutA
0612   0254             				;CALL		conoutB
0613   0254             
0614   0254             				; primaryIO is now set to the channel where SPACE was pressed
0615   0254             				;CALL 		TXCRLF						; TXCRLF
0616   0254             
0617   0254             ;------------------------------------------------------------------------------
0618   0254             ; Command interpreter for Direct Mode
0619   0254             ;------------------------------------------------------------------------------
0620   0254             COMMANDINIT:
0621   0254 21 EF 09    				LD			HL,SIGNON1      ; Sign-on message again
0622   0257 CD 0C 03    				CALL		MPRINT          ; Output string
0623   025A 21 9C 0B    				LD			HL,DMMSG		; Direct Mode message
0624   025D CD 0C 03    				CALL		MPRINT			; Print it
0625   0260 CD 86 02    				CALL		CRLF
0626   0263             COMMAND:
0627   0263 21 0E 0B    				LD			HL,CPROMPT		; Show the prompt
0628   0266 CD 0C 03    CMD2:			CALL		MPRINT
0629   0269 3E 3E       				LD			A,'>'			; Load A register with the command prompt character
0630   026B CD 48 01    				CALL		TXA				; Print the character in the A register
0631   026E 21 C9 41    				LD			HL,BUFFER		; Point to buffer
0632   0271 CD 3A 03    				CALL		CINPUT			; Get a command
0633   0274 C3 A3 02    				JP			CFNDWRD			; Parse input for commands
0634   0277             
0635   0277             SHORTPROMPT:
0636   0277 21 10 0B    				LD			HL,CSHTPRT		; Load the OK prompt without extra CRLF
0637   027A C3 66 02    				JP			CMD2
0638   027D             ;------------------------------------------------------------------------------
0639   027D             SHOWERR:
0640   027D 21 57 0B    				LD			HL,ERMSG		; Load error message
0641   0280 CD 0C 03    				CALL		MPRINT			; Print the message
0642   0283 C3 63 02    				JP			COMMAND			; Return to command line
0643   0286             				
0644   0286             ;------------------------------------------------------------------------------
0645   0286             CRLF:
0646   0286 F5          				PUSH		AF
0647   0287 3E 0D       				LD			A,CR					; Print CR and LF control codes.
0648   0289 CD 48 01    				CALL		TXA
0649   028C 3E 0A       				LD			A,LF
0650   028E CD 48 01    				CALL		TXA
0651   0291 F1          				POP			AF
0652   0292 C9          				RET
0653   0293             
0654   0293             ;------------------------------------------------------------------------------
0655   0293             CGETCHR:
0656   0293 23          				INC     	HL              		; Point to next character
0657   0294 7E                  		LD      	A,(HL)          		; Get next code string byte
0658   0295 FE 3A               		CP      	':'             		; Z if ':'
0659   0297 D0                  		RET     	NC              		; NC if > "9"
0660   0298 FE 20               		CP      	' '
0661   029A CA 93 02            		JP      	Z,CGETCHR      	; Skip over spaces
0662   029D FE 30               		CP      	'0'
0663   029F 3F                  		CCF                     				; NC if < '0'
0664   02A0 3C                  		INC     	A               		; Test for zero - Leave carry
0665   02A1 3D                  		DEC     	A               		; Z if Null
0666   02A2 C9                  		RET
0667   02A3             
0668   02A3             ;------------------------------------------------------------------------------
0669   02A3             ; Decode input string to find commands and call appropriate routine
0670   02A3             ;------------------------------------------------------------------------------
0671   02A3             CFNDWRD:
0672   02A3 11 68 09    				LD      	DE,CWORDS-1      	; Point to table
0673   02A6 06 7F               		LD      	B,DBASIC-1        	; First token value -1
0674   02A8 7E                  		LD      	A,(HL)          	; Get byte
0675   02A9 FE 61               		CP      	'a'             	; Less than 'a' ?
0676   02AB DA B6 02            		JP      	C,CSEARCH        	; Yes - search for words
0677   02AE FE 7B               		CP      	'z'+1           	; Greater than 'z' ?
0678   02B0 D2 B6 02            		JP      	NC,CSEARCH       	; Yes - search for words
0679   02B3 E6 5F               		AND     	01011111B       	; Force upper case
0680   02B5 77                  		LD      	(HL),A          	; Replace char with uppercase version
0681   02B6             CSEARCH:
0682   02B6 4E          				LD      	C,(HL)       		; Search for a word
0683   02B7 EB                  		EX      	DE,HL
0684   02B8             CGETNXT:
0685   02B8 23          				INC     	HL              	; Get next reserved word
0686   02B9 B6                  		OR			(HL)            	; Start of word?
0687   02BA F2 B8 02            		JP      	P,CGETNXT        	; No - move on
0688   02BD 04                  		INC     	B               	; Increment token value
0689   02BE 7E                  		LD      	A, (HL)				; Get byte from table
0690   02BF E6 7F               		AND     	01111111B       	; Strip bit 7
0691   02C1 CA 95 07            		JP	     	Z,SHOWSYERR			; Syntax Error if end of list
0692   02C4 B9                  		CP      	C               	; Same character as in buffer?
0693   02C5 C2 B8 02            		JP      	NZ,CGETNXT       	; No - get next word
0694   02C8 EB                  		EX     		DE,HL
0695   02C9 E5                  		PUSH    	HL              	; Save start of word
0696   02CA             CNXTBYT:
0697   02CA 13          				INC     	DE              	; Look through rest of word
0698   02CB 1A                  		LD      	A,(DE)          	; Get byte from table
0699   02CC B7                  		OR      	A               	; End of word ?
0700   02CD FA EC 02            		JP      	M,CMATCH         	; Yes - Match found
0701   02D0 4F                  		LD      	C,A             	; Save it
0702   02D1 78                  		LD      	A,B             	; Get token value
0703   02D2 FE 82               		CP      	DDUMP           	; Is it "DUMP" token ?
0704   02D4 C2 DB 02            		JP      	NZ,CNOSPC        	; No - Don't allow spaces
0705   02D7 CD 93 02            		CALL    	CGETCHR          	; Get next character
0706   02DA 2B                  		DEC     	HL              	; Cancel increment from CGETCHR
0707   02DB             CNOSPC: 
0708   02DB 23          				INC     	HL              	; Next byte
0709   02DC 7E                  		LD      	A,(HL)          	; Get byte
0710   02DD FE 61               		CP      	'a'             	; Less than 'a' ?
0711   02DF DA E4 02    				JP     		C,CNOCHNG        	; Yes - don't change
0712   02E2 E6 5F               		AND     	01011111B       	; Make upper case
0713   02E4             CNOCHNG:
0714   02E4 B9          				CP     		C               	; Same as in buffer ?
0715   02E5 CA CA 02            		JP     		Z,CNXTBYT        	; Yes - keep testing
0716   02E8 E1                  		POP			HL              	; Get back start of word
0717   02E9 C3 B6 02            		JP     		CSEARCH          	; Look at next word
0718   02EC             CMATCH:
0719   02EC 33          				INC			SP					; Increment stack pointer, effectively
0720   02ED 33          				INC			SP					; erasing last PUSH (with HL value in it)
0721   02EE DD E1       				POP			IX
0722   02F0 48          				LD     		C,B             	; Word found - Save token value
0723   02F1 23          				INC			HL					; Next char after command
0724   02F2 E5          				PUSH		HL					; Save code string address
0725   02F3 EB                  		EX     		DE,HL				; Swap HL back and go into EXECUTE
0726   02F4             EXECUTE:
0727   02F4 79          				LD			A,C					; Load saved token into A
0728   02F5 D6 80       				SUB			DBASIC            	; Is it a token?
0729   02F7 DA 95 07            		JP			C,SHOWSYERR    		; No - Syntax Error
0730   02FA FE 15               		CP			DXEST+1-DBASIC    	; Is it between BASIC and last command inclusive?
0731   02FC D2 95 07            		JP			NC,SHOWSYERR       	; No, not a key word - Syntax Error
0732   02FF 07                  		RLCA                    		; Double it
0733   0300 4F                  		LD			C,A             	; BC = Offset into table
0734   0301 06 00               		LD			B,0
0735   0303 21 C5 09            		LD			HL,CWORDTB       	; Keyword address table
0736   0306 09                  		ADD     	HL,BC           	; Point to routine address
0737   0307 5E          				LD			E,(HL)          	; Get LSB of routine address
0738   0308 23          				INC			HL
0739   0309 56          				LD			D,(HL)          	; Get MSB of routine address
0740   030A EB          				EX			DE,HL
0741   030B E9          				JP			(HL)
0742   030C             				
0743   030C             ;------------------------------------------------------------------------------
0744   030C             ; Print string of characters to Serial Port until byte=$00 (EOS)
0745   030C             ;------------------------------------------------------------------------------
0746   030C F5          MPRINT:			PUSH		AF
0747   030D 7E          MPR:			LD   		A,(HL)				; Get character
0748   030E FE 00       				CP   		EOS					; Is it $00 ?
0749   0310 28 05       				JR  		Z,MPEX				; Then RETurn on terminator
0750   0312 CF          				RST  		08H					; Print it
0751   0313 23          				INC  		HL					; Next Character
0752   0314 C3 0D 03    				JP   		MPR					; Continue until $00
0753   0317             				
0754   0317 F1          MPEX:			POP			AF
0755   0318 C9          				RET
0756   0319             
0757   0319             TXCRLF:
0758   0319 3E 0D       				LD   		A,CR					; 
0759   031B CF          				RST  		08H					; Print character 
0760   031C 3E 0A       				LD   		A,LF					; 
0761   031E CF          				RST  		08H					; Print character
0762   031F C9          				RET
0763   0320             				
0764   0320             ;------------------------------------------------------------------------------
0765   0320             ; Print string of characters to Serial Port B until byte=$00 (EOS)
0766   0320             ;------------------------------------------------------------------------------
0767   0320 F5          BPRINT:			PUSH		AF
0768   0321 7E          BPR:			LD   		A,(HL)				; Get character
0769   0322 FE 00       				CP   		EOS					; Is it $00 ?
0770   0324 28 07       				JR  		Z,BPEX				; Then RETurn on terminator
0771   0326 CD 5C 01    				CALL  		TXB					; Print it to serial port B
0772   0329 23          				INC  		HL					; Next Character
0773   032A C3 21 03    				JP   		BPR					; Continue until $00
0774   032D             				
0775   032D F1          BPEX:			POP			AF
0776   032E C9          				RET
0777   032F             
0778   032F             TXBCRLF:
0779   032F 3E 0D       				LD   		A,CR				; 
0780   0331 CD 5C 01    				CALL  		TXB					; Print character 
0781   0334 3E 0A       				LD   		A,LF				; 
0782   0336 CD 5C 01    				CALL  		TXB					; Print character
0783   0339 C9          				RET
0784   033A             
0785   033A             ;------------------------------------------------------------------------------
0786   033A             ; Take a line of text as input, handle special characters
0787   033A             ;------------------------------------------------------------------------------
0788   033A             CINPUT:
0789   033A E5          				PUSH		HL					; Push the contents of HL (whatever they are) onto the stack
0790   033B             NOBS:
0791   033B 3E 00       				LD			A,0					; Input a string to (HL), interpreting control characters.
0792   033D 77          				LD			(HL),A				; Clear any previous commands
0793   033E 47          				LD			B,A					; Character count stored in B - reset to 0
0794   033F             INPUTL:
0795   033F CD DB 00    				CALL		RXA					; Get a character from the ACIA
0796   0342 FE 08       				CP			BKSP				; Backspace? (Set in basic.asm)
0797   0344 CA 5A 03    				JP			Z,INBS				; Go to backspace function
0798   0347 FE 7F       				CP			DEL					; Delete? (Set in basic.asm)
0799   0349 CA 5A 03    				JP			Z,INBS				; Go to backspace function
0800   034C FE 0D       				CP			13					; Return
0801   034E CA 67 03    				JP			Z,INPUTX
0802   0351 77          				LD			(HL),A
0803   0352 23          				INC			HL
0804   0353 04          				INC			B
0805   0354 CD 48 01    				CALL		TXA					; Echo character
0806   0357 C3 3F 03    				JP			INPUTL
0807   035A             
0808   035A             INBS:
0809   035A 05          				DEC			B					; Command length by 1
0810   035B FA 3B 03    				JP			M,NOBS				; If negative, no further backspace allowed
0811   035E F5          				PUSH		AF					; Store A contents on stack
0812   035F CD 6C 03    				CALL		DOBKSP				; Backspace
0813   0362 F1          				POP			AF					; Restore A
0814   0363 2B          				DEC			HL					; Move the buffer point back one
0815   0364 C3 3F 03    				JP			INPUTL				
0816   0367             
0817   0367             INPUTX:
0818   0367 CD 86 02    				CALL		CRLF				; Print new line
0819   036A E1          				POP			HL					; Restore the contents of HL from the stack (buffer location)
0820   036B C9          				RET								; Return to the COMMAND routine
0821   036C             
0822   036C             ;------------------------------------------------------------------------------
0823   036C             ; BACKSPACE
0824   036C             ; Destroys A
0825   036C             ;------------------------------------------------------------------------------				
0826   036C 3E 08       DOBKSP:			LD			A,8					; Backspace
0827   036E CD 48 01    				CALL		TXA					; Transmit the backspace
0828   0371 3E 20       				LD			A,' '				; Rubout
0829   0373 CD 48 01    				CALL		TXA					; Rubout the previous character
0830   0376 3E 08       				LD			A,8					; Backspace
0831   0378 CD 48 01    				CALL		TXA					; Transmit the backspace again
0832   037B C9          				RET
0833   037C             				
0834   037C             ;------------------------------------------------------------------------------
0835   037C             ; Custom code can go here, otherwise default to cold start
0836   037C             ;------------------------------------------------------------------------------
0837   037C             USRCODE:
0838   037C E1          				POP			HL						; Dump command input from stack
0839   037D 3E 55       				LD			A,'U'
0840   037F CD 48 01    				CALL		TXA
0841   0382 3E 53       				LD			A,'S'
0842   0384 CD 48 01    				CALL		TXA
0843   0387 3E 52       				LD			A,'R'
0844   0389 CD 48 01    				CALL		TXA
0845   038C CD 86 02    				CALL		CRLF
0846   038F C3 63 02    				JP			COMMAND
0847   0392             
0848   0392             ;------------------------------------------------------------------------------
0849   0392             ; Cold-start BASIC
0850   0392             ;------------------------------------------------------------------------------
0851   0392             COLDSTART:
0852   0392 E1          				POP			HL						; Dump command input from stack
0853   0393 3E 42       				LD        	A,'B'           		; Set the BASIC STARTED flag
0854   0395 32 8A 40    				LD        	(basicStarted),A
0855   0398 C3 00 20    				JP        	BASCLD					; Start BASIC COLD
0856   039B             
0857   039B             ;------------------------------------------------------------------------------
0858   039B             ; Print the welcome message again
0859   039B             ;------------------------------------------------------------------------------
0860   039B             VER:
0861   039B E1          				POP			HL						; Dump command input from stack
0862   039C 21 EF 09    				LD			HL,SIGNON1
0863   039F CD 0C 03    				CALL		MPRINT
0864   03A2 21 9C 0B    				LD			HL,DMMSG
0865   03A5 CD 0C 03    				CALL		MPRINT
0866   03A8 C3 63 02    				JP			COMMAND
0867   03AB             
0868   03AB             ;------------------------------------------------------------------------------
0869   03AB             ; PSG test commands - takes an address from the command line and writes it to
0870   03AB             ; the PSG IO port, or reads the IO port value
0871   03AB             ;------------------------------------------------------------------------------
0872   03AB             CPSGOUT:
0873   03AB E1          				POP			HL						; Get command line pointer
0874   03AC CD 58 06    				CALL		GETBYTE					; Get 1-byte value from command line
0875   03AF 21 E0 0C    				LD			HL,AYPWRITE				; Display the port write text
0876   03B2 CD 0C 03    				CALL		MPRINT
0877   03B5 7B          				LD			A,E						; Load value into A
0878   03B6 CD 84 06    				CALL		PHEX					; Display it...
0879   03B9 3E 68       				LD			A,'h'					; ...with an 'H' on the end
0880   03BB CD 48 01    				CALL		TXA
0881   03BE             				
0882   03BE             				; Set IOA to OUTPUT
0883   03BE 3E 07       				LD			A,$07					; Select address R7 (select ENABLE register)
0884   03C0 D3 08       				OUT			(AY_LATCH),A			; Latch address R7
0885   03C2 3E 40       				LD			A,AY_OUTPUT				; 
0886   03C4 D3 09       				OUT			(AY_WRITE),A			; Set R7 to 40H (IOA set to output)
0887   03C6             				
0888   03C6             				; Set value in IOA
0889   03C6 3E 0E       				LD			A,AY_IO_ADDR			; Load A with IOA Register address
0890   03C8 D3 08       				OUT			(AY_LATCH),A			; Latch register in PSG
0891   03CA 7B          				LD			A,E						; Load A with value
0892   03CB D3 09       				OUT			(AY_WRITE),A			; Write value to PSG
0893   03CD             				
0894   03CD C3 63 02    				JP			COMMAND					; Return to Direct Mode CLI
0895   03D0             				
0896   03D0             CPSGIN:
0897   03D0 E1          				POP			HL						; Dump command line pointer
0898   03D1 21 CC 0C    				LD			HL,AYPREAD				; Display read text
0899   03D4 CD 0C 03    				CALL		MPRINT
0900   03D7             				
0901   03D7             				; Set IOA to INPUT
0902   03D7 3E 07       				LD			A,$07					; Select address R7 (select ENABLE register)
0903   03D9 D3 08       				OUT			(AY_LATCH),A			; Latch address R7
0904   03DB 3E 00       				LD			A,0
0905   03DD D3 09       				OUT			(AY_WRITE),A			; Set R7 to 0 (IOA set to input)
0906   03DF             				
0907   03DF             				; Read IOA
0908   03DF 3E 0E       				LD			A,AY_IO_ADDR			; Load A with IOA Register address
0909   03E1 D3 08       				OUT			(AY_LATCH),A			; Latch register in PSG
0910   03E3 DB 08       				IN			A,(AY_READ)				; Read register
0911   03E5             				
0912   03E5 CD 84 06    				CALL		PHEX					; Print the result
0913   03E8 3E 68       				LD			A,'h'					; ...with an 'h' on the end
0914   03EA CD 48 01    				CALL		TXA
0915   03ED             				
0916   03ED C3 63 02    				JP			COMMAND					; Return to Direct Mode CLI
0917   03F0             				
0918   03F0             CPSGERR:		; There was an error in the IO access (this routine not used)
0919   03F0 21 86 0B    				LD			HL,IOERR
0920   03F3 CD 0C 03    				CALL		MPRINT
0921   03F6 C3 63 02    				JP			COMMAND
0922   03F9             
0923   03F9             ;------------------------------------------------------------------------------
0924   03F9             ; CTC CLOCK Interrupt Setup - Should fire every second (depends on system clock frequency)
0925   03F9             ; Because of the way the clock division works (CPU_CLOCK/(TO2 output)^2), a value of 200
0926   03F9             ; had to be chosen for TO2, as 200^2 = 40000, so the first division results in 100, making
0927   03F9             ; the second division easy (100/100 = 1 interrupt per second, pretty much precisely.)
0928   03F9             ;------------------------------------------------------------------------------
0929   03F9             CTCCLK:
0930   03F9 3E 00       				LD			A,$00
0931   03FB 32 8E 40    				LD			(CLKMEM),A				; Initialise memory location used to
0932   03FE 32 8F 40    				LD			(CLKMEM+1),A			; store the 16-bit seconds counter
0933   0401             				
0934   0401             				; init CH2, which divides CPU CLK by 65536 providing a clock signal
0935   0401             				; at TO2. TO2 should be connected to TRG3.
0936   0401 3E 27       				LD			A,00100111b				; int off, timer on, prescaler=256, no ext. start,
0937   0403             													; start upon loading time constant, time constant
0938   0403             													; follows, sw reset, this is a ctrl cmd
0939   0403 D3 1A       				OUT			(CTC_2),A
0940   0405 3E C8       				LD			A,0C8h					; Time constant 200 defined
0941   0407 D3 1A       				OUT			(CTC_2),A				; and loaded into channel 2 (where it's squared)
0942   0409             													; TO2 outputs f=CPU_CLK (4 MHz)/ 40000 = 100
0943   0409             				
0944   0409             				; init CH3 - input TRG of CH3 is supplied by clock signal from TO2
0945   0409             				; CH3 divides TO2 clock by AFh
0946   0409             				; CH3 interrupts CPU appr. every 2 secs to service int routine CTC_Int
0947   0409 3E C7       				LD			A,11000111b				; int on, counter on, prescaler don't care, edge
0948   040B             													; don't care, time trigger don't care, time
0949   040B             													; constant follows, sw reset, this is ctrl cmd
0950   040B D3 1B       				OUT			(CTC_3),A
0951   040D 3E 64       				LD			A,064h					; Time constant 64h defined
0952   040F D3 1B       				OUT			(CTC_3),A				; and loaded into channel 3
0953   0411             													; This will divide TO2 by 100 for one
0954   0411             													; interrupt per minute
0955   0411             				
0956   0411 3E 58       				LD			A,58h					; Int vector defined in bit 7-3, bit 2-1 don't care,
0957   0413             													; bit 0 = 0 (for vector)
0958   0413 D3 18       				OUT			(CTC_0),A				; and loaded into channel 0
0959   0415             				
0960   0415 C9          				RET
0961   0416             
0962   0416             ;------------------------------------------------------------------------------				 
0963   0416             ; Test serial Tx to the Support Module
0964   0416             ; Destroys A
0965   0416             ;------------------------------------------------------------------------------
0966   0416             SM_TX:
0967   0416 E1          				POP			HL						; Dump command line pointer
0968   0417 21 19 0C    				LD			HL,BTSTMSG				; Transmit a single 'X'
0969   041A CD 20 03    				CALL		BPRINT					; to Port B
0970   041D C3 63 02    				JP			COMMAND
0971   0420             				
0972   0420             ;------------------------------------------------------------------------------				 
0973   0420             ; Display 256 bytes of memory starting at 16-bit pointer (HL)
0974   0420             ; Destroys DE, HL
0975   0420             ;------------------------------------------------------------------------------
0976   0420             MEMD:
0977   0420 E1          				POP			HL						; Get command input
0978   0421 CD 4F 06    				CALL		GETD					; Get memory address
0979   0424 EB          				EX			DE,HL					; Swap it into HL
0980   0425 CD CE 04    				CALL		MEMV					; Display 256 bytes
0981   0428 C3 63 02    				JP			COMMAND					; Return to command interpreter
0982   042B             				
0983   042B             ;------------------------------------------------------------------------------				 
0984   042B             ; MEMX - Memory Editor
0985   042B             ;------------------------------------------------------------------------------
0986   042B             MEMX:
0987   042B E1          				POP			HL						; Get command input to display
0988   042C CD 4F 06    				CALL		GETD					; the first 256 bytes from the
0989   042F EB          				EX			DE,HL					; address provided after the command
0990   0430             PRMEMX:
0991   0430 3E 0C       				LD			A,MCLS					; Clear screen
0992   0432 CD 48 01    				CALL		TXA
0993   0435 E5          				PUSH		HL						; Store the current address on the stack
0994   0436 CD CE 04    				CALL		MEMV					; Display 256 bytes
0995   0439 CD 86 02    				CALL		CRLF
0996   043C 21 51 0C    				LD			HL,MEMXMNU			; Load the MEMX command list string
0997   043F CD 0C 03    				CALL		MPRINT					; Print it
0998   0442 E1          				POP			HL						; Restore the current memory page address
0999   0443             MEMXIL:
1000   0443 CD DB 00    				CALL		RXA						; Get input char
1001   0446 FE 2C       				CP			','
1002   0448 CA 78 04    				JP			Z,BKMEMX				; Display previous 256 bytes
1003   044B FE 2E       				CP			'.'
1004   044D CA 88 04    				JP			Z,NXMEMX				; Display next 256 bytes
1005   0450 FE 58       				CP			'X'
1006   0452 CA 63 02    				JP			Z,COMMAND			; Return to command interpreter
1007   0455 FE 78       				CP			'x'
1008   0457 CA 63 02    				JP			Z,COMMAND			; Return to command interpreter
1009   045A FE 50       				CP			'P'
1010   045C CA AC 04    				JP			Z,MEMXPK				; Poke a value into memory
1011   045F FE 70       				CP			'p'
1012   0461 CA AC 04    				JP			Z,MEMXPK				; Poke a value into memory
1013   0464 FE 47       				CP			'G'
1014   0466 CA 98 04    				JP			Z,MEMXGO2			; Jump to address location
1015   0469 FE 67       				CP			'g'
1016   046B CA 98 04    				JP			Z,MEMXGO2			; Jump to address location
1017   046E             				; No commands recognised
1018   046E C3 43 04    				JP			MEMXIL					; Default behaviour for unrecognized commands - loop
1019   0471             
1020   0471             RTCLOOP:
1021   0471 D1          				POP			DE						; Restore DE contents
1022   0472 CD 86 02    				CALL		CRLF						; New line
1023   0475 C3 30 04    				JP			PRMEMX				; Display memory location in HL
1024   0478             				
1025   0478             BKMEMX:
1026   0478 D5          				PUSH		DE						; Preserve contents of DE registers
1027   0479 11 00 01    				LD			DE,$0100				; Load value 256 into DE register
1028   047C A7          				AND			A							; Clear carry flag
1029   047D ED 52       				SBC			HL,DE					; Subtract DE from HL as a 16-bit op
1030   047F D2 71 04    				JP			NC,RTCLOOP			; No carry, display the new memory location
1031   0482 21 00 FF    				LD			HL,$FF00				; Trying to go past start of RAM, so
1032   0485             															; set the address to the top ($FF00H)
1033   0485 C3 71 04    				JP			RTCLOOP				; Display the new memory location
1034   0488             
1035   0488             NXMEMX:
1036   0488 D5          				PUSH		DE						; Preserve contents of DE registers
1037   0489 11 00 01    				LD			DE,$0100				; Load value 256 into DE register
1038   048C A7          				AND			A							; Clear carry flag
1039   048D ED 5A       				ADC			HL,DE					; Subtract DE from HL as a 16-bit op
1040   048F D2 71 04    				JP			NC,RTCLOOP			; No carry, display the new memory location
1041   0492 21 00 00    				LD			HL,$0000				; Trying to go past end of RAM, so
1042   0495             															; set the address to the bottom ($0000H)
1043   0495 C3 71 04    				JP			RTCLOOP				; Display the new memory location
1044   0498             
1045   0498             ;------------------------------------------------------------------------------
1046   0498             ; MEMX - GOTO a memory address
1047   0498             ;------------------------------------------------------------------------------
1048   0498             MEMXGO2:
1049   0498 3E 0D       				LD			A,CR						; Reset cursor on line to overwrite the 'MEMX:' prompt
1050   049A CD 48 01    				CALL		TXA
1051   049D 21 9D 0C    				LD			HL,MEMXEAI			; Point to address entry text
1052   04A0 CD 0C 03    				CALL		MPRINT					; Print it
1053   04A3 CD 50 08    				CALL		GETHL					; Get 4 hex chars from console and pop into HL
1054   04A6 CD 86 02    				CALL		CRLF						; New line
1055   04A9 C3 30 04    				JP			PRMEMX				; Display memory location in HL
1056   04AC             				
1057   04AC             ;------------------------------------------------------------------------------
1058   04AC             ; MEMX - POKE a value into RAM
1059   04AC             ;------------------------------------------------------------------------------
1060   04AC             MEMXPK:
1061   04AC E5          				PUSH		HL
1062   04AD 3E 0D       				LD			A,CR						; Reset cursor on line to overwrite the 'MEMX:' prompt
1063   04AF CD 48 01    				CALL		TXA
1064   04B2 21 9D 0C    				LD			HL,MEMXEAI			; Display address entry instruction
1065   04B5 CD 0C 03    				CALL		MPRINT					; Print it
1066   04B8 CD 50 08    				CALL		GETHL					; Get 4 hex chars from console and pop into HL
1067   04BB E5          				PUSH		HL						; Save POKE memory location
1068   04BC 21 B3 0C    				LD			HL,MEMXEDI			; Display value entry instruction
1069   04BF CD 0C 03    				CALL		MPRINT					; Print it
1070   04C2 CD 2D 08    				CALL		GET2A					; Get two hex chars and convert to byte in A
1071   04C5 E1          				POP			HL						; Restore HL (POKE memory address)
1072   04C6 77          				LD			(HL),A					; Set address (HL) to A
1073   04C7 CD 86 02    				CALL		CRLF
1074   04CA E1          				POP			HL						; Restore current memory page address
1075   04CB C3 30 04    				JP			PRMEMX				; Display current memory location in HL
1076   04CE             
1077   04CE             ;------------------------------------------------------------------------------
1078   04CE             ; Displays 256 bytes of memory starting at 16-bit pointer (HL)
1079   04CE             ;------------------------------------------------------------------------------
1080   04CE             MEMV:
1081   04CE 06 10       				LD			B,16				; Row register
1082   04D0             				; Display column address headers
1083   04D0 06 05       				LD			B,5					; Number of spaces to print to get to first column
1084   04D2             MEMH:
1085   04D2 3E 20       				LD			A,' '				; Print that many spaces
1086   04D4 CD 48 01    				CALL		TXA
1087   04D7 05          				DEC			B
1088   04D8 C2 D2 04    				JP			NZ,MEMH
1089   04DB E5          				PUSH		HL					; Save the start address on the stack
1090   04DC             				; Print column address headers
1091   04DC 06 10       				LD			B,16				; Number of headers
1092   04DE             MEMAH:
1093   04DE 7D          				LD			A,L					; Load LSB of address into A
1094   04DF CD 84 06    				CALL		PHEX
1095   04E2 3E 20       				LD			A,' '
1096   04E4 CD 48 01    				CALL		TXA
1097   04E7 23          				INC			HL
1098   04E8 05          				DEC			B
1099   04E9 C2 DE 04    				JP			NZ,MEMAH		
1100   04EC             				; Display the memory rows
1101   04EC CD 86 02    				CALL		CRLF				; New line ready for data
1102   04EF E1          				POP			HL					; Reset HL back to start memory address
1103   04F0 06 10       				LD			B,16				; Reset row register
1104   04F2             				; Print the address of this line
1105   04F2 E5          MEMD1:			PUSH		HL					; Store start address for this line
1106   04F3 C5          				PUSH		BC					; Store MSB count (B register)
1107   04F4 7C          				LD			A,H
1108   04F5 CD 84 06    				CALL		PHEX
1109   04F8 7D          				LD			A,L
1110   04F9 CD 84 06    				CALL		PHEX
1111   04FC 3E 20       				LD			A,' '
1112   04FE CD 48 01    				CALL		TXA
1113   0501 06 10       				LD			B,16				; 16 digits to print
1114   0503             				; Print the 16 memory addresses for this line in hex
1115   0503 7E          MEMD2:			LD			A,(HL)
1116   0504 CD 84 06    				CALL		PHEX
1117   0507 3E 20       				LD			A,' '
1118   0509 CD 48 01    				CALL		TXA
1119   050C 23          				INC			HL
1120   050D 05          				DEC			B
1121   050E C2 03 05    				JP			NZ,MEMD2
1122   0511 3E 20       				LD			A,' '				; Print a space before the ASCII
1123   0513 CD 48 01    				CALL		TXA
1124   0516 C1          				POP			BC					; Pop off stack to get to HL below it
1125   0517 E1          				POP			HL					; Restore HL to start of address line
1126   0518 C5          				PUSH		BC					; Store BC again
1127   0519 06 10       				LD 			B,16				; Reset row register
1128   051B             				; Print the ASCII version of the line
1129   051B 7E          MEMASC2:		LD			A,(HL)
1130   051C CD 2D 05    				CALL		PASCII
1131   051F 23          				INC			HL
1132   0520 05          				DEC			B
1133   0521 C2 1B 05    				JP			NZ,MEMASC2
1134   0524 CD 86 02    				CALL		CRLF
1135   0527 C1          				POP			BC
1136   0528 05          				DEC			B
1137   0529 C2 F2 04    				JP			NZ,MEMD1
1138   052C C9          				RET
1139   052D             				
1140   052D             ;------------------------------------------------------------------------------
1141   052D             ; Prints the value in the A register as an ASCII character if it is valid,
1142   052D             ; otherwise a full-stop if not
1143   052D             ;------------------------------------------------------------------------------
1144   052D             PASCII:
1145   052D FE 20       				CP			$20					; Is it a space?
1146   052F CA 46 05    				JP			Z,PSPC				; Yes - print a space
1147   0532 FE 21       				CP      	'!'             	; Less than '!' ?
1148   0534 DA 40 05            		JP      	C,PDOT	        	; Yes - print a full stop
1149   0537 FE 7F               		CP      	'~'+1           	; Greater than '~' ?
1150   0539 D2 40 05            		JP      	NC,PDOT		   		; Yes - print a full stop
1151   053C CD 48 01            		CALL		TXA					; Is ASCII, print it
1152   053F C9          				RET
1153   0540             
1154   0540             PDOT:
1155   0540 3E 2E       				LD			A,'.'
1156   0542 CD 48 01    				CALL		TXA
1157   0545 C9          				RET
1158   0546             				
1159   0546             PSPC:
1160   0546 3E 20       				LD			A,' '
1161   0548 CD 48 01    				CALL		TXA
1162   054B C9          				RET
1163   054C             
1164   054C             ;------------------------------------------------------------------------------
1165   054C             ; Display 16-bit value in (HL) as human-readable time
1166   054C             ; HL points to memory location of 16-bit word, which is treated as seconds count
1167   054C             ;------------------------------------------------------------------------------
1168   054C             HL_TO_HRT:		; Divide HL by 3600 for hours
1169   054C             				; Divide remainder by 60 for minutes
1170   054C             				; Remainder is seconds
1171   054C             				
1172   054C F5          				PUSH		AF
1173   054D C5          				PUSH		BC
1174   054E E5          				PUSH		HL
1175   054F D5          				PUSH		DE
1176   0550             
1177   0550 E5          				PUSH		HL				; Load seconds count into BC
1178   0551 C1          				POP			BC				;
1179   0552             				
1180   0552 11 10 0E    				LD			DE,0E10h		; Load divisor into DE (3,600)
1181   0555 CD 7A 05    				CALL		Div16			; Divide BC by DE
1182   0558             				; BC is the number of hours, HL is the remainder
1183   0558             				
1184   0558 CD A0 05    				CALL		DECBC			; Print content of BC
1185   055B 3E 3A       				LD			A,':'			; Print separator
1186   055D CD 48 01    				CALL		TXA
1187   0560             				
1188   0560 E5          				PUSH		HL				; Swap the remainder into BC
1189   0561 C1          				POP			BC				;
1190   0562 11 3C 00    				LD			DE,03Ch			; 60
1191   0565 CD 7A 05    				CALL		Div16
1192   0568             				; BC is now number of minutes, HL is the remainder
1193   0568             				
1194   0568 CD A0 05    				CALL		DECBC			; Print content of BC
1195   056B 3E 3A       				LD			A,':'			; Print separator
1196   056D CD 48 01    				CALL		TXA
1197   0570             				
1198   0570 E5          				PUSH		HL				; Swap the remainder into BC
1199   0571 C1          				POP			BC				;
1200   0572             				; BC is now number of seconds
1201   0572             				
1202   0572 CD A0 05    				CALL		DECBC			; Print content of BC
1203   0575             
1204   0575 D1          				POP			DE
1205   0576 E1          				POP			HL
1206   0577 C1          				POP			BC
1207   0578 F1          				POP			AF
1208   0579             				
1209   0579 C9          				RET
1210   057A             				
1211   057A             ;------------------------------------------------------------------------------
1212   057A             ; Divide BC by DE, storing the result in BC, remainder in HL
1213   057A             ;------------------------------------------------------------------------------				
1214   057A             Div16:
1215   057A 21 00 00    				ld 			hl,0
1216   057D 78          				ld 			a,b
1217   057E 06 08       				ld 			b,8
1218   0580             Div16_Loop1:
1219   0580 17          				rla
1220   0581 ED 6A       				adc 		hl,hl
1221   0583 ED 52       				sbc 		hl,de
1222   0585 30 01       				jr 			nc,Div16_NoAdd1
1223   0587 19          				add 		hl,de
1224   0588             Div16_NoAdd1:
1225   0588 10 F6       				djnz 		Div16_Loop1
1226   058A 17          				rla
1227   058B 2F          				cpl
1228   058C 47          				ld 			b,a
1229   058D 79          				ld 			a,c
1230   058E 48          				ld 			c,b
1231   058F 06 08       				ld 			b,8
1232   0591             Div16_Loop2:
1233   0591 17          				rla
1234   0592 ED 6A       				adc 		hl,hl
1235   0594 ED 52       				sbc 		hl,de
1236   0596 30 01       				jr 			nc,Div16_NoAdd2
1237   0598 19          				add 		hl,de
1238   0599             Div16_NoAdd2:
1239   0599 10 F6       				djnz 		Div16_Loop2
1240   059B 17          				rla
1241   059C 2F          				cpl
1242   059D 41          				ld 			b,c
1243   059E 4F          				ld 			c,a
1244   059F C9          				ret
1245   05A0             
1246   05A0             ;------------------------------------------------------------------------------
1247   05A0             ; Display 8-bit value in C as 2-digit decimal ASCII
1248   05A0             ;------------------------------------------------------------------------------
1249   05A0             DECBC:
1250   05A0 F5          				PUSH		AF
1251   05A1 C5          				PUSH		BC
1252   05A2 E5          				PUSH		HL
1253   05A3 D5          				PUSH		DE
1254   05A4             				
1255   05A4 3E 00       				LD			A,0				; Set LZ_FLAG to zero so leading zeros
1256   05A6 32 90 40    				LD			(LZ_FLAG),A		; are not printed out
1257   05A9             				
1258   05A9 C5          				PUSH		BC				; Swap BC into HL
1259   05AA E1          				POP			HL
1260   05AB             				
1261   05AB             				; Display leading zero if L is less than 10
1262   05AB 7D          				LD			A,L
1263   05AC FE 0A       				CP			10
1264   05AE D2 B6 05    				JP			NC,DBC0
1265   05B1 3E 30       				LD			A,'0'
1266   05B3 CD 48 01    				CALL		TXA
1267   05B6             				
1268   05B6 01 9C FF    DBC0:			LD			BC,-100
1269   05B9 CD C4 05    				CALL		DBC1
1270   05BC 0E F6       				LD			C,-10
1271   05BE CD C4 05    				CALL		DBC1
1272   05C1 C3 E6 05    				JP			DBC3
1273   05C4             				
1274   05C4 3E 2F       DBC1:			LD			A,'0'-1
1275   05C6 3C          DBC2:			INC			A
1276   05C7 09          				ADD			HL,BC
1277   05C8 38 FC       				JR			C,DBC2
1278   05CA ED 42       				SBC			HL,BC
1279   05CC FE 30       				CP			'0'				; Check for a zero
1280   05CE C2 DD 05    				JP			NZ,DBCX			; Display if it's not a zero
1281   05D1 3A 90 40    				LD			A,(LZ_FLAG)		; Is a zero, so check LZ_FLAG to see if we
1282   05D4 FE FF       				CP			0FFh			; are not in leading zeros any more
1283   05D6 C0          				RET			NZ				; We are, so don't print the zero
1284   05D7 3E 30       				LD			A,'0'			; We're not, so print the zero
1285   05D9 CD 48 01    				CALL		TXA
1286   05DC C9          				RET
1287   05DD             				
1288   05DD CD 48 01    DBCX:			CALL 		TXA				; Print the number
1289   05E0 3E FF       				LD			A,0FFh			; Set the flag value
1290   05E2 32 90 40    				LD			(LZ_FLAG),A		; And set the flag so further non-leading
1291   05E5 C9          				RET							; zeros can be printed
1292   05E6             				
1293   05E6 0E FF       DBC3:			LD			C,-1
1294   05E8 3E 2F       				LD			A,'0'-1
1295   05EA 3C          DBC4:			INC			A
1296   05EB 09          				ADD			HL,BC
1297   05EC 38 FC       				JR			C,DBC4
1298   05EE ED 42       				SBC			HL,BC
1299   05F0 CD 48 01    				CALL 		TXA
1300   05F3             				
1301   05F3 D1          				POP			DE
1302   05F4 E1          				POP			HL
1303   05F5 C1          				POP			BC
1304   05F6 F1          				POP			AF
1305   05F7             				
1306   05F7 C9          				RET 
1307   05F8             				
1308   05F8             ;------------------------------------------------------------------------------
1309   05F8             ; Display 16-bit value in HL as decimal ASCII without leading zeros
1310   05F8             ;------------------------------------------------------------------------------
1311   05F8             DECHL:
1312   05F8 F5          				PUSH		AF
1313   05F9 C5          				PUSH		BC
1314   05FA E5          				PUSH		HL
1315   05FB D5          				PUSH		DE
1316   05FC             				
1317   05FC 3E 00       				LD			A,0				; Set LZ_FLAG to zero so leading zeros
1318   05FE 32 90 40    				LD			(LZ_FLAG),A		; are not printed out
1319   0601             				
1320   0601 01 F0 D8    				LD			BC,-10000
1321   0604 CD 1B 06    				CALL		NUM1
1322   0607 01 18 FC    				LD			BC,-1000
1323   060A CD 1B 06    				CALL		NUM1
1324   060D 01 9C FF    				LD			BC,-100
1325   0610 CD 1B 06    				CALL		NUM1
1326   0613 0E F6       				LD			C,-10
1327   0615 CD 1B 06    				CALL		NUM1
1328   0618 C3 3D 06    				JP			NUM3
1329   061B             				
1330   061B 3E 2F       NUM1:			LD			A,'0'-1
1331   061D 3C          NUM2:			INC			A
1332   061E 09          				ADD			HL,BC
1333   061F 38 FC       				JR			C,NUM2
1334   0621 ED 42       				SBC			HL,BC
1335   0623 FE 30       				CP			'0'				; Check for a zero
1336   0625 C2 34 06    				JP			NZ,NUMX			; Display if it's not a zero
1337   0628 3A 90 40    				LD			A,(LZ_FLAG)		; Is a zero, so check LZ_FLAG to see if we
1338   062B FE FF       				CP			0FFh			; are not in leading zeros any more
1339   062D C0          				RET			NZ				; We are, so don't print the zero
1340   062E 3E 30       				LD			A,'0'			; We're not, so print the zero
1341   0630 CD 48 01    				CALL		TXA
1342   0633 C9          				RET
1343   0634             				
1344   0634 CD 48 01    NUMX:			CALL 		TXA				; Print the number
1345   0637 3E FF       				LD			A,0FFh			; Set the flag value
1346   0639 32 90 40    				LD			(LZ_FLAG),A		; And set the flag so further non-leading
1347   063C C9          				RET							; zeros can be printed
1348   063D             				
1349   063D 0E FF       NUM3:			LD			C,-1
1350   063F 3E 2F       				LD			A,'0'-1
1351   0641 3C          NUM4:			INC			A
1352   0642 09          				ADD			HL,BC
1353   0643 38 FC       				JR			C,NUM4
1354   0645 ED 42       				SBC			HL,BC
1355   0647 CD 48 01    				CALL 		TXA
1356   064A             				
1357   064A D1          				POP			DE
1358   064B E1          				POP			HL
1359   064C C1          				POP			BC
1360   064D F1          				POP			AF
1361   064E             				
1362   064E C9          				RET 
1363   064F             
1364   064F             ;------------------------------------------------------------------------------
1365   064F             ; Get four ASCII hex digits from (HL), convert to a 16-bit word in DE
1366   064F             ;------------------------------------------------------------------------------
1367   064F             GETD:
1368   064F CD 5D 06    				CALL		GETHX
1369   0652 57          				LD			D,A
1370   0653 CD 5D 06    				CALL		GETHX
1371   0656 5F          				LD			E,A
1372   0657 C9          				RET
1373   0658             				
1374   0658             ;------------------------------------------------------------------------------
1375   0658             ; Get 2 ASCII hex digits from (HL), convert to an 8-bit byte in E
1376   0658             ;------------------------------------------------------------------------------
1377   0658             GETBYTE:
1378   0658 CD 5D 06    				CALL		GETHX
1379   065B 5F          				LD			E,A
1380   065C C9          				RET
1381   065D             
1382   065D             ;------------------------------------------------------------------------------
1383   065D             ; Get 2 ASCII hex digits pointed to by (HL), convert to a byte in A
1384   065D             ;------------------------------------------------------------------------------
1385   065D             GETHX:
1386   065D 06 00       				LD			B,0
1387   065F CD 67 06    				CALL		GETH1
1388   0662 07          				RLCA
1389   0663 07          				RLCA
1390   0664 07          				RLCA
1391   0665 07          				RLCA
1392   0666 47          				LD			B,A
1393   0667             GETH1:
1394   0667 7E          				LD			A,(HL)
1395   0668 FE 20       				CP			' '						; If first char is a space, ignore it
1396   066A C2 6F 06    				JP			NZ,GETH11		; Not a space, carry on
1397   066D 23          				INC			HL					; Is a space, skip past it
1398   066E 7E          				LD			A,(HL)
1399   066F             GETH11:											; Convert the value in A to an ASCII HEX char
1400   066F E6 70       				AND			070h
1401   0671 FE 40       				CP			040h
1402   0673 DA 7E 06    				JP			C,GETH2
1403   0676 7E          				LD			A,(HL)
1404   0677 E6 0F       				AND			00Fh
1405   0679 C6 09       				ADD			A,9
1406   067B C3 81 06    				JP			GETH3
1407   067E             GETH2:
1408   067E 7E          				LD			A,(HL)
1409   067F E6 0F       				AND			00Fh
1410   0681             GETH3:
1411   0681 23          				INC			HL
1412   0682 B0          				OR 			B
1413   0683 C9          				RET
1414   0684             				
1415   0684             ;------------------------------------------------------------------------------
1416   0684             ; Print content of A as an ASCII hex number
1417   0684             ;------------------------------------------------------------------------------
1418   0684             PHEX:
1419   0684 32 8C 40    				LD			(CHRBUF),A			; Preserve content of A register
1420   0687 E6 F0       				AND			0F0h
1421   0689 0F          				RRCA
1422   068A 0F          				RRCA
1423   068B 0F          				RRCA
1424   068C 0F          				RRCA
1425   068D CD 90 06    				CALL		PHEX1
1426   0690             PHEX1:
1427   0690 E6 0F       				AND			00Fh
1428   0692 FE 0A       				CP			00Ah
1429   0694 DA 9E 06    				JP			C,PHEX2
1430   0697 D6 09       				SUB			009h
1431   0699 F6 40       				OR			040h
1432   069B C3 A0 06    				JP			PHEX3
1433   069E             PHEX2:
1434   069E F6 30       				OR			030h
1435   06A0             PHEX3:
1436   06A0 CD 48 01    				CALL		TXA
1437   06A3 3A 8C 40    				LD			A,(CHRBUF)			; Restore content of A register
1438   06A6 C9          				RET
1439   06A7             
1440   06A7             ;------------------------------------------------------------------------------
1441   06A7             ; Load an Intel Hex stream pasted into the console. Terminated by record type 1.
1442   06A7             ;------------------------------------------------------------------------------
1443   06A7             RHEX:
1444   06A7 E1          				POP			HL					; Discard command address
1445   06A8 21 CF 0B    				LD			HL,RHXMSG			; Load the instruction string
1446   06AB CD 0C 03    				CALL		MPRINT				; Print it
1447   06AE CD 86 02    				CALL		CRLF				; Newline ready for progress output
1448   06B1             RHEXA:			; Initial loop takes first few bytes of input line and stores the
1449   06B1             				; start address so it can be printed out at the end
1450   06B1 CD DB 00    				CALL		RXA					; Get next character
1451   06B4 FE 1B       				CP			ESC
1452   06B6 CA 63 02    				JP			Z,COMMAND			; ESC cancels operation
1453   06B9 FE 3A       				CP			':'					; Start of record?
1454   06BB C2 B1 06    				JP			NZ,RHEXA			; If not, wait until it is
1455   06BE CD 28 07    				CALL		INHEX				; Record length
1456   06C1 57          				LD			D,A					; Length counter
1457   06C2 CD 28 07    				CALL		INHEX				; Get target address high
1458   06C5 67          				LD			H,A					; Load it into H register
1459   06C6 CD 28 07    				CALL		INHEX				; Get target address low
1460   06C9 6F          				LD			L,A					; Load it into L register
1461   06CA E5          				PUSH		HL					; Store start address of code
1462   06CB CD 28 07    				CALL		INHEX				; Get record type
1463   06CE FE 01       				CP			1					; End of record?
1464   06D0 CA 0B 07    				JP			Z,ENDRHEX
1465   06D3 C3 FA 06    				JP			RHEXL
1466   06D6             RHEXI:			; This is the main loop - essentially a duplicate of RHEXA above,
1467   06D6             				; but this one doesn't overwrite the memory address on the stack
1468   06D6             				; and prevents the last memory address being displayed at the end
1469   06D6             				; instead of the first memory address
1470   06D6 CD DB 00    				CALL		RXA					; Get next character
1471   06D9 FE 1B       				CP			ESC
1472   06DB CA 63 02    				JP			Z,COMMAND			; ESC cancels operation
1473   06DE FE 3A       				CP			':'					; Start of record?
1474   06E0 C2 D6 06    				JP			NZ,RHEXI			; If not, wait until it is
1475   06E3 CD 28 07    				CALL		INHEX				; Record length
1476   06E6 57          				LD			D,A					; Length counter
1477   06E7 CD 28 07    				CALL		INHEX				; Get target address high
1478   06EA 67          				LD			H,A					; Load it into H register
1479   06EB CD 28 07    				CALL		INHEX				; Get target address low
1480   06EE 6F          				LD			L,A					; Load it into L register
1481   06EF CD 28 07    				CALL		INHEX				; Get record type
1482   06F2 FE 01       				CP			1					; End of record?
1483   06F4 CA 0B 07    				JP			Z,ENDRHEX
1484   06F7 CD 86 02    				CALL		CRLF				; Newline for next line of data
1485   06FA             				
1486   06FA             RHEXL:			; This loop loads in the data in the current line, before returning
1487   06FA             				; to RHEXI above to input the next line if there is one
1488   06FA CD 28 07    				CALL		INHEX
1489   06FD 77          				LD			(HL),A				; Load the value into the current memory address
1490   06FE 3E 2E       				LD			A,'.'				; Display a . for each byte entered
1491   0700 CD 48 01    				CALL		TXA					;
1492   0703 23          				INC			HL					; Increment to next memory address
1493   0704 15          				DEC			D					; Decrement record length counter
1494   0705 C2 FA 06    				JP			NZ,RHEXL
1495   0708 C3 D6 06    				JP			RHEXI				; Continue reading records
1496   070B             
1497   070B             ENDRHEX:		; Reached the end of the pasted code - nothing is done with the
1498   070B             				; checksum currently, but a final success message is printed out
1499   070B             				; displaying the start address of the loaded code
1500   070B CD 28 07    				CALL		INHEX					; Get checksum
1501   070E CD 86 02    				CALL		CRLF
1502   0711 21 39 0C    				LD			HL,RHXFMSG				; Load completed message
1503   0714 CD 0C 03    				CALL		MPRINT					; Print it
1504   0717 E1          				POP			HL						; Print the start address it was loaded at
1505   0718 7C          				LD			A,H
1506   0719 CD 84 06    				CALL		PHEX
1507   071C 7D          				LD			A,L
1508   071D CD 84 06    				CALL		PHEX
1509   0720 3E 48       				LD			A,'H'					; with an 'H' on the end as it's hexadecimal
1510   0722 CD 48 01    				CALL		TXA
1511   0725 C3 63 02    				JP			COMMAND					; Return to command prompt
1512   0728             INHEX:
1513   0728 06 00       				LD			B,0						; Input an ASCII hex digit to A from console
1514   072A CD 32 07    				CALL		INH1
1515   072D 07          				RLCA
1516   072E 07          				RLCA
1517   072F 07          				RLCA
1518   0730 07          				RLCA
1519   0731 47          				LD			B,A
1520   0732             INH1:
1521   0732 CD DB 00    				CALL		RXA
1522   0735 4F          				LD			C,A						; Copy A into C as the next instructions change A
1523   0736 E6 70       				AND			070h
1524   0738 FE 40       				CP			040h
1525   073A DA 45 07    				JP			C,INH2
1526   073D 79          				LD			A,C						; Restore A to original value
1527   073E E6 0F       				AND			00Fh
1528   0740 C6 09       				ADD			A,9
1529   0742 C3 48 07    				JP			INH3
1530   0745             INH2:
1531   0745 79          				LD			A,C						; Restore A to original value
1532   0746 E6 0F       				AND			00Fh
1533   0748             INH3:
1534   0748 B0          				OR			B
1535   0749 C9          				RET
1536   074A             
1537   074A             ;------------------------------------------------------------------------------
1538   074A             ; Basic IO commands - CPOUT outputs nnH (0-255) to port ppH (O pp,nn)
1539   074A             ;					- CPIN prints the value at port ppH (IN pp)
1540   074A             ;------------------------------------------------------------------------------
1541   074A             CPOUT:
1542   074A E1          				POP			HL
1543   074B CD 59 07    				CALL    	CSETIO				; Set up port number
1544   074E F5          				PUSH		AF					; Push the data to send onto the stack
1545   074F 3A 8B 40    				LD			A,(IO_ADDR)			; Get port address into A
1546   0752 4F          				LD			C,A					; Load the IO port into C
1547   0753 F1          				POP			AF					; Pop the data to send off the stack
1548   0754 ED 79       				OUT			(C),A				; Output data to port specified in C and return
1549   0756 C3 77 02    				JP			SHORTPROMPT
1550   0759             				
1551   0759             CSETIO:
1552   0759 CD 58 06    				CALL    	GETBYTE        		; Get 2 hex digits from 0-FF into E
1553   075C 7B          				LD			A,E					; Load port number into A
1554   075D 32 8B 40    				LD			(IO_ADDR),A			; Load IO port into IO_ADDR location
1555   0760 7E          				LD			A,(HL)				; Make sure ',' follows
1556   0761 FE 2C       				CP			','					; Check next char is a comma
1557   0763 C2 95 07    				JP			NZ,SHOWSYERR		; No - Error
1558   0766 23          				INC			HL
1559   0767 CD 58 06    				CALL    	GETBYTE	          	; Get 2 hex digits from 0 to FF
1560   076A 7B          				LD      	A,E					; Get LSB of number
1561   076B C9          				RET
1562   076C             
1563   076C             ;------------------------------------------------------------------------------
1564   076C             CPIN:
1565   076C E1          				POP			HL
1566   076D CD 84 07    				CALL    	CSETIN           	; Set up port number
1567   0770 3A 8B 40    				LD			A,(IO_ADDR)			; Get port address into A
1568   0773 4F          				LD			C,A					; Load the IO port into C
1569   0774 ED 78       				IN			A,(C)				; Output data to port specified in C and return
1570   0776 4F          				LD			C,A					; Copy the data to C
1571   0777 21 15 0B    				LD			HL,CINMSG			; Load the result string
1572   077A CD 0C 03    				CALL		MPRINT				; Print it
1573   077D 79          				LD			A,C					; Copy the port value into A
1574   077E CD 84 06    				CALL		PHEX				; Print it as a hex value
1575   0781 C3 63 02    				JP			COMMAND				; returning to input
1576   0784             				
1577   0784             CSETIN: 
1578   0784 CD 58 06    				CALL    	GETBYTE        		; Get 2 hex digits from 0-FF into E
1579   0787 7B          				LD			A,E					; Load port number into A
1580   0788 32 8B 40    				LD			(IO_ADDR),A			; Load IO port into IO_ADDR location
1581   078B C9          				RET
1582   078C             				
1583   078C             ;------------------------------------------------------------------------------
1584   078C             SHOWIOERR:
1585   078C 21 57 0B    				LD			HL,ERMSG			; Load error message
1586   078F CD 0C 03    				CALL		MPRINT				; Print the message
1587   0792 C3 63 02    				JP			COMMAND				; Return to command line
1588   0795             
1589   0795             ;------------------------------------------------------------------------------
1590   0795             SHOWSYERR:
1591   0795 21 8F 0B    				LD			HL,SYERR			; Load error message
1592   0798 CD 0C 03    				CALL		MPRINT				; Print the message
1593   079B C3 63 02    				JP			COMMAND				; Return to command line
1594   079E             
1595   079E             ;------------------------------------------------------------------------------
1596   079E             ; POKE command - write an 8-bit value to memory address nnnn - POKE nnnnH,ddH
1597   079E             ;------------------------------------------------------------------------------
1598   079E             CPOKE:
1599   079E E1          				POP			HL
1600   079F CD 4F 06    				CALL    	GETD        		; Get target address into DE
1601   07A2 D5          				PUSH		DE					; Save it on the stack
1602   07A3 7E          				LD			A,(HL)          	; Make sure ',' follows
1603   07A4 FE 2C       				CP			','					; Check next char is a comma
1604   07A6 C2 95 07    				JP			NZ,SHOWSYERR		; No - Error
1605   07A9 23          				INC			HL					; Next char should be data byte
1606   07AA CD 58 06    				CALL    	GETBYTE	          	; Get 2 hex digits from 0 to FF
1607   07AD 7B          				LD      	A,E           		; Get data byte into A
1608   07AE E1          				POP			HL					; Pop target address off stack into HL
1609   07AF 77          				LD			(HL),A				; Write data into target memory location
1610   07B0 C3 77 02    				JP			SHORTPROMPT
1611   07B3             
1612   07B3             ;------------------------------------------------------------------------------
1613   07B3             ; PEEK command - read an 8-bit value at memory address nnnn - PEEK nnnnH
1614   07B3             ;------------------------------------------------------------------------------
1615   07B3             CPEEK:
1616   07B3 E1          				POP			HL
1617   07B4 CD 4F 06    				CALL		GETD				; Get target address
1618   07B7 21 15 0B    				LD			HL,CINMSG			
1619   07BA CD 0C 03    				CALL		MPRINT
1620   07BD 1A          				LD			A,(DE)				; Load byte into A
1621   07BE CD 84 06    				CALL		PHEX				; Print it as hex
1622   07C1 3E 68       				LD			A,'h'
1623   07C3 CD 48 01    				CALL		TXA
1624   07C6 C3 63 02    				JP			COMMAND				; to main loop
1625   07C9             
1626   07C9             ;------------------------------------------------------------------------------
1627   07C9             ; TIME command - read an 16-bit value at memory address CLKMEM as seconds and
1628   07C9             ; display as a human-readable time in the CLI
1629   07C9             ;------------------------------------------------------------------------------
1630   07C9             CTIME:
1631   07C9 2A 8E 40    				LD			HL,(CLKMEM)			; Load seconds-since-boot
1632   07CC CD 4C 05    				CALL		HL_TO_HRT			; Display HL as time
1633   07CF 21 07 0C    				LD			HL,SECSMSG
1634   07D2 CD 0C 03    				CALL		MPRINT
1635   07D5             
1636   07D5 C3 63 02    				JP			COMMAND
1637   07D8             
1638   07D8             ;------------------------------------------------------------------------------
1639   07D8             ; Show HELP text - list of commands
1640   07D8             ; Registers used : HL,A
1641   07D8             ;------------------------------------------------------------------------------
1642   07D8             HELP:
1643   07D8 E1          				POP			HL					; Dump HL off the stack
1644   07D9 21 F4 0C    				LD			HL,CMDLIST			; Load the help command list string
1645   07DC CD 0C 03    				CALL		MPRINT				; You know the rest
1646   07DF C3 63 02    				JP			COMMAND
1647   07E2             
1648   07E2             ;------------------------------------------------------------------------------
1649   07E2             ; CALL address specified by user in CALL $nnnn command
1650   07E2             ; Registers used: HL,DE
1651   07E2             ;------------------------------------------------------------------------------
1652   07E2             CCALL:
1653   07E2 E1          				POP			HL
1654   07E3 CD 4F 06    				CALL		GETD				; Get a double ASCII word (16-bit)
1655   07E6 EB          				EX			DE, HL
1656   07E7 E9          				JP			(HL)				; CALL the code at that address
1657   07E8             
1658   07E8             ;------------------------------------------------------------------------------				 
1659   07E8             ; CLRMEM nnnn,dddd - Set ddddH bytes to zero from address nnnnH
1660   07E8             ; Registers used: AF,BC,DE,HL
1661   07E8             ;------------------------------------------------------------------------------
1662   07E8             CLEARM:
1663   07E8 E1          				POP			HL
1664   07E9 CD 4F 06    				CALL		GETD				; Get address to start from
1665   07EC D5          				PUSH		DE					; Save it on the stack
1666   07ED 7E          				LD			A,(HL)				; Make sure ',' follows
1667   07EE FE 2C       				CP			','					; Check next char is a comma
1668   07F0 C2 95 07    				JP			NZ,SHOWSYERR		; No - Error
1669   07F3 23          				INC			HL					; Next char
1670   07F4 CD 4F 06    				CALL		GETD				; Get length to clear
1671   07F7 D5          				PUSH		DE					; Swap area size into BC
1672   07F8 C1          				POP			BC
1673   07F9 E1          				POP			HL					; Load start address into HL		
1674   07FA 3E 00       				LD			A,0					; Set value to write
1675   07FC CD 02 08    				CALL		MFILL
1676   07FF C3 77 02    				JP			SHORTPROMPT			; Return to main loop, minus CRLF
1677   0802             				
1678   0802             MFILL:
1679   0802 77          				LD			(HL),A				; Fill first byte with value
1680   0803 54          				LD			D,H					; Destination ptr = source ptr + 1
1681   0804 5D          				LD			E,L
1682   0805 13          				INC			DE
1683   0806 0B          				DEC			BC					; Eliminate first byte from count
1684   0807 78          				LD			A,B					; Are there more bytes to fill?
1685   0808 B1          				OR			C
1686   0809 C8          				RET			Z					; No, return - size was 1
1687   080A ED B0       				LDIR							; Yes, use block move to fill rest
1688   080C             												; by moving value ahead 1 byte
1689   080C C9          				RET
1690   080D             
1691   080D             ;------------------------------------------------------------------------------				 
1692   080D             ; BASIC 'C/OLD' - Transfer to the BASIC interpreter after working out if a cold or 
1693   080D             ; warm start is needed, or a cold start is forced with optional C or COLD parameter
1694   080D             ;------------------------------------------------------------------------------
1695   080D             CBASIC:
1696   080D 3A 8A 40    				LD			A,(basicStarted)		; Check the BASIC STARTED flag
1697   0810 FE 42       				CP			'B'             			; to see if this is power-up
1698   0812 C2 92 03    				JP			NZ,COLDSTART    	; If not BASIC started then always do cold start
1699   0815 E1          				POP			HL						; Get pointer to input string
1700   0816 23          				INC			HL						; Skip the space
1701   0817 7E          				LD			A,(HL)          			; See if keyword follows
1702   0818 E6 5F       				AND     	01011111B    	   	; Force upper case
1703   081A FE 43       				CP			'C'						; Check next char is a C
1704   081C C2 03 20    				JP			NZ,BASWRM  		; Otherwise go to warm start
1705   081F C3 92 03    				JP			COLDSTART			; Cold start selected
1706   0822             				
1707   0822             ;------------------------------------------------------------------------------
1708   0822             ; Get a character from the console, must be $20-$7F to be valid (no control characters)
1709   0822             ; <Ctrl-c> and <SPACE> breaks with the Zero Flag set
1710   0822             ;------------------------------------------------------------------------------	
1711   0822             MGETCHR:
1712   0822 CD 8B 01    				CALL 		RDCHR					; RX a Character
1713   0825 FE 03       				CP			$03						; <ctrl-c> User break?
1714   0827 C8          				RET  		Z			
1715   0828 FE 20       				CP			$20						; <space> or better?
1716   082A 38 F6       				JR			C,MGETCHR			; Do it again until we get something usable
1717   082C C9          				RET
1718   082D             
1719   082D             ;------------------------------------------------------------------------------
1720   082D             ; Gets two ASCII characters from the console (assuming them to be HEX 0-9 A-F)
1721   082D             ; Moves them into B and C, converts them into a byte value in A
1722   082D             ;------------------------------------------------------------------------------
1723   082D             GET2A:
1724   082D CD 22 08    				CALL 		MGETCHR					; Get us a valid character to work with
1725   0830 CD 48 01    				CALL		TXA
1726   0833 47          				LD			B,A						; Load it in B
1727   0834 CD 22 08    				CALL 		MGETCHR					; Get us another character
1728   0837 CD 48 01    				CALL		TXA
1729   083A 4F          				LD			C,A						; load it in C
1730   083B CD 7E 08    				CALL 		BCTOA					; Convert ASCII to byte
1731   083E C9          				RET
1732   083F             				
1733   083F             ;------------------------------------------------------------------------------
1734   083F             ; Gets two ASCII characters from the console (assuming them to be HEX 0-9 A-F)
1735   083F             ; Moves them into B and C, converts them into a byte value in A and updates a
1736   083F             ; Checksum value in E
1737   083F             ;------------------------------------------------------------------------------
1738   083F             GET2:
1739   083F CD 22 08    				CALL 		MGETCHR					; Get us a valid character to work with
1740   0842 47          				LD			B,A						; Load it in B
1741   0843 CD 22 08    				CALL 		MGETCHR					; Get us another character
1742   0846 4F          				LD			C,A						; load it in C
1743   0847 CD 7E 08    				CALL 		BCTOA					; Convert ASCII to byte
1744   084A 4F          				LD			C,A						; Build the checksum
1745   084B 7B          				LD			A,E
1746   084C 91          				SUB  		C						; The checksum should always equal zero when checked
1747   084D 5F          				LD			E,A						; Save the checksum back where it came from
1748   084E 79          				LD			A,C						; Retrieve the byte and go back
1749   084F C9          				RET
1750   0850             				
1751   0850             ;------------------------------------------------------------------------------
1752   0850             ; Gets four Hex characters from the console, converts them to values in HL
1753   0850             ;------------------------------------------------------------------------------
1754   0850             GETHL:
1755   0850 21 00 00    				LD			HL,$0000				; Gets xxxx but sets Carry Flag on any Terminator
1756   0853 CD A4 08    				CALL 		ECHO					; RX a Character
1757   0856 FE 0D       				CP			CR						; <CR>?
1758   0858 20 0E       				JR			NZ,GETX2				; other key		
1759   085A             SETCY:
1760   085A 37          				SCF									; Set Carry Flag
1761   085B C9          				RET             					; and Return to main program		
1762   085C             				
1763   085C             ;------------------------------------------------------------------------------
1764   085C             ; This routine converts last four hex characters (0-9 A-F) user types into a value in HL
1765   085C             ; Rotates the old out and replaces with the new until the user hits a terminating character
1766   085C             ;------------------------------------------------------------------------------
1767   085C             GETX:
1768   085C 21 00 00    				LD			HL,$0000			; CLEAR HL
1769   085F             GETX1:
1770   085F CD A4 08    				CALL 		ECHO				; RX a character from the console
1771   0862 FE 0D       				CP			CR					; <CR>
1772   0864 C8          				RET  		Z					; quit
1773   0865 FE 2C       				CP			$2C					; <,> can be used to safely quit for multiple entries
1774   0867 C8          				RET  		Z					; (Like filling both DE and HL from the user)
1775   0868             GETX2:
1776   0868 FE 03       				CP			$03					; Likewise, a <ctrl-C> will terminate clean, too, but
1777   086A 28 EE       				JR			Z,SETCY				; It also sets the Carry Flag for testing later.
1778   086C 29          				ADD  		HL,HL				; Otherwise, rotate the previous low nibble to high
1779   086D 29          				ADD  		HL,HL				; rather slowly
1780   086E 29          				ADD  		HL,HL				; until we get to the top
1781   086F 29          				ADD  		HL,HL				; and then we can continue on.
1782   0870 D6 30       				SUB  		$30					; Convert ASCII to byte	value
1783   0872 FE 0A       				CP			$0A					; Are we in the 0-9 range?
1784   0874 38 02       				JR			C,GETX3				; Then we just need to sub $30, but if it is A-F
1785   0876 D6 07       				SUB  		$07					; We need to take off 7 more to get the value down to
1786   0878             GETX3:
1787   0878 E6 0F       				AND  		$0F					; to the right hex value
1788   087A 85          				ADD  		A,L					; Add the high nibble to the low
1789   087B 6F          				LD			L,A					; Move the byte back to A
1790   087C 18 E1       				JR			GETX1				; and go back for next character until he terminates
1791   087E             
1792   087E             ;------------------------------------------------------------------------------
1793   087E             ; Convert ASCII characters in B C registers to a byte value in A
1794   087E             ;------------------------------------------------------------------------------
1795   087E             BCTOA:
1796   087E 78          		LD   A,B	; Move the hi order byte to A
1797   087F D6 30       		SUB  $30	; Take it down from Ascii
1798   0881 FE 0A       		CP   $0A	; Are we in the 0-9 range here?
1799   0883 38 02       		JR   C,BCTOA1	; If so, get the next nybble
1800   0885 D6 07       		SUB  $07	; But if A-F, take it down some more
1801   0887             BCTOA1:
1802   0887 07          		RLCA		; Rotate the nybble from low to high
1803   0888 07          		RLCA		; One bit at a time
1804   0889 07          		RLCA		; Until we
1805   088A 07          		RLCA		; Get there with it
1806   088B 47          		LD   B,A	; Save the converted high nybble
1807   088C 79          		LD   A,C	; Now get the low order byte
1808   088D D6 30       		SUB  $30	; Convert it down from Ascii
1809   088F FE 0A       		CP   $0A	; 0-9 at this point?
1810   0891 38 02       		JR   C,BCTOA2	; Good enough then, but
1811   0893 D6 07       		SUB  $07	; Take off 7 more if it's A-F
1812   0895             BCTOA2:
1813   0895 80          		ADD  A,B	; Add in the high order nybble
1814   0896 C9          		RET
1815   0897             
1816   0897             ;------------------------------------------------------------------------------
1817   0897             ; HLDivC - Divide 16-bit HL by 8-bit C and put remainder in A
1818   0897             ; Inputs:
1819   0897             ;     HL - numerator
1820   0897             ;     C  - denominator
1821   0897             ; Outputs:
1822   0897             ;     A  - remainder
1823   0897             ;     B  - 0
1824   0897             ;     C  - unchanged
1825   0897             ;     DE - unchanged
1826   0897             ;     HL - quotient
1827   0897             ;------------------------------------------------------------------------------
1828   0897             HLDivC:
1829   0897 06 10       				LD			B,16
1830   0899 AF          				XOR			A
1831   089A 29          				ADD			HL,HL
1832   089B 17          				RLA
1833   089C B9          				CP			C
1834   089D 38 02       				JR			C,$+4
1835   089F 2C          				INC			L
1836   08A0 91          				SUB			C
1837   08A1 10 F7       				DJNZ		$-7
1838   08A3 C9          				RET
1839   08A4             
1840   08A4             ;------------------------------------------------------------------------------
1841   08A4             ; Get a character and echo it back to the user
1842   08A4             ;------------------------------------------------------------------------------
1843   08A4             ECHO:
1844   08A4 CD 8B 01    				CALL		RDCHR
1845   08A7 CD 97 01    				CALL		WRCHR
1846   08AA C9          				RET
1847   08AB             
1848   08AB             ;------------------------------------------------------------------------------
1849   08AB             ; MGOTO command
1850   08AB             ;------------------------------------------------------------------------------
1851   08AB             MGOTO:
1852   08AB CD 50 08    				CALL 		GETHL			; ENTRY POINT FOR <G>oto addr. Get XXXX from user.
1853   08AE D8          				RET  		C				; Return if invalid       	
1854   08AF E5          				PUSH 		HL
1855   08B0 C9          				RET							; Jump to HL address value
1856   08B1             
1857   08B1             ;------------------------------------------------------------------------------
1858   08B1             ; Start BASIC command
1859   08B1             ;------------------------------------------------------------------------------
1860   08B1             BASIC:
1861   08B1 21 54 0A    				LD 			HL,BASICTXT
1862   08B4 CD 0C 03    				CALL 		MPRINT
1863   08B7 CD 22 08    				CALL 		MGETCHR
1864   08BA C8          				RET 		Z				; Cancel if CTRL-C
1865   08BB E6 5F       				AND  		$5F 			; uppercase
1866   08BD FE 43       				CP 			'C'
1867   08BF CA 00 20    				JP  		Z,BASCLD
1868   08C2 FE 57       				CP 			'W'
1869   08C4 CA 03 20    				JP  		Z,BASWRM
1870   08C7 C9          				RET
1871   08C8             
1872   08C8             ;------------------------------------------------------------------------------
1873   08C8             ; CP/M load command
1874   08C8             ;------------------------------------------------------------------------------
1875   08C8             CPMLOAD:
1876   08C8 21 1D 0B    				LD 			HL,CPMTXT
1877   08CB CD 0C 03    				CALL 		MPRINT
1878   08CE CD 22 08    				CALL 		MGETCHR
1879   08D1 C8          				RET 		Z				; Cancel if CTRL-C
1880   08D2 E6 5F       				AND  		$5F 			; uppercase
1881   08D4 FE 59       				CP 			'Y'
1882   08D6 CA DA 08    				JP  		Z,CPMLOAD2
1883   08D9 C9          				RET
1884   08DA             
1885   08DA             CPMLOAD2:
1886   08DA CD D0 01    				CALL		INIT_CTC		; Shut down all CTC interrupts
1887   08DD 21 2A 0B    				LD 			HL,CPMTXT2
1888   08E0 CD 0C 03    				CALL 		MPRINT
1889   08E3             
1890   08E3 CD 5E 09    				CALL		cfWait
1891   08E6 3E 01       				LD 			A,CF_8BIT		; Set IDE to be 8bit
1892   08E8 D3 11       				OUT			(CF_FEATURES),A
1893   08EA 3E EF       				LD			A,CF_SET_FEAT
1894   08EC D3 17       				OUT			(CF_COMMAND),A
1895   08EE             
1896   08EE             
1897   08EE CD 5E 09    				CALL		cfWait
1898   08F1 3E 82       				LD 			A,CF_NOCACHE	; No write cache
1899   08F3 D3 11       				OUT			(CF_FEATURES),A
1900   08F5 3E EF       				LD			A,CF_SET_FEAT
1901   08F7 D3 17       				OUT			(CF_COMMAND),A
1902   08F9             
1903   08F9 06 18       				LD			B,numSecs
1904   08FB             
1905   08FB 3E 00       				LD			A,0
1906   08FD 32 97 40    				LD			(secNo),A
1907   0900 21 00 D0    				LD			HL,loadAddr
1908   0903 22 98 40    				LD			(dmaAddr),HL
1909   0906             processSectors:
1910   0906 CD 5E 09    				CALL		cfWait
1911   0909             
1912   0909 3A 97 40    				LD			A,(secNo)
1913   090C D3 13       				OUT 		(CF_LBA0),A
1914   090E 3E 00       				LD			A,0
1915   0910 D3 14       				OUT 		(CF_LBA1),A
1916   0912 D3 15       				OUT 		(CF_LBA2),A
1917   0914 3E E0       				LD			A,0E0H
1918   0916 D3 16       				OUT 		(CF_LBA3),A
1919   0918 3E 01       				LD 			A,1
1920   091A D3 12       				OUT 		(CF_SECCOUNT),A
1921   091C             
1922   091C CD 3A 09    				CALL		read
1923   091F             
1924   091F 11 00 02    				LD			DE,0200H
1925   0922 2A 98 40    				LD			HL,(dmaAddr)
1926   0925 19          				ADD			HL,DE
1927   0926 22 98 40    				LD			(dmaAddr),HL
1928   0929 3A 97 40    				LD			A,(secNo)
1929   092C 3C          				INC			A
1930   092D 32 97 40    				LD			(secNo),A
1931   0930             
1932   0930 10 D4       				DJNZ		processSectors
1933   0932             
1934   0932             ; Start CP/M using entry at top of BIOS
1935   0932             ; The current active console stream ID is pushed onto the stack
1936   0932             ; to allow the CBIOS to pick it up
1937   0932             ; 0 = SIO A, 1 = SIO B
1938   0932 3A 96 40    				LD			A,(primaryIO)
1939   0935 F5          				PUSH		AF
1940   0936 2A FE FF    				LD			HL,($FFFE)
1941   0939 E9          				JP			(HL)
1942   093A             
1943   093A             ;------------------------------------------------------------------------------
1944   093A             ; Read physical sector from host
1945   093A             ;------------------------------------------------------------------------------
1946   093A             read:
1947   093A F5          		PUSH 	AF
1948   093B C5          		PUSH 	BC
1949   093C E5          		PUSH 	HL
1950   093D             
1951   093D CD 5E 09    		CALL 	cfWait
1952   0940             
1953   0940 3E 20       		LD 	A,CF_READ_SEC
1954   0942 D3 17       		OUT 	(CF_COMMAND),A
1955   0944             
1956   0944 CD 5E 09    		CALL 	cfWait
1957   0947             
1958   0947 0E 04       		LD 	c,4
1959   0949 2A 98 40    		LD 	HL,(dmaAddr)
1960   094C             rd4secs:
1961   094C 06 80       		LD 	b,128
1962   094E             rdByte:
1963   094E 00          		nop
1964   094F 00          		nop
1965   0950 DB 10       		in 	A,(CF_DATA)
1966   0952 77          		LD 	(HL),A
1967   0953 23          		iNC 	HL
1968   0954 05          		dec 	b
1969   0955 20 F7       		JR 	NZ, rdByte
1970   0957 0D          		dec 	c
1971   0958 20 F2       		JR 	NZ,rd4secs
1972   095A             
1973   095A E1          		POP 	HL
1974   095B C1          		POP 	BC
1975   095C F1          		POP 	AF
1976   095D             
1977   095D C9          		RET
1978   095E             
1979   095E             
1980   095E             ; Wait for disk to be ready (busy=0,ready=1)
1981   095E             cfWait:
1982   095E F5          		PUSH 	AF
1983   095F             cfWait1:
1984   095F DB 17       		in 	A,(CF_STATUS)
1985   0961 E6 80       		AND 	080H
1986   0963 FE 80       		cp 	080H
1987   0965 28 F8       		JR	Z,cfWait1
1988   0967 F1          		POP 	AF
1989   0968 C9          		RET
1990   0969             
1991   0969             ;------------------------------------------------------------------------------
1992   0969             ; COMMAND LIST - Direct Mode commands.  Position in table relates to 
1993   0969             ; routine called in Keyword Address Table below
1994   0969             ;------------------------------------------------------------------------------
1995   0969             CWORDS:  
1996   0969 C241534943  			.BYTE	'B'+80H,"ASIC"
1997   096E D5 53 45 52         	.BYTE	'U'+80H,"SER"
1998   0972 C4 55 4D 50         	.BYTE	'D'+80H,"UMP"
1999   0976 D2 48 45 58 			.BYTE	'R'+80H,"HEX"
2000   097A D6455253494F        	.BYTE	'V'+80H,"ERSION"
2000   0980 4E
2001   0981 C8 45 4C 50         	.BYTE	'H'+80H,"ELP"
2002   0985 C3 41 4C 4C 			.BYTE	'C'+80H,"ALL"
2003   0989 CF 55 54            	.BYTE	'O'+80H,"UT"
2004   098C C9 4E       			.BYTE	'I'+80H,"N"
2005   098E D0 4F 4B 45 			.BYTE	'P'+80H,"OKE"
2006   0992 D0 45 45 4B 			.BYTE	'P'+80H,"EEK"
2007   0996 C34C524D454D			.BYTE	'C'+80H,"LRMEM"
2008   099C CD 45 4D 58 			.BYTE	'M'+80H,"EMX"
2009   09A0 D245534554  			.BYTE	'R'+80H,"ESET"
2010   09A5 C3 50 4D    			.BYTE	'C'+80H,"PM"
2011   09A8 D34554494F  			.BYTE	'S'+80H,"ETIO"
2012   09AD C74554494F  			.BYTE	'G'+80H,"ETIO"
2013   09B2 D4 49 4D 45 			.BYTE	'T'+80H,"IME"
2014   09B6 D3 43 41 4E 			.BYTE	'S'+80H,"CAN"
2015   09BA D35550504F52			.BYTE	'S'+80H,"UPPORT"
2015   09C0 54
2016   09C1 D8 45 53 54 			.BYTE	'X'+80H,"EST"
2017   09C5             
2018   09C5             ;------------------------------------------------------------------------------
2019   09C5             ; KEYWORD ADDRESS TABLE - LINKS KEYWORDS TO SUBROUTINES
2020   09C5             ;------------------------------------------------------------------------------
2021   09C5             CWORDTB: 
2022   09C5 0D 08       			.WORD	CBASIC			; BASIC
2023   09C7 7C 03               	.WORD	USRCODE			; USER
2024   09C9 20 04               	.WORD	MEMD			; DUMP
2025   09CB A7 06       			.WORD	RHEX			; RHEX
2026   09CD 9B 03       			.WORD	VER				; VERSION
2027   09CF D8 07               	.WORD	HELP			; HELP
2028   09D1 E2 07       			.WORD	CCALL			; CALL
2029   09D3 4A 07               	.WORD	CPOUT			; OUT
2030   09D5 6C 07       			.WORD	CPIN			; IN
2031   09D7 9E 07       			.WORD	CPOKE			; POKE
2032   09D9 B3 07       			.WORD	CPEEK			; PEEK
2033   09DB E8 07       			.WORD	CLEARM			; CLEARMEM
2034   09DD 2B 04       			.WORD	MEMX			; MEMX
2035   09DF 00 00       			.WORD	RST00			; RESET
2036   09E1 C8 08       			.WORD	CPMLOAD			; CPM
2037   09E3 AB 03       			.WORD	CPSGOUT			; PSG IO TESTING
2038   09E5 D0 03       			.WORD	CPSGIN			; PSG IO TESTING
2039   09E7 C9 07       			.WORD	CTIME			; TIME SINCE BOOT
2040   09E9 45 11       			.WORD	I2C_SCAN		; I²C BUS SCANNER
2041   09EB 16 04       			.WORD	SM_TX			; TRANSMIT TO SUPPORT MODULE TESTER
2042   09ED 9B 03       			.WORD	VER				; FIX FOR LAST ENTRY NOT WORKING
2043   09EF             
2044   09EF             ;------------------------------------------------------------------------------
2045   09EF             ; RESERVED WORD TOKEN VALUES
2046   09EF             ; Don't actually think these are needed - it's likely these are the tokens
2047   09EF             ; that BASIC uses to replace commands in the stored BASIC programs
2048   09EF             ;------------------------------------------------------------------------------
2049   09EF             DBASIC  	.EQU    	080H        ; BASIC
2050   09EF             DUSER   	.EQU    	081H        ; USRCODE
2051   09EF             DDUMP		.EQU		082H        ; DUMP
2052   09EF             DRHEX		.EQU		083H		; RHEX
2053   09EF             DVER		.EQU		084H		; VERSION
2054   09EF             DHELP   	.EQU    	085H        ; HELP
2055   09EF             DCALL		.EQU		086H		; CALL
2056   09EF             DOUT   		.EQU    	087H        ; OUT
2057   09EF             DIN			.EQU		088H		; IN
2058   09EF             DPOKE		.EQU		089H		; POKE
2059   09EF             DPEEK		.EQU		08AH		; PEEK
2060   09EF             DCLEARM		.EQU		08BH		; CLRMEM
2061   09EF             DMEMX		.EQU		08CH		; MEMX
2062   09EF             DRESET		.EQU		08DH		; RESET
2063   09EF             DCPM		.EQU		08EH		; CPM
2064   09EF             DCPSGOUT	.EQU		08FH		; PSG IO WRITE
2065   09EF             DCPSGIN		.EQU		090H		; PSG IO READ
2066   09EF             DTIME		.EQU		091H		; TIME SINCE BOOT
2067   09EF             DSCAN		.EQU		092H		; I²C BUS SCANNER
2068   09EF             DSMSEL		.EQU		093H		; SUPPORT MODULE TESTER
2069   09EF             DXEST		.EQU		094H		; FIX FOR LAST ENTRY NOT WORKING
2070   09EF             
2071   09EF             ;------------------------------------------------------------------------------
2072   09EF             ; STRING VALUES
2073   09EF             ;------------------------------------------------------------------------------
2074   09EF             SIGNON1       	
2075   09EF 0C          		.BYTE   MCLS
2076   09F0 5A3830204D69		.BYTE	"Z80 Minicom II 64K Computer "
2076   09F6 6E69636F6D2049492036344B20436F6D707574657220
2077   0A0C 4020332E3638		.BYTE	"@ 3.6864 MHz"
2077   0A12 3634204D487A
2078   0A18 0D 0A       		.BYTE	CR,LF
2079   0A1A 2020426F6F74		.BYTE	"  Boot ROM v1.3",CR,LF
2079   0A20 20524F4D2076312E330D0A
2080   0A2B 20202020436F		.BYTE	"    Copyright ",40,"C",41," 2017 "
2080   0A31 7079726967687420284329203230313720
2081   0A42 4A6F6E617468		.BYTE  	"Jonathan Nock",CR,LF
2081   0A48 616E204E6F636B0D0A
2082   0A51 0D 0A 00    		.BYTE	CR,LF,EOS
2083   0A54             		
2084   0A54             BASICTXT
2085   0A54 0D 0A       		.BYTE	CR,LF
2086   0A56 436F6C64206F		.TEXT	"Cold or Warm ?"
2086   0A5C 72205761726D203F
2087   0A64 0D 0A 00    		.BYTE	CR,LF,EOS
2088   0A67             
2089   0A67             CKSUMERR
2090   0A67 436865636B73		.BYTE	"Checksum error"
2090   0A6D 756D206572726F72
2091   0A75 0D 0A 00    		.BYTE	CR,LF,EOS
2092   0A78             
2093   0A78             MINITTXTA
2094   0A78 0C          		.BYTE	MCLS
2095   0A79 5A3830204D69		.TEXT	"Z80 Minicom II 64K Computer "
2095   0A7F 6E69636F6D2049492036344B20436F6D707574657220
2096   0A95 0D 0A       		.BYTE	CR,LF
2097   0A97 504F52542041		.TEXT	"PORT A: Press [SPACE] to activate console"
2097   0A9D 3A205072657373205B53504143455D20746F20616374697661746520636F6E736F6C65
2098   0AC0 0D 0A 00    		.BYTE	CR,LF,EOS
2099   0AC3             
2100   0AC3             MINITTXTB
2101   0AC3 0C          		.BYTE	MCLS
2102   0AC4 5A3830204D69		.TEXT	"Z80 Minicom II 64K Computer "
2102   0ACA 6E69636F6D2049492036344B20436F6D707574657220
2103   0AE0 0D 0A       		.BYTE	CR,LF
2104   0AE2 504F52542042		.TEXT	"PORT B: Press [SPACE] to activate console"
2104   0AE8 3A205072657373205B53504143455D20746F20616374697661746520636F6E736F6C65
2105   0B0B 0D 0A 00    		.BYTE	CR,LF,EOS
2106   0B0E             		
2107   0B0E             CPROMPT
2108   0B0E 0D 0A       		.BYTE	CR,LF
2109   0B10             		
2110   0B10             CSHTPRT
2111   0B10 4F4B0D0A00  		.BYTE	"OK",CR,LF,EOS
2112   0B15             
2113   0B15             CINMSG
2114   0B15 56414C55453A		.BYTE	"VALUE: ",EOS
2114   0B1B 2000
2115   0B1D             		
2116   0B1D             CPMTXT:
2117   0B1D 0D 0A       		.BYTE	CR,LF
2118   0B1F 426F6F742043		.TEXT	"Boot CP/M?"
2118   0B25 502F4D3F
2119   0B29 00          		.BYTE	EOS
2120   0B2A             
2121   0B2A             CPMTXT2:
2122   0B2A 0D 0A       		.BYTE	CR,LF
2123   0B2C 43544320696E		.TEXT	"CTC interrupts reset..."
2123   0B32 74657272757074732072657365742E2E2E
2124   0B43 0D 0A       		.BYTE	CR,LF
2125   0B45 4C6F6164696E		.TEXT	"Loading CP/M..."
2125   0B4B 672043502F4D2E2E2E
2126   0B54 0D 0A 00    		.BYTE	CR,LF,EOS
2127   0B57             		
2128   0B57             ERMSG
2129   0B57 556E7265636F		.BYTE	"Unrecognised command",EOS
2129   0B5D 676E6973656420636F6D6D616E6400
2130   0B6C             		
2131   0B6C             INTERR
2132   0B6C 556E68616E64		.BYTE	"Unhandled Interrupt Error",EOS
2132   0B72 6C656420496E74657272757074204572726F7200
2133   0B86             
2134   0B86             IOERR
2135   0B86 494F20457272		.BYTE	"IO Error",EOS
2135   0B8C 6F7200
2136   0B8F             
2137   0B8F             SYERR
2138   0B8F 53796E746178		.BYTE	"Syntax Error",EOS
2138   0B95 204572726F7200
2139   0B9C             
2140   0B9C             DMMSG
2141   0B9C 446972656374		.BYTE	"Direct Mode Interpreter - "
2141   0BA2 204D6F646520496E746572707265746572202D20
2142   0BB6 547970652027		.BYTE	"Type 'HELP' for commands"
2142   0BBC 48454C502720666F7220636F6D6D616E6473
2143   0BCE 00          		.BYTE	EOS
2144   0BCF             
2145   0BCF             RHXMSG
2146   0BCF 506173746520		.BYTE	"Paste your Intel Hex code "
2146   0BD5 796F757220496E74656C2048657820636F646520
2147   0BE9 6E6F77206F72		.BYTE	"now or press ESC to "
2147   0BEF 2070726573732045534320746F20
2148   0BFD 63616E63656C		.BYTE	"cancel..."
2148   0C03 2E2E2E
2149   0C06 00          		.BYTE	EOS
2150   0C07             		
2151   0C07             SECSMSG
2152   0C07 2073696E6365		.BYTE	" since last boot.",EOS
2152   0C0D 206C61737420626F6F742E00
2153   0C19             		
2154   0C19             BTSTMSG
2155   0C19 546869732069		.BYTE	"This is a message from "
2155   0C1F 732061206D6573736167652066726F6D20
2156   0C30 746865205A38		.BYTE	"the Z80!",EOS
2156   0C36 302100
2157   0C39             
2158   0C39             RHXFMSG
2159   0C39 44617461206C		.BYTE	"Data loaded at address ",EOS
2159   0C3F 6F6164656420617420616464726573732000
2160   0C51             
2161   0C51             MEMXMNU
2162   0C51 282C29205072		.BYTE	"(,) Prev page "
2162   0C57 6576207061676520
2163   0C5F 282E29204E65		.BYTE	"(.) Next page "
2163   0C65 7874207061676520
2164   0C6D 28472920476F		.BYTE	"(G) Go to addr "
2164   0C73 20746F206164647220
2165   0C7C 28502920506F		.BYTE	"(P) Poke "
2165   0C82 6B6520
2166   0C85 285829204578		.BYTE	"(X) Exit editor",CR,LF
2166   0C8B 697420656469746F720D0A
2167   0C96 4D454D583A20		.BYTE	"MEMX: ",EOS
2167   0C9C 00
2168   0C9D             				
2169   0C9D             MEMXEAI
2170   0C9D 456E74657220		.BYTE	"Enter address (xxxx):",EOS
2170   0CA3 61646472657373202878787878293A00
2171   0CB3             
2172   0CB3             MEMXEDI
2173   0CB3 456E74657220		.BYTE	"Enter data to poke (xx):",EOS
2173   0CB9 6461746120746F20706F6B6520287878293A00
2174   0CCC             		
2175   0CCC             AYPREAD
2176   0CCC 50534720494F		.BYTE	"PSG IO Port Value: ",EOS
2176   0CD2 20506F72742056616C75653A2000
2177   0CE0             		
2178   0CE0             AYPWRITE
2179   0CE0 50534720494F		.BYTE	"PSG IO Port Write: ",EOS
2179   0CE6 20506F72742057726974653A2000
2180   0CF4             
2181   0CF4             CMDLIST
2182   0CF4 446972656374		.BYTE	"Direct Mode command list:",CR,LF
2182   0CFA 204D6F646520636F6D6D616E64206C6973743A0D0A
2183   0D0F 2D2D2D2D2D2D		.BYTE	"-------------------------",CR,LF
2183   0D15 2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D0D0A
2184   0D2A 424153494320		.BYTE	"BASIC (C/OLD)  - "
2184   0D30 28432F4F4C442920202D20
2185   0D3B 476F20746F20		.BYTE	"Go to BASIC interpreter - "
2185   0D41 424153494320696E746572707265746572202D20
2186   0D55 666F72636520		.BYTE	"force cold start with C "
2186   0D5B 636F6C642073746172742077697468204320
2187   0D6D 6F7220434F4C		.BYTE	"or COLD",CR,LF
2187   0D73 440D0A
2188   0D76 43504D202020		.BYTE	"CPM            - "
2188   0D7C 2020202020202020202D20
2189   0D87 426F6F742043		.BYTE	"Boot CP/M (load $D000-$FFFF "
2189   0D8D 502F4D20286C6F61642024443030302D244646464620
2190   0DA3 66726F6D2064		.BYTE	"from disk)",CR,LF
2190   0DA9 69736B290D0A
2191   0DAF 524553455420		.BYTE	"RESET          - "
2191   0DB5 2020202020202020202D20
2192   0DC0 526573657420		.BYTE	"Reset the computer",CR,LF
2192   0DC6 74686520636F6D70757465720D0A
2193   0DD4 555345522020		.BYTE	"USER           - "
2193   0DDA 2020202020202020202D20
2194   0DE5 43616C6C2075		.BYTE	"Call user assembly routine",CR,LF
2194   0DEB 73657220617373656D626C7920726F7574696E650D0A
2195   0E01 44554D502024		.BYTE	"DUMP $nnnn     - "
2195   0E07 6E6E6E6E20202020202D20
2196   0E12 44756D702061		.BYTE	"Dump a 256-byte segment of "
2196   0E18 203235362D62797465207365676D656E74206F6620
2197   0E2D 6D656D6F7279		.BYTE	"memory from location $nnnn",CR,LF
2197   0E33 2066726F6D206C6F636174696F6E20246E6E6E6E0D0A
2198   0E49 4D454D582020		.BYTE	"MEMX           - "
2198   0E4F 2020202020202020202D20
2199   0E5A 4F70656E7320		.BYTE	"Opens the memory editor tool",CR,LF
2199   0E60 746865206D656D6F727920656469746F7220746F6F6C0D0A
2200   0E78 524845582020		.BYTE	"RHEX           - "
2200   0E7E 2020202020202020202D20
2201   0E89 4C697374656E		.BYTE	"Listen for Intel Hex stream "
2201   0E8F 20666F7220496E74656C204865782073747265616D20
2202   0EA5 616E64206C6F		.BYTE	"and load into memory",CR,LF
2202   0EAB 616420696E746F206D656D6F72790D0A
2203   0EBB 56455253494F		.BYTE	"VERSION        - "
2203   0EC1 4E20202020202020202D20
2204   0ECC 53686F772074		.BYTE	"Show the system version "
2204   0ED2 68652073797374656D2076657273696F6E20
2205   0EE4 6E756D626572		.BYTE	"numbers",CR,LF
2205   0EEA 730D0A
2206   0EED 4F5554202470		.BYTE	"OUT $pp,$nn    - "
2206   0EF3 702C246E6E202020202D20
2207   0EFE 577269746520		.BYTE	"Write the hex $nn to port "
2207   0F04 7468652068657820246E6E20746F20706F727420
2208   0F18 2470700D0A  		.BYTE	"$pp",CR,LF
2209   0F1D 494E20247070		.BYTE	"IN $pp         - "
2209   0F23 2020202020202020202D20
2210   0F2E 5072696E7420		.BYTE	"Print the value at port "
2210   0F34 7468652076616C756520617420706F727420
2211   0F46 2470700D0A  		.BYTE	"$pp",CR,LF
2212   0F4B 43414C4C2024		.BYTE	"CALL $nnnn     - "
2212   0F51 6E6E6E6E20202020202D20
2213   0F5C 43616C6C2061		.BYTE	"Call a subroutine at address"
2213   0F62 20737562726F7574696E652061742061646472657373
2214   0F78 20246E6E6E6E		.BYTE	" $nnnn",CR,LF
2214   0F7E 0D0A
2215   0F80 5045454B2024		.BYTE	"PEEK $nnnn     - "
2215   0F86 6E6E6E6E20202020202D20
2216   0F91 526561642061		.BYTE	"Read a value from address $nnnn"
2216   0F97 2076616C75652066726F6D206164647265737320246E6E6E6E
2217   0FB0 0D 0A       		.BYTE	CR,LF
2218   0FB2 504F4B452024		.BYTE	"POKE $nnnn,$dd - "
2218   0FB8 6E6E6E6E2C246464202D20
2219   0FC3 577269746520		.BYTE	"Write value $dd to address "
2219   0FC9 76616C75652024646420746F206164647265737320
2220   0FDE 246E6E6E6E0D		.BYTE	"$nnnn",CR,LF
2220   0FE4 0A
2221   0FE5 434C524D454D		.BYTE	"CLRMEM $nnnn,$dddd - "
2221   0FEB 20246E6E6E6E2C2464646464202D20
2222   0FFA 536574206172		.BYTE	"Set area size $dddd to 0 from "
2222   1000 65612073697A6520246464646420746F20302066726F6D20
2223   1018 6D656D6F7279		.BYTE	"memory address $nnnn",CR,LF
2223   101E 206164647265737320246E6E6E6E0D0A
2224   102E 534554494F20		.BYTE	"SETIO $nn      - "
2224   1034 246E6E2020202020202D20
2225   103F 577269746520		.BYTE	"Write hex $nn to PSG IO port"
2225   1045 68657820246E6E20746F2050534720494F20706F7274
2226   105B 0D 0A       		.BYTE	CR,LF
2227   105D 474554494F20		.BYTE	"GETIO          - "
2227   1063 2020202020202020202D20
2228   106E 526561642061		.BYTE	"Read a byte from IO port",CR,LF
2228   1074 20627974652066726F6D20494F20706F72740D0A
2229   1088 54494D452020		.BYTE	"TIME           - "
2229   108E 2020202020202020202D20
2230   1099 53686F772074		.BYTE	"Show time since boot"
2230   109F 696D652073696E636520626F6F74
2231   10AD 0D 0A       		.BYTE	CR,LF
2232   10AF 5343414E2020		.BYTE	"SCAN           - "
2232   10B5 2020202020202020202D20
2233   10C0 5363616E2074		.BYTE	"Scan the IIC bus for devices"
2233   10C6 6865204949432062757320666F722064657669636573
2234   10DC 0D 0A       		.BYTE	CR,LF
2235   10DE 535550504F52		.BYTE	"SUPPORT        - "
2235   10E4 5420202020202020202D20
2236   10EF 5472616E736D		.BYTE   "Transmit single character "
2236   10F5 69742073696E676C652063686172616374657220
2237   1109 746F20746865		.BYTE	"to the Support Module"
2237   110F 20537570706F7274204D6F64756C65
2238   111E 0D 0A       		.BYTE	CR,LF
2239   1120 48454C502020		.BYTE	"HELP           - "
2239   1126 2020202020202020202D20
2240   1131 53686F772074		.BYTE	"Show this help text",EOS
2240   1137 6869732068656C70207465787400
2241   1145             
2242   1145             ;------------------------------------------------------------------------------
2243   1145             #INCLUDE	"i2c_lib.asm"
0001+  1145             ; I²C LIBRARY for Z80 Minicom II
0002+  1145             ; For PIO-implemented I²C bus (bit-banging)
0003+  1145             ;
0004+  1145             ; (C) Jonathan Nock 2017
0005+  1145             ;
0006+  1145             ; nockieboy@gmail.com
0007+  1145             ;
0008+  1145             ; The following high-level routines are standalone - they include I²C bus management:
0009+  1145             ;
0010+  1145             ; I2C_GETHL8 - Read a word of data into HL via I²C using 8-bit addressing
0011+  1145             ; I2C_GETHL16- Read a word of data into HL via I²C using 16-bit addressing
0012+  1145             ; I2C_RD_D8  - Read block of data from device via I²C that uses 8-bit addressing
0013+  1145             ; I2C_RD_D16 - Read block of data from device via I²C that uses 16-bit addressing
0014+  1145             ; I2C_WR_D8  - Transmit block of data to device via I²C that uses 8-bit addressing
0015+  1145             ; I2C_WR_D16 - Transmit block of data to device via I²C that uses 16-bit addressing
0016+  1145             ;
0017+  1145             ; Low-level functions (further functions are internal to these):
0018+  1145             ;
0019+  1145             ; I2C_RST    - I²C bus reset
0020+  1145             ; I2C_START  - Initiates I²C bus transfer
0021+  1145             ; I2C_STOP   - Stops I²C bus transfer during WRITE operation
0022+  1145             ; I2C_STOP_RD- Stops I²C bus transfer during READ operation
0023+  1145             ; I2C_TX     - Transmit 1 byte via I²C
0024+  1145             ; I2C_RX     - Receive 1 byte via I²C
0025+  1145             ; I2C_ACK    - Transmit ACK
0026+  1145             
0027+  1145             ;------------------------------------------------------------------------------
0028+  1145             ; I²C BUS SCANNER
0029+  1145             ; Prints addresses for any devices on the I²C bus.
0030+  1145             ; Requires minicom.asm for support routines (char printing)
0031+  1145             ; Modifies:
0032+  1145             ;------------------------------------------------------------------------------
0033+  1145             I2C_SCAN:
0034+  1145 E1          				POP			HL					; Dump CLI pointer
0035+  1146 06 7E       				LD			B,7Eh				; Iterate through addresses from 126 -> 0
0036+  1148             				; Select device address:
0037+  1148 CD AA 11    I2C_SCNLP:		CALL		I2C_START
0038+  114B 78          				LD 			A,B
0039+  114C 32 95 40    				LD			(I2C_BUFF),A		; Buffer B
0040+  114F E6 FE       				AND			%11111110			; Clear the LSB for writes
0041+  1151 CD C5 11    				CALL		I2C_TX				; Write the address of the device
0042+  1154 D2 66 11    				JP			NC,I2C_NOPRT		; Don't print anything if no ACK (no device)
0043+  1157             				; Device has responded
0044+  1157 CD 86 02    				CALL		CRLF				; Newline
0045+  115A 21 73 11    				LD			HL,FNDMSG			; Load the found message
0046+  115D CD 0C 03    				CALL		MPRINT				; Print it
0047+  1160 3A 95 40    				LD			A,(I2C_BUFF)		; Copy the address into A ready to print
0048+  1163 CD 84 06    				CALL		PHEX				; Append the address
0049+  1166 3A 95 40    I2C_NOPRT:		LD			A,(I2C_BUFF)		; Restore B
0050+  1169 47          				LD			B,A					; 
0051+  116A 05          				DEC			B					; Skip odd addresses to halve search space
0052+  116B CD B1 11    				CALL		I2C_STOP			; Free the I²C bus
0053+  116E 10 D8       				DJNZ		I2C_SCNLP			; Decrement B and loop
0054+  1170 C3 63 02    				JP			COMMAND				; Return to CLI
0055+  1173             
0056+  1173 466F756E6420FNDMSG			.BYTE		"Found IIC device at: ",EOS
0056+  1179 494943206465766963652061743A2000
0057+  1189 436865636B69CHKMSG			.BYTE		"Checking **",EOS
0057+  118F 6E67202A2A00
0058+  1195             
0059+  1195             ;------------------------------------------------------------------------------
0060+  1195             ; I²C BUS TESTER
0061+  1195             ; Sends a START and STOP condition to the I²C bus to display a pattern trace
0062+  1195             ; on the SDA/SCL bus via oscilloscope.
0063+  1195             ; Permanent loop. Locks up computer if run until reset.
0064+  1195             ;------------------------------------------------------------------------------
0065+  1195             I2C_TEST:
0066+  1195 CD AA 11    				CALL		I2C_START
0067+  1198 00          				NOP
0068+  1199 CD B1 11    				CALL		I2C_STOP
0069+  119C C3 95 11    				JP			I2C_TEST
0070+  119F             
0071+  119F             ;------------------------------------------------------------------------------
0072+  119F             ; I²C BUS RESET
0073+  119F             ; Modifies A, B, D
0074+  119F             ; Leaves SDA high and SCL high
0075+  119F             ;------------------------------------------------------------------------------
0076+  119F             I2C_RST:
0077+  119F 06 0A       				LD			B,0Ah				; Do 10 SCL cycles while SDA is high
0078+  11A1 CD E8 12    I_77:			CALL		SCL_CYCLE
0079+  11A4 10 FB       				DJNZ		I_77
0080+  11A6 CD 15 13    				CALL		SCL_HIGH
0081+  11A9 C9          				RET
0082+  11AA             
0083+  11AA             ;------------------------------------------------------------------------------
0084+  11AA             ; I²C BUS START & STOP
0085+  11AA             ;------------------------------------------------------------------------------
0086+  11AA             I2C_START:		; Starts I²C bus
0087+  11AA CD 05 13    				CALL		SDA_LOW				; START defined by H-L on SDA with SCL H
0088+  11AD CD 25 13    				CALL		SCL_LOW
0089+  11B0 C9          				RET
0090+  11B1             				
0091+  11B1             I2C_STOP:		; Stops I²C bus during WRITE
0092+  11B1 CD 05 13    				CALL		SDA_LOW				; Make sure SDA is LOW initially.
0093+  11B4 CD 15 13    				CALL		SCL_HIGH			; STOP is defined by the SDA
0094+  11B7 CD F5 12    				CALL		SDA_HIGH			; transitioning to HIGH whilst SCL
0095+  11BA C9          				RET								; is HIGH.
0096+  11BB             				
0097+  11BB             I2C_STOP_RD:	; Stops I²C bus during READ
0098+  11BB CD 25 13    				CALL		SCL_LOW
0099+  11BE CD 05 13    				CALL		SDA_LOW
0100+  11C1 CD B1 11    				CALL		I2C_STOP
0101+  11C4 C9          				RET
0102+  11C5             
0103+  11C5             ;------------------------------------------------------------------------------
0104+  11C5             ; I²C TX
0105+  11C5             ; Writes a byte to the I²C bus and reads an acknowledgment.
0106+  11C5             ; Byte to send in A
0107+  11C5             ; Returns with carry cleared if ackn bit not found
0108+  11C5             ; Modifies A,B,C,D,HL
0109+  11C5             ;------------------------------------------------------------------------------
0110+  11C5             I2C_TX:
0111+  11C5 CD 35 13    				CALL		I2C_SEND_BYTE
0112+  11C8 CB 4A       				BIT			1,D					; Test D register for acknowledge bit
0113+  11CA 37          				SCF
0114+  11CB C8          				RET			Z					; Return if ACK bit low with carry set
0115+  11CC             				
0116+  11CC             				; When ACK error - stop bus
0117+  11CC CD B1 11    				CALL		I2C_STOP
0118+  11CF 37          				SCF
0119+  11D0 3F          				CCF
0120+  11D1 C9          				RET								; Return if ACK bit high with carry cleared
0121+  11D2             
0122+  11D2             ;------------------------------------------------------------------------------
0123+  11D2             ; I²C RX
0124+  11D2             ; Returns with slave data byte in A
0125+  11D2             ; Leaves SCL low and SDA high
0126+  11D2             ; Modifies A,B,D
0127+  11D2             ;------------------------------------------------------------------------------
0128+  11D2             I2C_RX:
0129+  11D2 06 08       				LD			B,8h
0130+  11D4 DB 21       I_66:			IN			A,(PIO_B_D)
0131+  11D6 37          				SCF
0132+  11D7 CB 4F       				BIT			1,A
0133+  11D9 C2 DD 11    				JP			NZ,H_FOUND
0134+  11DC 3F          L_FOUND:		CCF
0135+  11DD CB 11       H_FOUND:		RL			C
0136+  11DF CD E8 12    				CALL		SCL_CYCLE
0137+  11E2 10 F0       				DJNZ		I_66
0138+  11E4 CD E8 12    				CALL		SCL_CYCLE			; Send ACK to slave
0139+  11E7             												; Slave byte ready in C
0140+  11E7 79          				LD			A,C					; So switch byte to A
0141+  11E8 C9          				RET
0142+  11E9             
0143+  11E9             ;------------------------------------------------------------------------------
0144+  11E9             ; I²C READ 8-BIT DATA
0145+  11E9             ; Reads a block of data to an I²C-bus device that uses 8-bit addressing.
0146+  11E9             ; Pre:
0147+  11E9             ;   B  = Amount of data to read.
0148+  11E9             ;   C  = Address of device on I²C bus.
0149+  11E9             ;   E  = Address to read data from on device.
0150+  11E9             ;   HL = Pointer to location to store received data.
0151+  11E9             ; Post:
0152+  11E9             ;   Carry = set on error.
0153+  11E9             ;   All other flags are undefined; A is destroyed.
0154+  11E9             ;------------------------------------------------------------------------------
0155+  11E9             
0156+  11E9             I2C_RD_D8:
0157+  11E9 CD AA 11    				CALL		I2C_START	
0158+  11EC             				; Select device address:
0159+  11EC 79          				LD 			A,C
0160+  11ED E6 FE       				AND			%11111110			; Clear the LSB for writes
0161+  11EF CD C5 11    				CALL		I2C_TX				; Write the address of the device
0162+  11F2 DA BB 11    				JP			C,I2C_STOP_RD		; Stop if no ACK
0163+  11F5             				; Register address (8-bit):
0164+  11F5 7B          				LD			A,E
0165+  11F6 CD C5 11    				CALL		I2C_TX
0166+  11F9 DA BB 11    				JP			C,I2C_STOP_RD		; Stop if no ACK
0167+  11FC             				; Restart I²C bus
0168+  11FC CD B1 11    				CALL		I2C_STOP
0169+  11FF CD AA 11    				CALL		I2C_START
0170+  1202             				; Device address:
0171+  1202 79          				LD			A,C
0172+  1203 F6 01       				OR			%00000001			; Set the LSB for reads
0173+  1205 CD C5 11    				CALL		I2C_TX
0174+  1208 DA BB 11    				JP			C,I2C_STOP_RD		; Stop if no ACK	
0175+  120B CD D2 11    I2C_RDD8LP:		CALL		I2C_RX				; Get byte from I²C bus into A
0176+  120E 13          				INC			DE
0177+  120F 77          				LD			(HL),A				; Load the byte into memory
0178+  1210 23          				INC			HL
0179+  1211 78          				LD			A,B
0180+  1212 FE 01       				CP			1
0181+  1214 C4 DB 12    				CALL		NZ,I2C_ACK			; Write ACKnowledge to I²C bus
0182+  1217 10 F2       				DJNZ		I2C_RDD8LP			; Loop ^
0183+  1219 B7          				OR			A
0184+  121A C3 BB 11    				JP			I2C_STOP_RD
0185+  121D             
0186+  121D             ;------------------------------------------------------------------------------
0187+  121D             ; I²C READ 16-BIT DATA
0188+  121D             ; Reads a block of data to an I²C-bus device that uses 16-bit addressing.
0189+  121D             ; Pre:
0190+  121D             ;   B   = Amount of data to read.
0191+  121D             ;   C   = Address of device on I²C bus.
0192+  121D             ;   DE  = Address to read data from on device.
0193+  121D             ;   HL  = Pointer to location to store received data.
0194+  121D             ; Post:
0195+  121D             ;   Carry = set on error.
0196+  121D             ;   All other flags are undefined; A is destroyed.
0197+  121D             ;------------------------------------------------------------------------------
0198+  121D             
0199+  121D             I2C_RD_D16:
0200+  121D CD AA 11    				CALL		I2C_START	
0201+  1220             				; Select device address in C:
0202+  1220 79          				LD 			A,C
0203+  1221 E6 FE       				AND			%11111110			; Clear the LSB for writes
0204+  1223 CD C5 11    				CALL		I2C_TX				; Write the address of the device
0205+  1226 DA BB 11    				JP			C,I2C_STOP_RD		; Stop if no ACK
0206+  1229             				; Register address (16-bit) in DE:
0207+  1229 7A          				LD			A,D
0208+  122A CD C5 11    				CALL		I2C_TX
0209+  122D D8          				RET			C					; Stop if no ACK
0210+  122E 7B          				LD			A,E
0211+  122F CD C5 11    				CALL		I2C_TX
0212+  1232 DA BB 11    				JP			C,I2C_STOP_RD		; Stop if no ACK
0213+  1235             				; Restart I²C bus
0214+  1235 CD B1 11    				CALL		I2C_STOP
0215+  1238 CD AA 11    				CALL		I2C_START
0216+  123B             				; Device address:
0217+  123B 79          				LD			A,C
0218+  123C F6 01       				OR			%00000001			; Set the LSB for reads
0219+  123E CD C5 11    				CALL		I2C_TX
0220+  1241 DA BB 11    				JP			C,I2C_STOP_RD		; Stop if no ACK	
0221+  1244 CD D2 11    I2C_RDD16LP:	CALL		I2C_RX				; Get byte from I²C bus into A
0222+  1247 13          				INC			DE
0223+  1248 77          				LD			(HL),A				; Load the byte into memory
0224+  1249 23          				INC			HL
0225+  124A 78          				LD			A,B
0226+  124B FE 01       				CP			1
0227+  124D C4 DB 12    				CALL		NZ,I2C_ACK			; Write ACKnowledge to I²C bus
0228+  1250 10 F2       				DJNZ		I2C_RDD16LP			; Loop ^
0229+  1252 B7          				OR			A
0230+  1253 C3 BB 11    				JP			I2C_STOP_RD
0231+  1256             
0232+  1256             ;------------------------------------------------------------------------------
0233+  1256             ; I²C READ WORD INTO HL USING 8-BIT ADDRESSING
0234+  1256             ; Reads a word of data (2 bytes) from an I²C-bus device that uses 8-bit addressing.
0235+  1256             ; Pre:
0236+  1256             ;   C   = Address of device on I²C bus.
0237+  1256             ;   E   = Address to read data from on device.
0238+  1256             ; Post:
0239+  1256             ;   Carry = set on error.
0240+  1256             ;   HL  = word of data returned from I²C bus.
0241+  1256             ;   All other flags are undefined; A is destroyed.
0242+  1256             ;------------------------------------------------------------------------------
0243+  1256             
0244+  1256             I2C_GETHL8:
0245+  1256 CD AA 11    				CALL		I2C_START	
0246+  1259             				; Select device address in C:
0247+  1259 79          				LD 			A,C
0248+  125A E6 FE       				AND			%11111110			; Clear the LSB for writes
0249+  125C CD C5 11    				CALL		I2C_TX				; Write the address of the device
0250+  125F DA BB 11    				JP			C,I2C_STOP_RD		; Stop if no ACK
0251+  1262             				; Register address (8-bit) in DE:
0252+  1262 7B          				LD			A,E
0253+  1263 CD C5 11    				CALL		I2C_TX
0254+  1266 DA BB 11    				JP			C,I2C_STOP_RD		; Stop if no ACK
0255+  1269             				; Restart I²C bus
0256+  1269 CD B1 11    I2CxRT:			CALL		I2C_STOP			; 16-bit routine also runs from here
0257+  126C CD AA 11    				CALL		I2C_START
0258+  126F             				; Device address:
0259+  126F 79          				LD			A,C
0260+  1270 F6 01       				OR			%00000001			; Set the LSB for reads
0261+  1272 CD C5 11    				CALL		I2C_TX
0262+  1275 DA BB 11    				JP			C,I2C_STOP_RD		; Stop if no ACK	
0263+  1278             				; Get 2 bytes
0264+  1278 CD D2 11    				CALL		I2C_RX				; Get byte from I²C bus into A
0265+  127B DA BB 11    				JP			C,I2C_STOP_RD		; Stop if no ACK	
0266+  127E 6F          				LD			L,A
0267+  127F CD DB 12    				CALL		I2C_ACK
0268+  1282 CD D2 11    				CALL		I2C_RX
0269+  1285 DA BB 11    				JP			C,I2C_STOP_RD		; Stop if no ACK	
0270+  1288 67          				LD			H,A
0271+  1289             				; Free up I²C-bus and return
0272+  1289 B7          				OR			A
0273+  128A C3 BB 11    				JP			I2C_STOP_RD
0274+  128D             
0275+  128D             ;------------------------------------------------------------------------------
0276+  128D             ; I²C READ WORD INTO HL USING 16-BIT ADDRESSING
0277+  128D             ; Reads a word of data (2 bytes) from an I²C-bus device that uses 16-bit addressing.
0278+  128D             ; Pre:
0279+  128D             ;   C   = Address of device on I²C bus.
0280+  128D             ;   DE  = Address to read data from on device.
0281+  128D             ; Post:
0282+  128D             ;   Carry = set on error.
0283+  128D             ;   HL  = word of data returned from I²C bus.
0284+  128D             ;   All other flags are undefined; A is destroyed.
0285+  128D             ;------------------------------------------------------------------------------
0286+  128D             
0287+  128D             I2C_GETHL16:
0288+  128D CD AA 11    				CALL		I2C_START	
0289+  1290             				; Select device address in C:
0290+  1290 79          				LD 			A,C
0291+  1291 E6 FE       				AND			%11111110			; Clear the LSB for writes
0292+  1293 CD C5 11    				CALL		I2C_TX				; Write the address of the device
0293+  1296 DA BB 11    				JP			C,I2C_STOP_RD		; Stop if no ACK
0294+  1299             				; Register address (16-bit) in DE:
0295+  1299 7A          				LD			A,D
0296+  129A CD C5 11    				CALL		I2C_TX
0297+  129D D8          				RET			C					; Stop if no ACK
0298+  129E 7B          				LD			A,E
0299+  129F CD C5 11    				CALL		I2C_TX
0300+  12A2 DA BB 11    				JP			C,I2C_STOP_RD		; Stop if no ACK
0301+  12A5 C3 69 12    				JP			I2CxRT				; Re-use the routine above
0302+  12A8             
0303+  12A8             ;------------------------------------------------------------------------------
0304+  12A8             ; I²C WRITE 8-BIT DATA
0305+  12A8             ; Writes a block of data to an I²C-bus device that uses 8-bit addressing.
0306+  12A8             ; Pre:
0307+  12A8             ;   B  = Amount of data to write.
0308+  12A8             ;   C  = Address of device on I²C bus.
0309+  12A8             ;   E  = Address to write data to on device.
0310+  12A8             ;   HL = Pointer to data to write.
0311+  12A8             ; Post:
0312+  12A8             ;   Carry = set if transfer failed, reset if successful.
0313+  12A8             ;   All other flags are undefined; A is destroyed.
0314+  12A8             ;------------------------------------------------------------------------------
0315+  12A8             
0316+  12A8             I2C_WR_D8:
0317+  12A8 CD AA 11    				CALL 		I2C_START
0318+  12AB             	
0319+  12AB             				; Device address:
0320+  12AB 79          				LD 			A,C
0321+  12AC E6 FE       				AND			%11111110			; Clear the LSB for writes.
0322+  12AE CD C5 11    				CALL		I2C_TX				; Write the address of the device
0323+  12B1 D8          				RET			C					; Stop if no ACK
0324+  12B2             	
0325+  12B2             				; Register address (8-bit):
0326+  12B2 7B          				LD			A,E
0327+  12B3 CD C5 11    				CALL		I2C_TX
0328+  12B6 D8          				RET			C					; Stop if no ACK
0329+  12B7             				
0330+  12B7             				; Write B bytes of data, starting at HL
0331+  12B7 7E          WRT_LOOP:		LD			A,(HL)
0332+  12B8 23          				INC			HL
0333+  12B9 CD C5 11    				CALL		I2C_TX
0334+  12BC D8          				RET			C					; Stop if no ACK
0335+  12BD 13          				INC			DE					; NOT SURE ABOUT THIS - INCREMENTS E
0336+  12BE 10 F7       				DJNZ		WRT_LOOP			; Dec B and loop
0337+  12C0 B7          				OR			A
0338+  12C1 C3 B1 11    				JP			I2C_STOP
0339+  12C4             
0340+  12C4             ;------------------------------------------------------------------------------
0341+  12C4             ; I²C WRITE 16-BIT DATA
0342+  12C4             ; Writes a block of data to an I²C-bus device that uses 16-bit addressing.
0343+  12C4             ; Pre:
0344+  12C4             ;   B  = Amount of data to write.
0345+  12C4             ;   C  = Address of device on I²C bus.
0346+  12C4             ;   E  = Address to write data to on device.
0347+  12C4             ;   HL = Pointer to data to write.
0348+  12C4             ; Post:
0349+  12C4             ;   Carry = set if transfer failed, reset if successful.
0350+  12C4             ;   All other flags are undefined; A is destroyed.
0351+  12C4             ;------------------------------------------------------------------------------
0352+  12C4             
0353+  12C4             I2C_WR_D16:
0354+  12C4 CD AA 11    				CALL 		I2C_START
0355+  12C7             	
0356+  12C7             				; Device address:
0357+  12C7 79          				LD 			A,C
0358+  12C8 E6 FE       				AND			%11111110			; Clear the LSB for writes.
0359+  12CA CD C5 11    				CALL		I2C_TX				; Write the address of the device
0360+  12CD D8          				RET			C					; Stop if no ACK
0361+  12CE             	
0362+  12CE             				; Register address (16-bit):
0363+  12CE 7A          				LD			A,D
0364+  12CF CD C5 11    				CALL		I2C_TX
0365+  12D2 D8          				RET			C					; Stop if no ACK
0366+  12D3 7B          				LD			A,E
0367+  12D4 CD C5 11    				CALL		I2C_TX
0368+  12D7 D8          				RET			C					; Stop if no ACK
0369+  12D8             				
0370+  12D8 C3 B7 12    				JP			WRT_LOOP			; Write the 8 bytes
0371+  12DB             
0372+  12DB             ;------------------------------------------------------------------------------
0373+  12DB             ; I²C WRITE ACKnowledge
0374+  12DB             ; Writes an acknowledgement to the currently addressed device.
0375+  12DB             ; Leaves SCL low and SDA high
0376+  12DB             ; Modifies A
0377+  12DB             ;------------------------------------------------------------------------------
0378+  12DB             I2C_ACK:
0379+  12DB CD 05 13    				CALL		SDA_LOW
0380+  12DE CD 15 13    				CALL		SCL_HIGH
0381+  12E1 CD 25 13    				CALL		SCL_LOW
0382+  12E4 CD F5 12    				CALL		SDA_HIGH
0383+  12E7 C9          				RET
0384+  12E8             
0385+  12E8             ;------------------------------------------------------------------------------
0386+  12E8             ; I²C SCL CYCLE
0387+  12E8             ; Every bit transferred via SDA must be accompanied by a L-H-L sequence on SCL.
0388+  12E8             ; After SCL goes H, SDA is sampled.
0389+  12E8             ; Returns D wherein bit 1 represents status of SDA while SCL was high
0390+  12E8             ; Leaves SCL low
0391+  12E8             ; Modifies A
0392+  12E8             ;------------------------------------------------------------------------------
0393+  12E8             SCL_CYCLE:
0394+  12E8 CD 25 13    				CALL		SCL_LOW
0395+  12EB CD 15 13    				CALL		SCL_HIGH
0396+  12EE             				; Look for ACK bit
0397+  12EE DB 21       				IN			A,(PIO_B_D)
0398+  12F0 57          				LD			D,A
0399+  12F1 CD 25 13    				CALL		SCL_LOW
0400+  12F4 C9          				RET
0401+  12F5             
0402+  12F5             ;------------------------------------------------------------------------------
0403+  12F5             ; I²C SET SDA AS INPUT OR OUTPUT
0404+  12F5             ; Setting direction of B1 determines whether a H or L is driver on SDA.
0405+  12F5             ; Reloads PIO B mode
0406+  12F5             ; Modifies A
0407+  12F5             ;------------------------------------------------------------------------------
0408+  12F5             SDA_HIGH:
0409+  12F5 3A 93 40    				LD			A,(PIO_B_MODE)
0410+  12F8 D3 23       				OUT			(PIO_B_C),A
0411+  12FA             				; Change direction of SDA to input
0412+  12FA 3A 94 40    				LD			A,(PIO_B_IO_CONF)
0413+  12FD CB CF       				SET			1,A
0414+  12FF D3 23       				OUT			(PIO_B_C),A
0415+  1301 32 94 40    				LD			(PIO_B_IO_CONF),A
0416+  1304 C9          				RET
0417+  1305             
0418+  1305             SDA_LOW:
0419+  1305 3A 93 40    				LD			A,(PIO_B_MODE)
0420+  1308 D3 23       				OUT			(PIO_B_C),A
0421+  130A             				; Change direction of SDA to output
0422+  130A 3A 94 40    				LD			A,(PIO_B_IO_CONF)
0423+  130D CB 8F       				RES			1,A
0424+  130F D3 23       				OUT			(PIO_B_C),A
0425+  1311 32 94 40    				LD			(PIO_B_IO_CONF),A
0426+  1314 C9          				RET
0427+  1315             
0428+  1315             ;------------------------------------------------------------------------------
0429+  1315             ; I²C SET SCL AS OUTPUT OR INPUT
0430+  1315             ; Setting direction of B0 determines whether a H or L is driver on SCL.
0431+  1315             ; Reloads PIO B mode
0432+  1315             ; Modifies A
0433+  1315             ;------------------------------------------------------------------------------
0434+  1315             SCL_HIGH:
0435+  1315 3A 93 40    				LD			A,(PIO_B_MODE)
0436+  1318 D3 23       				OUT			(PIO_B_C),A
0437+  131A             				; Change direction of SCL to input
0438+  131A 3A 94 40    				LD			A,(PIO_B_IO_CONF)
0439+  131D CB C7       				SET			0,A
0440+  131F D3 23       				OUT			(PIO_B_C),A
0441+  1321 32 94 40    				LD			(PIO_B_IO_CONF),A
0442+  1324 C9          				RET
0443+  1325             
0444+  1325             SCL_LOW:
0445+  1325 3A 93 40    				LD			A,(PIO_B_MODE)
0446+  1328 D3 23       				OUT			(PIO_B_C),A
0447+  132A             				; Change direction of SCL to output
0448+  132A 3A 94 40    				LD			A,(PIO_B_IO_CONF)
0449+  132D CB 87       				RES			0,A
0450+  132F D3 23       				OUT			(PIO_B_C),A
0451+  1331 32 94 40    				LD			(PIO_B_IO_CONF),A
0452+  1334 C9          				RET
0453+  1335             
0454+  1335             ;------------------------------------------------------------------------------
0455+  1335             ; I²C SEND BYTE - called by I2C_TX
0456+  1335             ; Clocks out a data byte in A.
0457+  1335             ; Returns with bit 1 of D holding status of ACK bit
0458+  1335             ; Leaves SCL low and SDA high
0459+  1335             ; Modifies A, B, C, D
0460+  1335             ;------------------------------------------------------------------------------
0461+  1335             I2C_SEND_BYTE:
0462+  1335 06 08       				LD			B,8h				; 8 bits are to be clocked out
0463+  1337 4F          				LD			C,A					; Copy to C reg
0464+  1338 CB 21       I_74:			SLA			C					; Shift MSB of C into carry
0465+  133A DA 43 13    				JP			C,SDA_H				; When low
0466+  133D CD 05 13    SDA_L:			CALL		SDA_LOW				; Pull SDA low
0467+  1340 C3 46 13    				JP			I_75
0468+  1343 CD F5 12    SDA_H:			CALL		SDA_HIGH			; Release SDA to let it go high
0469+  1346 CD E8 12    I_75:			CALL		SCL_CYCLE			; Do SCL cycle (L-H-L)
0470+  1349 10 ED       				DJNZ		I_74				; Process next bit of C reg
0471+  134B CD F5 12    				CALL		SDA_HIGH			; Release SDA to let it go high
0472+  134E CD E8 12    				CALL		SCL_CYCLE			; Do SCL cycle (L-H-L), bit 1 of D
0473+  1351 C9          				RET								; holds ACK bit
0474+  1352             
2244   1352             #INCLUDE	"basic.asm"
0001+  1352             ;==================================================================================
0002+  1352             ; The updates to the original BASIC within this file are copyright Grant Searle
0003+  1352             ;
0004+  1352             ; You have permission to use this for NON COMMERCIAL USE ONLY
0005+  1352             ; If you wish to use it elsewhere, please include an acknowledgement to myself.
0006+  1352             ;
0007+  1352             ; http://searle.hostei.com/grant/index.html
0008+  1352             ;
0009+  1352             ; eMail: home.micros01@btinternet.com
0010+  1352             ;
0011+  1352             ; If the above don't work, please perform an Internet search to see if I have
0012+  1352             ; updated the web page hosting service.
0013+  1352             ;
0014+  1352             ;==================================================================================
0015+  1352             
0016+  1352             ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
0017+  1352             ; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
0018+  1352             ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
0019+  1352             ; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
0020+  1352             ; the original ROM code (checksum A934H). PA
0021+  1352             ;
0022+  1352             ; 29/03/17 - Updated to 4.7b1 after line buffer was moved further up RAM and increased from 72 to 138 characters
0023+  1352             ; 18/04/17 - Updated to 4.7b3; testing addition of new command CLRMEM
0024+  1352             
0025+  1352             ; GENERAL EQUATES
0026+  1352             
0027+  1352             CTRLC   	.EQU    	03H             	; Control "C"
0028+  1352             CTRLG   	.EQU    	07H             	; Control "G"
0029+  1352             BKSP    	.EQU    	08H             	; Back space
0030+  1352             CTRLO   	.EQU    	0FH             	; Control "O"
0031+  1352             CTRLQ		.EQU		11H		      	; Control "Q"
0032+  1352             CTRLR   	.EQU    	12H             	; Control "R"
0033+  1352             CTRLS   	.EQU    	13H             	; Control "S"
0034+  1352             CTRLU   	.EQU    	15H             	; Control "U"
0035+  1352             ESC     		.EQU    	1BH             	; Escape
0036+  1352             DEL     		.EQU    	7FH             	; Delete
0037+  1352             LINELEN	.EQU		8AH				; Maximum line length
0038+  1352             
0039+  1352             ; BASIC WORK SPACE LOCATIONS
0040+  1352             
0041+  1352             WRKSPC  .EQU    BASCLD+20D0H      ; BASIC Work space (RAM_BOTTOM is defined in minicomp.asm)
0042+  1352             USR     .EQU    WRKSPC+3H           ; "USR (x)" jump
0043+  1352             OUTSUB  .EQU    WRKSPC+6H           ; "OUT p,n"
0044+  1352             OTPORT  .EQU    WRKSPC+7H           ; Port (p)
0045+  1352             DIVSUP  .EQU    WRKSPC+9H           ; Division support routine
0046+  1352             DIV1    .EQU    WRKSPC+0AH           ; <- Values
0047+  1352             DIV2    .EQU    WRKSPC+0EH           ; <-   to
0048+  1352             DIV3    .EQU    WRKSPC+12H           ; <-   be
0049+  1352             DIV4    .EQU    WRKSPC+15H           ; <-inserted
0050+  1352             SEED    .EQU    WRKSPC+17H           ; Random number seed
0051+  1352             LSTRND  .EQU    WRKSPC+3AH           ; Last random number
0052+  1352             INPSUB  .EQU    WRKSPC+3EH           ; #INP (x)" Routine
0053+  1352             INPORT  .EQU    WRKSPC+3FH           ; PORT (x)
0054+  1352             NULLS   .EQU    WRKSPC+41H           ; Number of nulls
0055+  1352             LWIDTH  .EQU    WRKSPC+42H           ; Terminal width
0056+  1352             COMMAN  .EQU    WRKSPC+43H           ; Width for commas
0057+  1352             NULFLG  .EQU    WRKSPC+44H           ; Null after input byte flag
0058+  1352             CTLOFG  .EQU    WRKSPC+45H           ; Control "O" flag
0059+  1352             LINESC  .EQU    WRKSPC+46H           ; Lines counter
0060+  1352             LINESN  .EQU    WRKSPC+48H           ; Lines number
0061+  1352             CHKSUM  .EQU    WRKSPC+4AH           ; Array load/save check sum
0062+  1352             NMIFLG  .EQU    WRKSPC+4CH           ; Flag for NMI break routine
0063+  1352             BRKFLG  .EQU    WRKSPC+4DH           ; Break flag
0064+  1352             RINPUT  .EQU    WRKSPC+4EH           ; Input reflection
0065+  1352             POINT   .EQU    WRKSPC+51H           ; "POINT" reflection (unused)
0066+  1352             PSET    .EQU    WRKSPC+54H           ; "SET"   reflection
0067+  1352             RESET   .EQU    WRKSPC+57H           ; "RESET" reflection
0068+  1352             STRSPC  .EQU    WRKSPC+5AH           ; Bottom of string space
0069+  1352             LINEAT  .EQU    WRKSPC+5CH           ; Current line number
0070+  1352             BASTXT  .EQU    WRKSPC+5EH           ; Pointer to start of program
0071+  1352             STACK   .EQU    WRKSPC+66H           ; Initial stack
0072+  1352             CURPOS  .EQU    WRKSPC+0ABH          ; Character position on line
0073+  1352             LCRFLG  .EQU    WRKSPC+0ACH          ; Locate/Create flag
0074+  1352             TYPE    .EQU    WRKSPC+0ADH          ; Data type flag
0075+  1352             DATFLG  .EQU    WRKSPC+0AEH          ; Literal statement flag
0076+  1352             LSTRAM  .EQU    WRKSPC+0AFH          ; Last available RAM
0077+  1352             TMSTPT  .EQU    WRKSPC+0B1H          ; Temporary string pointer
0078+  1352             TMSTPL  .EQU    WRKSPC+0B3H          ; Temporary string pool
0079+  1352             TMPSTR  .EQU    WRKSPC+0BFH          ; Temporary string
0080+  1352             STRBOT  .EQU    WRKSPC+0C3H          ; Bottom of string space
0081+  1352             CUROPR  .EQU    WRKSPC+0C5H          ; Current operator in EVAL
0082+  1352             LOOPST  .EQU    WRKSPC+0C7H          ; First statement of loop
0083+  1352             DATLIN  .EQU    WRKSPC+0C9H          ; Line of current DATA item
0084+  1352             FORFLG  .EQU    WRKSPC+0CBH          ; "FOR" loop flag
0085+  1352             LSTBIN  .EQU    WRKSPC+0CCH          ; Last byte entered
0086+  1352             READFG  .EQU    WRKSPC+0CDH          ; Read/Input flag
0087+  1352             BRKLIN  .EQU    WRKSPC+0CEH          ; Line of break
0088+  1352             NXTOPR  .EQU    WRKSPC+0D0H          ; Next operator in EVAL
0089+  1352             ERRLIN  .EQU    WRKSPC+0D2H          ; Line of error
0090+  1352             CONTAD  .EQU    WRKSPC+0D4H          ; Where to CONTinue
0091+  1352             PROGND  .EQU    WRKSPC+0D6H          ; End of program
0092+  1352             VAREND  .EQU    WRKSPC+0D8H          ; End of variables
0093+  1352             ARREND  .EQU    WRKSPC+0DAH          ; End of arrays
0094+  1352             NXTDAT  .EQU    WRKSPC+0DCH          ; Next data item
0095+  1352             FNRGNM  .EQU    WRKSPC+0DEH          ; Name of FN argument
0096+  1352             FNARG   .EQU    WRKSPC+0E0H          ; FN argument value
0097+  1352             FPREG   .EQU    WRKSPC+0E4H          ; Floating point register
0098+  1352             FPEXP   .EQU    FPREG+3         ; Floating point exponent
0099+  1352             SGNRES  .EQU    WRKSPC+0E8H     ; Sign of result
0100+  1352             PBUFF   .EQU    WRKSPC+0E9H     ; Number print buffer
0101+  1352             MULVAL  .EQU    WRKSPC+0F6H     ; Multiplier
0102+  1352             BUFFER	.EQU	WRKSPC+0F9H		; Input buffer
0103+  1352             PROGST  .EQU    WRKSPC+186H     ; Start of program text area
0104+  1352             STLOOK  .EQU    WRKSPC+1EAH     ; Start of memory test
0105+  1352             
0106+  1352             ; BASIC ERROR CODE VALUES
0107+  1352             
0108+  1352             NF      .EQU    00H             ; NEXT without FOR
0109+  1352             SN      .EQU    11H             ; Syntax error
0110+  1352             RG      .EQU    18H             ; RETURN without GOSUB
0111+  1352             OD      .EQU    1BH             ; Out of DATA
0112+  1352             FC      .EQU    1EH             ; Function call error
0113+  1352             OV      .EQU    21H             ; Overflow
0114+  1352             OM      .EQU    24H             ; Out of memory
0115+  1352             UL      .EQU    27H             ; Undefined line number
0116+  1352             BS      .EQU    2AH             ; Bad subscript
0117+  1352             DD      .EQU    2DH             ; Re-DIMensioned array
0118+  1352             DZ      .EQU    30H             ; Division by zero (/0)
0119+  1352             ID      .EQU    33H             ; Illegal direct
0120+  1352             TM      .EQU    36H             ; Type miss-match
0121+  1352             OS      .EQU    39H             ; Out of string space
0122+  1352             LS      .EQU    3CH             ; String too long
0123+  1352             ST      .EQU    3FH             ; String formula too complex
0124+  1352             CN      .EQU    42H             ; Can't CONTinue
0125+  1352             UF      .EQU    45H             ; UnDEFined FN function
0126+  1352             MO      .EQU    48H             ; Missing operand
0127+  1352             HX      .EQU    4BH             ; HEX error
0128+  1352             BN      .EQU    4EH             ; BIN error
0129+  1352             
0130+  2000                     .ORG    BASCLD
0131+  2000             
0132+  2000 C3 06 20    COLD:   JP      STARTB          ; Jump for cold start
0133+  2003 C3 A4 20    WARM:   JP      WARMST          ; Jump for warm start
0134+  2006             
0135+  2006             STARTB: 
0136+  2006 DD 21 00 00         LD      IX,0            ; Flag cold start
0137+  200A C3 11 20            JP      CSTART          ; Jump to initialise
0138+  200D             
0139+  200D 1D 29               .WORD   DEINT           ; Get integer -32768 to 32767
0140+  200F 93 30               .WORD   ABPASS          ; Return integer in AB
0141+  2011             
0142+  2011             
0143+  2011 21 D0 40    CSTART: LD      HL,WRKSPC       ; Start of workspace RAM
0144+  2014 F9                  LD      SP,HL           ; Set up a temporary stack
0145+  2015 C3 D6 3C            JP      INITST          ; Go to initialise
0146+  2018             
0147+  2018 11 31 23    B_INIT: LD      DE,INITAB       ; Initialise workspace
0148+  201B 06 63               LD      B,INITBE-INITAB+3; Bytes to copy
0149+  201D 21 D0 40            LD      HL,WRKSPC       ; Into workspace RAM
0150+  2020 1A          COPY:   LD      A,(DE)          ; Get source
0151+  2021 77                  LD      (HL),A          ; To destination
0152+  2022 23                  INC     HL              ; Next destination
0153+  2023 13                  INC     DE              ; Next source
0154+  2024 05                  DEC     B               ; Count bytes
0155+  2025 C2 20 20            JP      NZ,COPY         ; More to move
0156+  2028 F9                  LD      SP,HL           ; Temporary stack
0157+  2029 CD 37 25            CALL    CLREG           ; Clear registers and stack
0158+  202C CD 13 2B            CALL    PRNTCRLF        ; Output CRLF
0159+  202F 32 54 42            LD      (BUFFER+LINELEN+1),A ; Mark end of buffer
0160+  2032 32 56 42            LD      (PROGST),A      ; Initialise program area
0161+  2035 21 1D 21    MSIZE:  LD      HL,MEMMSG       ; Point to message
0162+  2038 CD B1 31            CALL    PRS             ; Output "Memory size"
0163+  203B CD 54 25            CALL    PROMPT          ; Get input with '?'
0164+  203E CD 6A 28            CALL    GETCHR          ; Get next character
0165+  2041 B7                  OR      A               ; Set flags
0166+  2042 C2 5A 20            JP      NZ,TSTMEM       ; If number - Test if RAM there
0167+  2045 21 BA 42            LD      HL,STLOOK       ; Point to start of RAM
0168+  2048 23          MLOOP:  INC     HL              ; Next byte
0169+  2049 7C                  LD      A,H             ; Above address FFFF ?
0170+  204A B5                  OR      L
0171+  204B CA 6C 20            JP      Z,SETTOP        ; Yes - 64K RAM
0172+  204E 7E                  LD      A,(HL)          ; Get contents
0173+  204F 47                  LD      B,A             ; Save it
0174+  2050 2F                  CPL                     ; Flip all bits
0175+  2051 77                  LD      (HL),A          ; Put it back
0176+  2052 BE                  CP      (HL)            ; RAM there if same
0177+  2053 70                  LD      (HL),B          ; Restore old contents
0178+  2054 CA 48 20            JP      Z,MLOOP         ; If RAM - test next byte
0179+  2057 C3 6C 20            JP      SETTOP          ; Top of RAM found
0180+  205A             
0181+  205A CD 37 29    TSTMEM: CALL    ATOH            ; Get high memory into DE
0182+  205D B7                  OR      A               ; Set flags on last byte
0183+  205E C2 03 24            JP      NZ,SNERR        ; ?SN Error if bad character
0184+  2061 EB                  EX      DE,HL           ; Address into HL
0185+  2062 2B                  DEC     HL              ; Back one byte
0186+  2063 3E D9               LD      A,11011001B     ; Test byte
0187+  2065 46                  LD      B,(HL)          ; Get old contents
0188+  2066 77                  LD      (HL),A          ; Load test byte
0189+  2067 BE                  CP      (HL)            ; RAM there if same
0190+  2068 70                  LD      (HL),B          ; Restore old contents
0191+  2069 C2 35 20            JP      NZ,MSIZE        ; Ask again if no RAM
0192+  206C             
0193+  206C 2B          SETTOP: DEC     HL              ; Back one byte
0194+  206D 11 B9 42            LD      DE,STLOOK-1     ; See if enough RAM
0195+  2070 CD DA 26            CALL    CPDEHL          ; Compare DE with HL
0196+  2073 DA 35 20            JP      C,MSIZE         ; Ask again if not enough RAM
0197+  2076 11 CE FF            LD      DE,0-50         ; 50 Bytes string space
0198+  2079 22 7F 41            LD      (LSTRAM),HL     ; Save last available RAM
0199+  207C 19                  ADD     HL,DE           ; Allocate string space
0200+  207D 22 2A 41            LD      (STRSPC),HL     ; Save string space
0201+  2080 CD 12 25            CALL    CLRPTR          ; Clear program area
0202+  2083 2A 2A 41            LD      HL,(STRSPC)     ; Get end of memory
0203+  2086 11 EF FF            LD      DE,0-17         ; Offset for free bytes
0204+  2089 19                  ADD     HL,DE           ; Adjust HL
0205+  208A 11 56 42            LD      DE,PROGST       ; Start of program text
0206+  208D 7D                  LD      A,L             ; Get LSB
0207+  208E 93                  SUB     E               ; Adjust it
0208+  208F 6F                  LD      L,A             ; Re-save
0209+  2090 7C                  LD      A,H             ; Get MSB
0210+  2091 9A                  SBC     A,D             ; Adjust it
0211+  2092 67                  LD      H,A             ; Re-save
0212+  2093 E5                  PUSH    HL              ; Save bytes free
0213+  2094 21 BC 20            LD      HL,SIGNON       ; Sign-on message
0214+  2097 CD B1 31            CALL    PRS             ; Output string
0215+  209A E1                  POP     HL              ; Get bytes free back
0216+  209B CD 78 38            CALL    PRNTHL          ; Output amount of free memory
0217+  209E 21 AD 20            LD      HL,BFREE        ; " Bytes free" message
0218+  20A1 CD B1 31            CALL    PRS             ; Output string
0219+  20A4             
0220+  20A4 31 36 41    WARMST: LD      SP,STACK        ; Temporary stack
0221+  20A7 CD 37 25    BRKRET: CALL    CLREG           ; Clear registers and stack
0222+  20AA C3 50 24            JP      PRNTOK          ; Go to get command line
0223+  20AD             
0224+  20AD 204279746573BFREE:  .BYTE   " Bytes free",CR,LF,0,0
0224+  20B3 20667265650D0A0000
0225+  20BC             
0226+  20BC 5A3830204241SIGNON: .BYTE   "Z80 BASIC Ver 4.7b5",CR,LF
0226+  20C2 5349432056657220342E3762350D0A
0227+  20D1 436F70797269        .BYTE   "Copyright ",40,"C",41
0227+  20D7 67687420284329
0228+  20DE 203139373820        .BYTE   " 1978 Microsoft",CR,LF,0,0
0228+  20E4 4D6963726F736F66740D0A0000
0229+  20F1             
0230+  20F1 4D656D6F7279CLRMSG:	.BYTE	"Memory cleared",CR,LF,0,0
0230+  20F7 20636C65617265640D0A0000
0231+  2103 546869732069TSTMSG:	.BYTE	"This is a test message!",CR,LF,0
0231+  2109 7320612074657374206D657373616765210D0A00
0232+  211D 4D656D6F7279MEMMSG: .BYTE   "Memory top",0
0232+  2123 20746F7000
0233+  2128             
0234+  2128             ; FUNCTION ADDRESS TABLE
0235+  2128             
0236+  2128 ED 36       FNCTAB: .WORD   SGN
0237+  212A B1 37               .WORD   INT
0238+  212C 03 37               .WORD   ABS
0239+  212E D3 40               .WORD   USR
0240+  2130 71 30               .WORD   FRE
0241+  2132 F6 33               .WORD   INP
0242+  2134 9F 30               .WORD   POS
0243+  2136 77 39               .WORD   SQR
0244+  2138 56 3A               .WORD   RND
0245+  213A 92 35               .WORD   LOG
0246+  213C C5 39               .WORD   EXP
0247+  213E CB 3A               .WORD   COS
0248+  2140 D1 3A               .WORD   SIN
0249+  2142 32 3B               .WORD   TAN
0250+  2144 47 3B               .WORD   ATN
0251+  2146 6E 34               .WORD   PEEK
0252+  2148 B2 3B               .WORD   DEEK
0253+  214A 21 41               .WORD   POINT
0254+  214C 23 33               .WORD   LEN
0255+  214E 3B 31               .WORD   STR
0256+  2150 BD 33               .WORD   VAL
0257+  2152 32 33               .WORD   ASC
0258+  2154 43 33               .WORD   CHR
0259+  2156 D4 3B               .WORD   HEX
0260+  2158 67 3C               .WORD   BIN
0261+  215A 53 34       		.WORD	CLRMEM
0262+  215C 53 33               .WORD   LEFT
0263+  215E 83 33               .WORD   RIGHT
0264+  2160 8D 33               .WORD   MID
0265+  2162             
0266+  2162             ; RESERVED WORD LIST
0267+  2162             
0268+  2162 C5 4E 44    WORDS:  .BYTE   'E'+80H,"ND"
0269+  2165 C6 4F 52            .BYTE   'F'+80H,"OR"
0270+  2168 CE 45 58 54         .BYTE   'N'+80H,"EXT"
0271+  216C C4 41 54 41         .BYTE   'D'+80H,"ATA"
0272+  2170 C94E505554          .BYTE   'I'+80H,"NPUT"
0273+  2175 C4 49 4D            .BYTE   'D'+80H,"IM"
0274+  2178 D2 45 41 44         .BYTE   'R'+80H,"EAD"
0275+  217C CC 45 54            .BYTE   'L'+80H,"ET"
0276+  217F C7 4F 54 4F         .BYTE   'G'+80H,"OTO"
0277+  2183 D2 55 4E            .BYTE   'R'+80H,"UN"
0278+  2186 C9 46               .BYTE   'I'+80H,"F"
0279+  2188 D24553544F52        .BYTE   'R'+80H,"ESTORE"
0279+  218E 45
0280+  218F C74F535542          .BYTE   'G'+80H,"OSUB"
0281+  2194 D2455455524E        .BYTE   'R'+80H,"ETURN"
0282+  219A D2 45 4D            .BYTE   'R'+80H,"EM"
0283+  219D D3 54 4F 50         .BYTE   'S'+80H,"TOP"
0284+  21A1 CF 55 54            .BYTE   'O'+80H,"UT"
0285+  21A4 CF 4E               .BYTE   'O'+80H,"N"
0286+  21A6 CE 55 4C 4C         .BYTE   'N'+80H,"ULL"
0287+  21AA D7 41 49 54         .BYTE   'W'+80H,"AIT"
0288+  21AE C4 45 46            .BYTE   'D'+80H,"EF"
0289+  21B1 D0 4F 4B 45         .BYTE   'P'+80H,"OKE"
0290+  21B5 C4 4F 4B 45         .BYTE   'D'+80H,"OKE"
0291+  21B9 D3435245454E        .BYTE   'S'+80H,"CREEN"
0292+  21BF CC494E4553          .BYTE   'L'+80H,"INES"
0293+  21C4 C3 4C 53            .BYTE   'C'+80H,"LS"
0294+  21C7 D749445448          .BYTE   'W'+80H,"IDTH"
0295+  21CC CD4F4E49544F        .BYTE   'M'+80H,"ONITOR"
0295+  21D2 52
0296+  21D3 D3 45 54            .BYTE   'S'+80H,"ET"
0297+  21D6 D245534554          .BYTE   'R'+80H,"ESET"
0298+  21DB D052494E54          .BYTE   'P'+80H,"RINT"
0299+  21E0 C3 4F 4E 54         .BYTE   'C'+80H,"ONT"
0300+  21E4 CC 49 53 54         .BYTE   'L'+80H,"IST"
0301+  21E8 C34C454152          .BYTE   'C'+80H,"LEAR"
0302+  21ED D4 45 53 54         .BYTE   'T'+80H,"EST"
0303+  21F1 C34C524D454D        .BYTE   'C'+80H,"LRMEM"
0304+  21F7 CE 45 57            .BYTE   'N'+80H,"EW"
0305+  21FA             		
0306+  21FA D4 41 42 28         .BYTE   'T'+80H,"AB("
0307+  21FE D4 4F               .BYTE   'T'+80H,"O"
0308+  2200 C6 4E               .BYTE   'F'+80H,"N"
0309+  2202 D3 50 43 28         .BYTE   'S'+80H,"PC("
0310+  2206 D4 48 45 4E         .BYTE   'T'+80H,"HEN"
0311+  220A CE 4F 54            .BYTE   'N'+80H,"OT"
0312+  220D D3 54 45 50         .BYTE   'S'+80H,"TEP"
0313+  2211             
0314+  2211 AB                  .BYTE   '+'+80H
0315+  2212 AD                  .BYTE   '-'+80H
0316+  2213 AA                  .BYTE   '*'+80H
0317+  2214 AF                  .BYTE   '/'+80H
0318+  2215 DE                  .BYTE   '^'+80H
0319+  2216 C1 4E 44            .BYTE   'A'+80H,"ND"
0320+  2219 CF 52               .BYTE   'O'+80H,"R"
0321+  221B BE                  .BYTE   '>'+80H
0322+  221C BD                  .BYTE   '='+80H
0323+  221D BC                  .BYTE   '<'+80H
0324+  221E             
0325+  221E D3 47 4E            .BYTE   'S'+80H,"GN"
0326+  2221 C9 4E 54            .BYTE   'I'+80H,"NT"
0327+  2224 C1 42 53            .BYTE   'A'+80H,"BS"
0328+  2227 D5 53 52            .BYTE   'U'+80H,"SR"
0329+  222A C6 52 45            .BYTE   'F'+80H,"RE"
0330+  222D C9 4E 50            .BYTE   'I'+80H,"NP"
0331+  2230 D0 4F 53            .BYTE   'P'+80H,"OS"
0332+  2233 D3 51 52            .BYTE   'S'+80H,"QR"
0333+  2236 D2 4E 44            .BYTE   'R'+80H,"ND"
0334+  2239 CC 4F 47            .BYTE   'L'+80H,"OG"
0335+  223C C5 58 50            .BYTE   'E'+80H,"XP"
0336+  223F C3 4F 53            .BYTE   'C'+80H,"OS"
0337+  2242 D3 49 4E            .BYTE   'S'+80H,"IN"
0338+  2245 D4 41 4E            .BYTE   'T'+80H,"AN"
0339+  2248 C1 54 4E            .BYTE   'A'+80H,"TN"
0340+  224B D0 45 45 4B         .BYTE   'P'+80H,"EEK"
0341+  224F C4 45 45 4B         .BYTE   'D'+80H,"EEK"
0342+  2253 D04F494E54          .BYTE   'P'+80H,"OINT"
0343+  2258 CC 45 4E            .BYTE   'L'+80H,"EN"
0344+  225B D3 54 52 24         .BYTE   'S'+80H,"TR$"
0345+  225F D6 41 4C            .BYTE   'V'+80H,"AL"
0346+  2262 C1 53 43            .BYTE   'A'+80H,"SC"
0347+  2265 C3 48 52 24         .BYTE   'C'+80H,"HR$"
0348+  2269 C8 45 58 24         .BYTE   'H'+80H,"EX$"
0349+  226D C2 49 4E 24         .BYTE   'B'+80H,"IN$"
0350+  2271 CC45465424          .BYTE   'L'+80H,"EFT$"
0351+  2276 D24947485424        .BYTE   'R'+80H,"IGHT$"
0352+  227C CD 49 44 24         .BYTE   'M'+80H,"ID$"
0353+  2280 80                  .BYTE   80H             ; End of list marker
0354+  2281             
0355+  2281             ; KEYWORD ADDRESS TABLE
0356+  2281             
0357+  2281 B4 28       WORDTB: .WORD   PEND
0358+  2283 B1 27               .WORD   FOR
0359+  2285 8D 2C               .WORD   NEXT
0360+  2287 02 2A               .WORD   DATA
0361+  2289 94 2B               .WORD   INPUT
0362+  228B C9 2E               .WORD   DIM
0363+  228D C3 2B               .WORD   READ
0364+  228F 19 2A               .WORD   LET
0365+  2291 BF 29               .WORD   GOTO
0366+  2293 A2 29               .WORD   RUN
0367+  2295 91 2A               .WORD   IF
0368+  2297 7A 28               .WORD   RESTOR
0369+  2299 AE 29               .WORD   GOSUB
0370+  229B DD 29               .WORD   RETURN
0371+  229D 04 2A               .WORD   REM
0372+  229F B2 28               .WORD   STOP
0373+  22A1 02 34               .WORD   POUT
0374+  22A3 73 2A               .WORD   ON
0375+  22A5 F4 28               .WORD   NULL
0376+  22A7 08 34               .WORD   WAIT
0377+  22A9 A7 30               .WORD   DEF
0378+  22AB 75 34               .WORD   POKE
0379+  22AD BD 3B               .WORD   DOKE
0380+  22AF 04 2A               .WORD   REM
0381+  22B1 A3 3B               .WORD   LINES
0382+  22B3 96 3B               .WORD   CLS
0383+  22B5 9B 3B               .WORD   WIDTH
0384+  22B7 D3 3C               .WORD   MONITR
0385+  22B9 24 41               .WORD   PSET
0386+  22BB 27 41               .WORD   RESET
0387+  22BD B5 2A               .WORD   PRINT
0388+  22BF E0 28               .WORD   CONT
0389+  22C1 26 27               .WORD   LIST
0390+  22C3 5C 29               .WORD   CLEAR
0391+  22C5 4A 34               .WORD   TEST			; TEST token is directed to TEST VAR
0392+  22C7 53 34               .WORD   CLRMEM			; CLRMEM token is directed to CLRMEM VAR
0393+  22C9 11 25               .WORD   NEW
0394+  22CB             
0395+  22CB             ; RESERVED WORD TOKEN VALUES
0396+  22CB             
0397+  22CB             ZEND    .EQU    080H            ; END
0398+  22CB             ZFOR    .EQU    081H            ; FOR
0399+  22CB             ZDATA   .EQU    083H            ; DATA
0400+  22CB             ZGOTO   .EQU    088H            ; GOTO
0401+  22CB             ZGOSUB  .EQU    08CH            ; GOSUB
0402+  22CB             ZREM    .EQU    08EH            ; REM
0403+  22CB             ZPRINT  .EQU    09EH            ; PRINT
0404+  22CB             ZNEW    .EQU    0A4H            ; NEW
0405+  22CB             
0406+  22CB             ZTAB    .EQU    0A5H            ; TAB
0407+  22CB             ZTO     .EQU    0A6H            ; TO
0408+  22CB             ZFN     .EQU    0A7H            ; FN
0409+  22CB             ZSPC    .EQU    0A8H            ; SPC
0410+  22CB             ZTHEN   .EQU    0A9H            ; THEN
0411+  22CB             ZNOT    .EQU    0AAH            ; NOT
0412+  22CB             ZSTEP   .EQU    0ABH            ; STEP
0413+  22CB             
0414+  22CB             ZPLUS   .EQU    0ACH            ; +
0415+  22CB             ZMINUS  .EQU    0ADH            ; -
0416+  22CB             ZTIMES  .EQU    0AEH            ; *
0417+  22CB             ZDIV    .EQU    0AFH            ; /
0418+  22CB             
0419+  22CB             ZOR     .EQU    0B2H            ; OR
0420+  22CB             ZGTR    .EQU    0B3H            ; >
0421+  22CB             ZEQUAL  .EQU    0B4H            ; M
0422+  22CB             ZLTH    .EQU    0B5H            ; <
0423+  22CB             ZSGN    .EQU    0B6H            ; SGN
0424+  22CB             
0425+  22CB             ZPOINT  .EQU    0C7H            ; POINT
0426+  22CB             ZLEFT   .EQU    0CDH +2         ; LEFT$
0427+  22CB             
0428+  22CB             ; ARITHMETIC PRECEDENCE TABLE
0429+  22CB             
0430+  22CB 79          PRITAB: .BYTE   79H             ; Precedence value
0431+  22CC 5F 38               .WORD   PADD            ; FPREG = <last> + FPREG
0432+  22CE             
0433+  22CE 79                  .BYTE   79H             ; Precedence value
0434+  22CF 93 34               .WORD   PSUB            ; FPREG = <last> - FPREG
0435+  22D1             
0436+  22D1 7C                  .BYTE   7CH             ; Precedence value
0437+  22D2 D1 35               .WORD   MULT            ; PPREG = <last> * FPREG
0438+  22D4             
0439+  22D4 7C                  .BYTE   7CH             ; Precedence value
0440+  22D5 32 36               .WORD   DIV             ; FPREG = <last> / FPREG
0441+  22D7             
0442+  22D7 7F                  .BYTE   7FH             ; Precedence value
0443+  22D8 80 39               .WORD   POWER           ; FPREG = <last> ^ FPREG
0444+  22DA             
0445+  22DA 50                  .BYTE   50H             ; Precedence value
0446+  22DB 22 2E               .WORD   PAND            ; FPREG = <last> AND FPREG
0447+  22DD             
0448+  22DD 46                  .BYTE   46H             ; Precedence value
0449+  22DE 21 2E               .WORD   POR             ; FPREG = <last> OR FPREG
0450+  22E0             
0451+  22E0             ; BASIC ERROR CODE LIST
0452+  22E0             
0453+  22E0 4E4558542077ERRORS: .BYTE   "NEXT without FOR",0    ; NEXT without FOR
0453+  22E6 6974686F757420464F5200
0454+  22F1 53796E746178        .BYTE   "Syntax",0          ; Syntax error
0454+  22F7 00
0455+  22F8 52 47 00            .BYTE   "RG",0          ; RETURN without GOSUB
0456+  22FB 4F 44 00            .BYTE   "OD",0          ; Out of DATA
0457+  22FE 46 43 00            .BYTE   "FC",0          ; Illegal function call
0458+  2301 4F 56 00            .BYTE   "OV",0          ; Overflow error
0459+  2304 4F 4D 00            .BYTE   "OM",0          ; Out of memory
0460+  2307 55 4C 00            .BYTE   "UL",0          ; Undefined line
0461+  230A 42 53 00            .BYTE   "BS",0          ; Bad subscript
0462+  230D 44 44 00            .BYTE   "DD",0          ; Re-DIMensioned array
0463+  2310 2F 30 00            .BYTE   "/0",0          ; Division by zero
0464+  2313 49 44 00            .BYTE   "ID",0          ; Illegal direct
0465+  2316 54 4D 00            .BYTE   "TM",0          ; Type mis-match
0466+  2319 4F 53 00            .BYTE   "OS",0          ; Out of string space
0467+  231C 4C 53 00            .BYTE   "LS",0          ; String too long
0468+  231F 53 54 00            .BYTE   "ST",0          ; String formula too complex
0469+  2322 43 4E 00            .BYTE   "CN",0          ; Can't CONTinue
0470+  2325 55 46 00            .BYTE   "UF",0          ; Undefined FN function
0471+  2328 4D 4F 00            .BYTE   "MO",0          ; Missing operand
0472+  232B 48 58 00            .BYTE   "HX",0          ; HEX error
0473+  232E 42 4E 00            .BYTE   "BN",0          ; BIN error
0474+  2331             
0475+  2331             ; INITIALISATION TABLE -------------------------------------------------------
0476+  2331             
0477+  2331 C3 A4 20    INITAB: JP      WARMST          ; Warm start jump
0478+  2334 C3 32 29            JP      FCERR           ; "USR (X)" jump (Set to Error)
0479+  2337 D3 00               OUT     (0),A           ; "OUT p,n" skeleton
0480+  2339 C9                  RET
0481+  233A D6 00               SUB     0               ; Division support routine
0482+  233C 6F                  LD      L,A
0483+  233D 7C                  LD      A,H
0484+  233E DE 00               SBC     A,0
0485+  2340 67                  LD      H,A
0486+  2341 78                  LD      A,B
0487+  2342 DE 00               SBC     A,0
0488+  2344 47                  LD      B,A
0489+  2345 3E 00               LD      A,0
0490+  2347 C9                  RET
0491+  2348 00 00 00            .BYTE   0,0,0                   ; Random number seed table used by RND
0492+  234B 35 4A CA 99         .BYTE   035H,04AH,0CAH,099H     ;-2.65145E+07
0493+  234F 39 1C 76 98         .BYTE   039H,01CH,076H,098H     ; 1.61291E+07
0494+  2353 22 95 B3 98         .BYTE   022H,095H,0B3H,098H     ;-1.17691E+07
0495+  2357 0A DD 47 98         .BYTE   00AH,0DDH,047H,098H     ; 1.30983E+07
0496+  235B 53 D1 99 99         .BYTE   053H,0D1H,099H,099H     ;-2-01612E+07
0497+  235F 0A 1A 9F 98         .BYTE   00AH,01AH,09FH,098H     ;-1.04269E+07
0498+  2363 65 BC CD 98         .BYTE   065H,0BCH,0CDH,098H     ;-1.34831E+07
0499+  2367 D6 77 3E 98         .BYTE   0D6H,077H,03EH,098H     ; 1.24825E+07
0500+  236B 52 C7 4F 80         .BYTE   052H,0C7H,04FH,080H     ; Last random number
0501+  236F DB 00               IN      A,(0)           ; INP (x) skeleton
0502+  2371 C9                  RET
0503+  2372 01                  .BYTE   1               ; POS (x) number (1)
0504+  2373 FF                  .BYTE   255             ; Terminal width (255 = no auto CRLF)
0505+  2374 1C                  .BYTE   28              ; Width for commas (3 columns)
0506+  2375 00                  .BYTE   0               ; No nulls after input bytes
0507+  2376 00                  .BYTE   0               ; Output enabled (^O off)
0508+  2377 14 00               .WORD   20              ; Initial lines counter
0509+  2379 14 00               .WORD   20              ; Initial lines number
0510+  237B 00 00               .WORD   0               ; Array load/save check sum
0511+  237D 00                  .BYTE   0               ; Break not by NMI
0512+  237E 00                  .BYTE   0               ; Break flag
0513+  237F C3 57 26            JP      TTYLIN          ; Input reflection (set to TTY)
0514+  2382 C3 00 00            JP      $0000           ; POINT reflection unused
0515+  2385 C3 00 00            JP      $0000           ; SET reflection
0516+  2388 C3 00 00            JP      $0000          	; RESET reflection
0517+  238B BA 42               .WORD   STLOOK          ; Temp string space
0518+  238D FE FF               .WORD   -2              ; Current line number (cold)
0519+  238F 57 42               .WORD   PROGST+1        ; Start of program text
0520+  2391             INITBE:                         
0521+  2391             
0522+  2391             ; END OF INITIALISATION TABLE ---------------------------------------------------
0523+  2391             
0524+  2391 204572726F72ERRMSG: .BYTE   " Error",0
0524+  2397 00
0525+  2398 20696E2000  INMSG:  .BYTE   " in ",0
0526+  239D             ZERBYT  .EQU    $-1             ; A zero byte
0527+  239D 52656164790DOKMSG:  .BYTE   "Ready",CR,LF,0,0
0527+  23A3 0A0000
0528+  23A6 427265616B00BRKMSG: .BYTE   "Break",0
0529+  23AC             
0530+  23AC 21 04 00    BAKSTK: LD      HL,4            ; Look for "FOR" block with
0531+  23AF 39                  ADD     HL,SP           ; same index as specified
0532+  23B0 7E          LOKFOR: LD      A,(HL)          ; Get block ID
0533+  23B1 23                  INC     HL              ; Point to index address
0534+  23B2 FE 81               CP      ZFOR            ; Is it a "FOR" token
0535+  23B4 C0                  RET     NZ              ; No - exit
0536+  23B5 4E                  LD      C,(HL)          ; BC = Address of "FOR" index
0537+  23B6 23                  INC     HL
0538+  23B7 46                  LD      B,(HL)
0539+  23B8 23                  INC     HL              ; Point to sign of STEP
0540+  23B9 E5                  PUSH    HL              ; Save pointer to sign
0541+  23BA 69                  LD      L,C             ; HL = address of "FOR" index
0542+  23BB 60                  LD      H,B
0543+  23BC 7A                  LD      A,D             ; See if an index was specified
0544+  23BD B3                  OR      E               ; DE = 0 if no index specified
0545+  23BE EB                  EX      DE,HL           ; Specified index into HL
0546+  23BF CA C6 23            JP      Z,INDFND        ; Skip if no index given
0547+  23C2 EB                  EX      DE,HL           ; Index back into DE
0548+  23C3 CD DA 26            CALL    CPDEHL          ; Compare index with one given
0549+  23C6 01 0D 00    INDFND: LD      BC,16-3         ; Offset to next block
0550+  23C9 E1                  POP     HL              ; Restore pointer to sign
0551+  23CA C8                  RET     Z               ; Return if block found
0552+  23CB 09                  ADD     HL,BC           ; Point to next block
0553+  23CC C3 B0 23            JP      LOKFOR          ; Keep on looking
0554+  23CF             
0555+  23CF CD E9 23    MOVUP:  CALL    ENFMEM          ; See if enough memory
0556+  23D2 C5          MOVSTR: PUSH    BC              ; Save end of source
0557+  23D3 E3                  EX      (SP),HL         ; Swap source and dest" end
0558+  23D4 C1                  POP     BC              ; Get end of destination
0559+  23D5 CD DA 26    MOVLP:  CALL    CPDEHL          ; See if list moved
0560+  23D8 7E                  LD      A,(HL)          ; Get byte
0561+  23D9 02                  LD      (BC),A          ; Move it
0562+  23DA C8                  RET     Z               ; Exit if all done
0563+  23DB 0B                  DEC     BC              ; Next byte to move to
0564+  23DC 2B                  DEC     HL              ; Next byte to move
0565+  23DD C3 D5 23            JP      MOVLP           ; Loop until all bytes moved
0566+  23E0             
0567+  23E0 E5          CHKSTK: PUSH    HL              ; Save code string address
0568+  23E1 2A AA 41            LD      HL,(ARREND)     ; Lowest free memory
0569+  23E4 06 00               LD      B,0             ; BC = Number of levels to test
0570+  23E6 09                  ADD     HL,BC           ; 2 Bytes for each level
0571+  23E7 09                  ADD     HL,BC
0572+  23E8 3E                  .BYTE   3EH             ; Skip "PUSH HL"
0573+  23E9 E5          ENFMEM: PUSH    HL              ; Save code string address
0574+  23EA 3E D0               LD      A,0D0H ;LOW -48 ; 48 Bytes minimum RAM
0575+  23EC 95                  SUB     L
0576+  23ED 6F                  LD      L,A
0577+  23EE 3E FF               LD      A,0FFH; HIGH (-48) ; 48 Bytes minimum RAM
0578+  23F0 9C                  SBC     A,H
0579+  23F1 DA F8 23            JP      C,OMERR         ; Not enough - ?OM Error
0580+  23F4 67                  LD      H,A
0581+  23F5 39                  ADD     HL,SP           ; Test if stack is overflowed
0582+  23F6 E1                  POP     HL              ; Restore code string address
0583+  23F7 D8                  RET     C               ; Return if enough mmory
0584+  23F8 1E 24       OMERR:  LD      E,OM            ; ?OM Error
0585+  23FA C3 1E 24            JP      ERROR
0586+  23FD             
0587+  23FD 2A 99 41    DATSNR: LD      HL,(DATLIN)     ; Get line of current DATA item
0588+  2400 22 2C 41            LD      (LINEAT),HL     ; Save as current line
0589+  2403 11 11 00    SNERR:  LD      DE,SN            ; ?SN Error
0590+  2406 01                  .BYTE   01H             ; Skip "LD E,DZ"
0591+  2407 11 30 00    DZERR:  LD      DE,DZ            ; ?/0 Error
0592+  240A 01                  .BYTE   01H             ; Skip "LD E,NF"
0593+  240B 11 00 00    NFERR:  LD      DE,NF            ; ?NF Error
0594+  240E 01                  .BYTE   01H             ; Skip "LD E,DD"
0595+  240F 11 2D 00    DDERR:  LD      DE,DD            ; ?DD Error
0596+  2412 01                  .BYTE   01H             ; Skip "LD E,UF"
0597+  2413 11 45 00    UFERR:  LD      DE,UF            ; ?UF Error
0598+  2416 01                  .BYTE   01H             ; Skip "LD E,OV
0599+  2417 11 21 00    OVERR:  LD      DE,OV            ; ?OV Error
0600+  241A 01                  .BYTE   01H             ; Skip "LD E,TM"
0601+  241B 11 36 00    TMERR:  LD      DE,TM            ; ?TM Error
0602+  241E             
0603+  241E             ERROR:  
0604+  241E CD 37 25    		CALL    CLREG           	; Clear registers and stack
0605+  2421 32 15 41            LD      	(CTLOFG),A      	; Enable output (A is 0)
0606+  2424 CD 06 2B            CALL    STTLIN          	; Start new line
0607+  2427 21 E0 22            LD      	HL,ERRORS   	; Point to error codes
0608+  242A 19                  ADD     HL,DE           		; Offset to correct error code
0609+  242B 7E                  LD      	A,(HL)          		; First character
0610+  242C             PRTERR: 
0611+  242C CD EB 26    		CALL    OUTC            	; Output it
0612+  242F 23          		INC		HL					; Get next character
0613+  2430 7E          		LD      	A,(HL)				; Load next character
0614+  2431 FE 00       		CP		EOS              	; Is it $00 ?
0615+  2433 C2 2C 24    		JP		NZ,PRTERR		; Not $00, loop and print
0616+  2436 21 91 23            LD      	HL,ERRMSG   	; "Error" message
0617+  2439             ERRIN:  
0618+  2439 CD B1 31    		CALL    PRS             ; Output message
0619+  243C 2A 2C 41            LD      	HL,(LINEAT)     ; Get line of error
0620+  243F 11 FE FF            LD      	DE,-2           ; Cold start error if -2
0621+  2442 CD DA 26            CALL    CPDEHL          ; See if cold start error
0622+  2445 CA 11 20            JP      	Z,CSTART        ; Cold start error - Restart
0623+  2448 7C                  LD      	A,H             ; Was it a direct error?
0624+  2449 A5                  AND    	L               ; Line = -1 if direct error
0625+  244A 3C                  INC     	A
0626+  244B C4 70 38            CALL    NZ,LINEIN       ; No - output line of error
0627+  244E 3E                  .BYTE   3EH             ; Skip "POP BC"
0628+  244F C1          POPNOK: POP     BC              ; Drop address in input buffer
0629+  2450             
0630+  2450 AF          PRNTOK: XOR     A               ; Output "Ok" and get command
0631+  2451 32 15 41            LD      (CTLOFG),A      ; Enable output
0632+  2454 CD 06 2B            CALL    STTLIN          ; Start new line
0633+  2457 21 9D 23            LD      HL,OKMSG        ; "Ok" message
0634+  245A CD B1 31            CALL    PRS             ; Output "Ok"
0635+  245D 21 FF FF    GETCMD: LD      HL,-1           ; Flag direct mode
0636+  2460 22 2C 41            LD      (LINEAT),HL     ; Save as current line
0637+  2463 CD 57 26            CALL    GETLIN          ; Get an input line
0638+  2466 DA 5D 24            JP      C,GETCMD        ; Get line again if break
0639+  2469 CD 6A 28            CALL    GETCHR          ; Get first character
0640+  246C 3C                  INC     A               ; Test if end of line
0641+  246D 3D                  DEC     A               ; Without affecting Carry
0642+  246E CA 5D 24            JP      Z,GETCMD        ; Nothing entered - Get another
0643+  2471 F5                  PUSH    AF              ; Save Carry status
0644+  2472 CD 37 29            CALL    ATOH            ; Get line number into DE
0645+  2475 D5                  PUSH    DE              ; Save line number
0646+  2476 CD 61 25            CALL    CRUNCH          ; Tokenise rest of line
0647+  2479 47                  LD      B,A             ; Length of tokenised line
0648+  247A D1                  POP     DE              ; Restore line number
0649+  247B F1                  POP     AF              ; Restore Carry
0650+  247C D2 4A 28            JP      NC,EXCUTE       ; No line number - Direct mode
0651+  247F D5                  PUSH    DE              ; Save line number
0652+  2480 C5                  PUSH    BC              ; Save length of tokenised line
0653+  2481 AF                  XOR     A
0654+  2482 32 9C 41            LD      (LSTBIN),A      ; Clear last byte input
0655+  2485 CD 6A 28            CALL    GETCHR          ; Get next character
0656+  2488 B7                  OR      A               ; Set flags
0657+  2489 F5                  PUSH    AF              ; And save them
0658+  248A CD F1 24            CALL    SRCHLN          ; Search for line number in DE
0659+  248D DA 96 24            JP      C,LINFND        ; Jump if line found
0660+  2490 F1                  POP     AF              ; Get status
0661+  2491 F5                  PUSH    AF              ; And re-save
0662+  2492 CA D8 29            JP      Z,ULERR         ; Nothing after number - Error
0663+  2495 B7                  OR      A               ; Clear Carry
0664+  2496 C5          LINFND: PUSH    BC              ; Save address of line in prog
0665+  2497 D2 AD 24            JP      NC,INEWLN       ; Line not found - Insert new
0666+  249A EB                  EX      DE,HL           ; Next line address in DE
0667+  249B 2A A6 41            LD      HL,(PROGND)     ; End of program
0668+  249E 1A          SFTPRG: LD      A,(DE)          ; Shift rest of program down
0669+  249F 02                  LD      (BC),A
0670+  24A0 03                  INC     BC              ; Next destination
0671+  24A1 13                  INC     DE              ; Next source
0672+  24A2 CD DA 26            CALL    CPDEHL          ; All done?
0673+  24A5 C2 9E 24            JP      NZ,SFTPRG       ; More to do
0674+  24A8 60                  LD      H,B             ; HL - New end of program
0675+  24A9 69                  LD      L,C
0676+  24AA 22 A6 41            LD      (PROGND),HL     ; Update end of program
0677+  24AD             
0678+  24AD D1          INEWLN: POP     DE              ; Get address of line,
0679+  24AE F1                  POP     AF              ; Get status
0680+  24AF CA D4 24            JP      Z,SETPTR        ; No text - Set up pointers
0681+  24B2 2A A6 41            LD      HL,(PROGND)     ; Get end of program
0682+  24B5 E3                  EX      (SP),HL         ; Get length of input line
0683+  24B6 C1                  POP     BC              ; End of program to BC
0684+  24B7 09                  ADD     HL,BC           ; Find new end
0685+  24B8 E5                  PUSH    HL              ; Save new end
0686+  24B9 CD CF 23            CALL    MOVUP           ; Make space for line
0687+  24BC E1                  POP     HL              ; Restore new end
0688+  24BD 22 A6 41            LD      (PROGND),HL     ; Update end of program pointer
0689+  24C0 EB                  EX      DE,HL           ; Get line to move up in HL
0690+  24C1 74                  LD      (HL),H          ; Save MSB
0691+  24C2 D1                  POP     DE              ; Get new line number
0692+  24C3 23                  INC     HL              ; Skip pointer
0693+  24C4 23                  INC     HL
0694+  24C5 73                  LD      (HL),E          ; Save LSB of line number
0695+  24C6 23                  INC     HL
0696+  24C7 72                  LD      (HL),D          ; Save MSB of line number
0697+  24C8 23                  INC     HL              ; To first byte in line
0698+  24C9 11 C9 41            LD      DE,BUFFER       ; Copy buffer to program
0699+  24CC 1A          MOVBUF: LD      A,(DE)          ; Get source
0700+  24CD 77                  LD      (HL),A          ; Save destinations
0701+  24CE 23                  INC     HL              ; Next source
0702+  24CF 13                  INC     DE              ; Next destination
0703+  24D0 B7                  OR      A               ; Done?
0704+  24D1 C2 CC 24            JP      NZ,MOVBUF       ; No - Repeat
0705+  24D4 CD 1D 25    SETPTR: CALL    RUNFST          ; Set line pointers
0706+  24D7 23                  INC     HL              ; To LSB of pointer
0707+  24D8 EB                  EX      DE,HL           ; Address to DE
0708+  24D9 62          PTRLP:  LD      H,D             ; Address to HL
0709+  24DA 6B                  LD      L,E
0710+  24DB 7E                  LD      A,(HL)          ; Get LSB of pointer
0711+  24DC 23                  INC     HL              ; To MSB of pointer
0712+  24DD B6                  OR      (HL)            ; Compare with MSB pointer
0713+  24DE CA 5D 24            JP      Z,GETCMD        ; Get command line if end
0714+  24E1 23                  INC     HL              ; To LSB of line number
0715+  24E2 23                  INC     HL              ; Skip line number
0716+  24E3 23                  INC     HL              ; Point to first byte in line
0717+  24E4 AF                  XOR     A               ; Looking for 00 byte
0718+  24E5 BE          FNDEND: CP      (HL)            ; Found end of line?
0719+  24E6 23                  INC     HL              ; Move to next byte
0720+  24E7 C2 E5 24            JP      NZ,FNDEND       ; No - Keep looking
0721+  24EA EB                  EX      DE,HL           ; Next line address to HL
0722+  24EB 73                  LD      (HL),E          ; Save LSB of pointer
0723+  24EC 23                  INC     HL
0724+  24ED 72                  LD      (HL),D          ; Save MSB of pointer
0725+  24EE C3 D9 24            JP      PTRLP           ; Do next line
0726+  24F1             
0727+  24F1 2A 2E 41    SRCHLN: LD      HL,(BASTXT)     ; Start of program text
0728+  24F4 44          SRCHLP: LD      B,H             ; BC = Address to look at
0729+  24F5 4D                  LD      C,L
0730+  24F6 7E                  LD      A,(HL)          ; Get address of next line
0731+  24F7 23                  INC     HL
0732+  24F8 B6                  OR      (HL)            ; End of program found?
0733+  24F9 2B                  DEC     HL
0734+  24FA C8                  RET     Z               ; Yes - Line not found
0735+  24FB 23                  INC     HL
0736+  24FC 23                  INC     HL
0737+  24FD 7E                  LD      A,(HL)          ; Get LSB of line number
0738+  24FE 23                  INC     HL
0739+  24FF 66                  LD      H,(HL)          ; Get MSB of line number
0740+  2500 6F                  LD      L,A
0741+  2501 CD DA 26            CALL    CPDEHL          ; Compare with line in DE
0742+  2504 60                  LD      H,B             ; HL = Start of this line
0743+  2505 69                  LD      L,C
0744+  2506 7E                  LD      A,(HL)          ; Get LSB of next line address
0745+  2507 23                  INC     HL
0746+  2508 66                  LD      H,(HL)          ; Get MSB of next line address
0747+  2509 6F                  LD      L,A             ; Next line to HL
0748+  250A 3F                  CCF
0749+  250B C8                  RET     Z               ; Lines found - Exit
0750+  250C 3F                  CCF
0751+  250D D0                  RET     NC              ; Line not found,at line after
0752+  250E C3 F4 24            JP      SRCHLP          ; Keep looking
0753+  2511             
0754+  2511 C0          NEW:    RET     NZ              ; Return if any more on line
0755+  2512 2A 2E 41    CLRPTR: LD      HL,(BASTXT)     ; Point to start of program
0756+  2515 AF                  XOR     A               ; Set program area to empty
0757+  2516 77                  LD      (HL),A          ; Save LSB = 00
0758+  2517 23                  INC     HL
0759+  2518 77                  LD      (HL),A          ; Save MSB = 00
0760+  2519 23                  INC     HL
0761+  251A 22 A6 41            LD      (PROGND),HL     ; Set program end
0762+  251D             
0763+  251D 2A 2E 41    RUNFST: LD      HL,(BASTXT)     ; Clear all variables
0764+  2520 2B                  DEC     HL
0765+  2521             
0766+  2521 22 9E 41    INTVAR: LD      (BRKLIN),HL     ; Initialise RUN variables
0767+  2524 2A 7F 41            LD      HL,(LSTRAM)     ; Get end of RAM
0768+  2527 22 93 41            LD      (STRBOT),HL     ; Clear string space
0769+  252A AF                  XOR     A
0770+  252B CD 7A 28            CALL    RESTOR          ; Reset DATA pointers
0771+  252E 2A A6 41            LD      HL,(PROGND)     ; Get end of program
0772+  2531 22 A8 41            LD      (VAREND),HL     ; Clear variables
0773+  2534 22 AA 41            LD      (ARREND),HL     ; Clear arrays
0774+  2537             
0775+  2537 C1          CLREG:  POP     BC              ; Save return address
0776+  2538 2A 2A 41            LD      HL,(STRSPC)     ; Get end of working RAN
0777+  253B F9                  LD      SP,HL           ; Set stack
0778+  253C 21 83 41            LD      HL,TMSTPL       ; Temporary string pool
0779+  253F 22 81 41            LD      (TMSTPT),HL     ; Reset temporary string ptr
0780+  2542 AF                  XOR     A               ; A = 00
0781+  2543 6F                  LD      L,A             ; HL = 0000
0782+  2544 67                  LD      H,A
0783+  2545 22 A4 41            LD      (CONTAD),HL     ; No CONTinue
0784+  2548 32 9B 41            LD      (FORFLG),A      ; Clear FOR flag
0785+  254B 22 AE 41            LD      (FNRGNM),HL     ; Clear FN argument
0786+  254E E5                  PUSH    HL              ; HL = 0000
0787+  254F C5                  PUSH    BC              ; Put back return
0788+  2550 2A 9E 41    DOAGN:  LD      HL,(BRKLIN)     ; Get address of code to RUN
0789+  2553 C9                  RET                     ; Return to execution driver
0790+  2554             
0791+  2554 3E 3F       PROMPT: LD      A,'?'           ; '?'
0792+  2556 CD EB 26            CALL    OUTC            ; Output character
0793+  2559 3E 20               LD      A,' '           ; Space
0794+  255B CD EB 26            CALL    OUTC            ; Output character
0795+  255E C3 1E 41            JP      RINPUT          ; Get input line
0796+  2561             
0797+  2561 AF          CRUNCH: XOR     A               ; Tokenise line @ HL to BUFFER
0798+  2562 32 7E 41            LD      (DATFLG),A      ; Reset literal flag
0799+  2565 0E 05               LD      C,2+3           ; 2 byte number and 3 nulls
0800+  2567 11 C9 41            LD      DE,BUFFER       ; Start of input buffer
0801+  256A 7E          CRNCLP: LD      A,(HL)          ; Get byte
0802+  256B FE 20               CP      ' '             ; Is it a space?
0803+  256D CA E9 25            JP      Z,MOVDIR        ; Yes - Copy direct
0804+  2570 47                  LD      B,A             ; Save character
0805+  2571 FE 22               CP      '"'             ; Is it a quote?
0806+  2573 CA 09 26            JP      Z,CPYLIT        ; Yes - Copy literal string
0807+  2576 B7                  OR      A               ; Is it end of buffer?
0808+  2577 CA 10 26            JP      Z,ENDBUF        ; Yes - End buffer
0809+  257A 3A 7E 41            LD      A,(DATFLG)      ; Get data type
0810+  257D B7                  OR      A               ; Literal?
0811+  257E 7E                  LD      A,(HL)          ; Get byte to copy
0812+  257F C2 E9 25            JP      NZ,MOVDIR       ; Literal - Copy direct
0813+  2582 FE 3F               CP      '?'             ; Is it '?' short for PRINT
0814+  2584 3E 9E               LD      A,ZPRINT        ; "PRINT" token
0815+  2586 CA E9 25            JP      Z,MOVDIR        ; Yes - replace it
0816+  2589 7E                  LD      A,(HL)          ; Get byte again
0817+  258A FE 30               CP      '0'             ; Is it less than '0'
0818+  258C DA 94 25            JP      C,FNDWRD        ; Yes - Look for reserved words
0819+  258F FE 3C               CP      60; ";"+1           ; Is it "0123456789:;" ?
0820+  2591 DA E9 25            JP      C,MOVDIR        ; Yes - copy it direct
0821+  2594 D5          FNDWRD: PUSH    DE              ; Look for reserved words
0822+  2595 11 61 21            LD      DE,WORDS-1      ; Point to table
0823+  2598 C5                  PUSH    BC              ; Save count
0824+  2599 01 E5 25            LD      BC,RETNAD       ; Where to return to
0825+  259C C5                  PUSH    BC              ; Save return address
0826+  259D 06 7F               LD      B,ZEND-1        ; First token value -1
0827+  259F 7E                  LD      A,(HL)          ; Get byte
0828+  25A0 FE 61               CP      'a'             ; Less than 'a' ?
0829+  25A2 DA AD 25            JP      C,SEARCH        ; Yes - search for words
0830+  25A5 FE 7B               CP      'z'+1           ; Greater than 'z' ?
0831+  25A7 D2 AD 25            JP      NC,SEARCH       ; Yes - search for words
0832+  25AA E6 5F               AND     01011111B       ; Force upper case
0833+  25AC 77                  LD      (HL),A          ; Replace char with uppercase version
0834+  25AD 4E          SEARCH: LD      C,(HL)          ; Search for a word
0835+  25AE EB                  EX      DE,HL
0836+  25AF 23          GETNXT: INC     HL              ; Get next reserved word
0837+  25B0 B6                  OR      (HL)            ; Start of word?
0838+  25B1 F2 AF 25            JP      P,GETNXT        ; No - move on
0839+  25B4 04                  INC     B               ; Increment token value
0840+  25B5 7E                  LD      A, (HL)         ; Get byte from table
0841+  25B6 E6 7F               AND     01111111B       ; Strip bit 7
0842+  25B8 C8                  RET     Z               ; Return if end of list
0843+  25B9 B9                  CP      C               ; Same character as in buffer?
0844+  25BA C2 AF 25            JP      NZ,GETNXT       ; No - get next word
0845+  25BD EB                  EX      DE,HL
0846+  25BE E5                  PUSH    HL              ; Save start of word
0847+  25BF             
0848+  25BF 13          NXTBYT: INC     DE              ; Look through rest of word
0849+  25C0 1A                  LD      A,(DE)          ; Get byte from table
0850+  25C1 B7                  OR      A               ; End of word ?
0851+  25C2 FA E1 25            JP      M,MATCH         ; Yes - Match found
0852+  25C5 4F                  LD      C,A             ; Save it
0853+  25C6 78                  LD      A,B             ; Get token value
0854+  25C7 FE 88               CP      ZGOTO           ; Is it "GOTO" token ?
0855+  25C9 C2 D0 25            JP      NZ,NOSPC        ; No - Don't allow spaces
0856+  25CC CD 6A 28            CALL    GETCHR          ; Get next character
0857+  25CF 2B                  DEC     HL              ; Cancel increment from GETCHR
0858+  25D0 23          NOSPC:  INC     HL              ; Next byte
0859+  25D1 7E                  LD      A,(HL)          ; Get byte
0860+  25D2 FE 61               CP      'a'             ; Less than 'a' ?
0861+  25D4 DA D9 25            JP      C,NOCHNG        ; Yes - don't change
0862+  25D7 E6 5F               AND     01011111B       ; Make upper case
0863+  25D9 B9          NOCHNG: CP      C               ; Same as in buffer ?
0864+  25DA CA BF 25            JP      Z,NXTBYT        ; Yes - keep testing
0865+  25DD E1                  POP     HL              ; Get back start of word
0866+  25DE C3 AD 25            JP      SEARCH          ; Look at next word
0867+  25E1             
0868+  25E1 48          MATCH:  LD      C,B             ; Word found - Save token value
0869+  25E2 F1                  POP     AF              ; Throw away return
0870+  25E3 EB                  EX      DE,HL
0871+  25E4 C9                  RET                     ; Return to "RETNAD"
0872+  25E5 EB          RETNAD: EX      DE,HL           ; Get address in string
0873+  25E6 79                  LD      A,C             ; Get token value
0874+  25E7 C1                  POP     BC              ; Restore buffer length
0875+  25E8 D1                  POP     DE              ; Get destination address
0876+  25E9 23          MOVDIR: INC     HL              ; Next source in buffer
0877+  25EA 12                  LD      (DE),A          ; Put byte in buffer
0878+  25EB 13                  INC     DE              ; Move up buffer
0879+  25EC 0C                  INC     C               ; Increment length of buffer
0880+  25ED D6 3A               SUB     ':'             ; End of statement?
0881+  25EF CA F7 25            JP      Z,SETLIT        ; Jump if multi-statement line
0882+  25F2 FE 49               CP      ZDATA-3AH       ; Is it DATA statement ?
0883+  25F4 C2 FA 25            JP      NZ,TSTREM       ; No - see if REM
0884+  25F7 32 7E 41    SETLIT: LD      (DATFLG),A      ; Set literal flag
0885+  25FA D6 54       TSTREM: SUB     ZREM-3AH        ; Is it REM?
0886+  25FC C2 6A 25            JP      NZ,CRNCLP       ; No - Leave flag
0887+  25FF 47                  LD      B,A             ; Copy rest of buffer
0888+  2600 7E          NXTCHR: LD      A,(HL)          ; Get byte
0889+  2601 B7                  OR      A               ; End of line ?
0890+  2602 CA 10 26            JP      Z,ENDBUF        ; Yes - Terminate buffer
0891+  2605 B8                  CP      B               ; End of statement ?
0892+  2606 CA E9 25            JP      Z,MOVDIR        ; Yes - Get next one
0893+  2609 23          CPYLIT: INC     HL              ; Move up source string
0894+  260A 12                  LD      (DE),A          ; Save in destination
0895+  260B 0C                  INC     C               ; Increment length
0896+  260C 13                  INC     DE              ; Move up destination
0897+  260D C3 00 26            JP      NXTCHR          ; Repeat
0898+  2610             
0899+  2610 21 C8 41    ENDBUF: LD      HL,BUFFER-1     ; Point to start of buffer
0900+  2613 12                  LD      (DE),A          ; Mark end of buffer (A = 00)
0901+  2614 13                  INC     DE
0902+  2615 12                  LD      (DE),A          ; A = 00
0903+  2616 13                  INC     DE
0904+  2617 12                  LD      (DE),A          ; A = 00
0905+  2618 C9                  RET
0906+  2619             
0907+  2619 3A 14 41    DODEL:  LD      A,(NULFLG)      ; Get null flag status
0908+  261C B7                  OR      A               ; Is it zero?
0909+  261D 3E 00               LD      A,0             ; Zero A - Leave flags
0910+  261F 32 14 41            LD      (NULFLG),A      ; Zero null flag
0911+  2622 C2 2F 26            JP      NZ,ECHDEL       ; Set - Echo it
0912+  2625 05                  DEC     B               ; Decrement length
0913+  2626 CA 57 26            JP      Z,GETLIN        ; Get line again if empty
0914+  2629 CD EB 26            CALL    OUTC            ; Output null character
0915+  262C                     ;.BYTE   3EH              Skip "DEC B"
0916+  262C C3 30 26    		JP		ECHJP
0917+  262F 05          ECHDEL: DEC     B               ; Count bytes in buffer
0918+  2630 2B          ECHJP:  DEC     HL              ; Back space buffer
0919+  2631 CA 4E 26            JP      Z,OTKLN         ; No buffer - Try again
0920+  2634                     ;LD      A,(HL)           Get deleted byte
0921+  2634             		;CALL	 OUTC			  Echo it
0922+  2634 3E 08       		LD      A,8          	; Set delete char
0923+  2636 CD EB 26    		CALL    OUTC            ; Echo it
0924+  2639 3E 20       		LD		A,' '			; Rubout
0925+  263B CD EB 26    		CALL    OUTC            ; Echo it
0926+  263E 3E 08       		LD		A,8				; Backspace
0927+  2640 CD EB 26            CALL    OUTC            ; Echo it
0928+  2643 C3 60 26            JP      MORINP          ; Get more input
0929+  2646             
0930+  2646 05          DELCHR: DEC     B               ; Count bytes in buffer
0931+  2647 2B                  DEC     HL              ; Back space buffer
0932+  2648 CD EB 26            CALL    OUTC            ; Output character in A
0933+  264B C2 60 26            JP      NZ,MORINP       ; Not end - Get more
0934+  264E CD EB 26    OTKLN:  CALL    OUTC            ; Output character in A
0935+  2651 CD 13 2B    KILIN:  CALL    PRNTCRLF        ; Output CRLF
0936+  2654 C3 57 26            JP      TTYLIN          ; Get line again
0937+  2657             
0938+  2657             GETLIN:
0939+  2657 21 C9 41    TTYLIN: LD      HL,BUFFER       ; Get a line by character
0940+  265A 06 01               LD      B,1             ; Set buffer as empty
0941+  265C AF                  XOR     A
0942+  265D 32 14 41            LD      (NULFLG),A      ; Clear null flag
0943+  2660 CD 15 27    MORINP: CALL    CLOTST          ; Get character and test ^O
0944+  2663 4F                  LD      C,A             ; Save character in C
0945+  2664 FE 7F               CP      DEL             ; Delete character?
0946+  2666 CA 19 26            JP      Z,DODEL         ; Yes - Process it
0947+  2669 3A 14 41            LD      A,(NULFLG)      ; Get null flag
0948+  266C B7                  OR      A               ; Test null flag status
0949+  266D CA 79 26            JP      Z,PROCES        ; Reset - Process character
0950+  2670 3E 00               LD      A,0             ; Set a null
0951+  2672 CD EB 26            CALL    OUTC            ; Output null
0952+  2675 AF                  XOR     A               ; Clear A
0953+  2676 32 14 41            LD      (NULFLG),A      ; Reset null flag
0954+  2679 79          PROCES: LD      A,C             ; Get character
0955+  267A FE 07               CP      CTRLG           ; Bell?
0956+  267C CA BD 26            JP      Z,PUTCTL        ; Yes - Save it
0957+  267F FE 03               CP      CTRLC           ; Is it control "C"?
0958+  2681 CC 13 2B            CALL    Z,PRNTCRLF      ; Yes - Output CRLF
0959+  2684 37                  SCF                     ; Flag break
0960+  2685 C8                  RET     Z               ; Return if control "C"
0961+  2686 FE 0D               CP      CR              ; Is it enter?
0962+  2688 CA 0E 2B            JP      Z,ENDINP        ; Yes - Terminate input
0963+  268B FE 15               CP      CTRLU           ; Is it control "U"?
0964+  268D CA 51 26            JP      Z,KILIN         ; Yes - Get another line
0965+  2690 FE 40               CP      '@'             ; Is it "kill line"?
0966+  2692 CA 4E 26            JP      Z,OTKLN         ; Yes - Kill line
0967+  2695 FE 5F               CP      '_'             ; Is it delete?
0968+  2697 CA 46 26            JP      Z,DELCHR        ; Yes - Delete character
0969+  269A FE 08               CP      BKSP            ; Is it backspace?
0970+  269C CA 46 26            JP      Z,DELCHR        ; Yes - Delete character
0971+  269F FE 12               CP      CTRLR           ; Is it control "R"?
0972+  26A1 C2 B8 26            JP      NZ,PUTBUF       ; No - Put in buffer
0973+  26A4 C5                  PUSH    BC              ; Save buffer length
0974+  26A5 D5                  PUSH    DE              ; Save DE
0975+  26A6 E5                  PUSH    HL              ; Save buffer address
0976+  26A7 36 00               LD      (HL),0          ; Mark end of buffer
0977+  26A9 CD E7 3C            CALL    OUTNCR          ; Output and do CRLF
0978+  26AC 21 C9 41            LD      HL,BUFFER       ; Point to buffer start
0979+  26AF CD B1 31            CALL    PRS             ; Output buffer
0980+  26B2 E1                  POP     HL              ; Restore buffer address
0981+  26B3 D1                  POP     DE              ; Restore DE
0982+  26B4 C1                  POP     BC              ; Restore buffer length
0983+  26B5 C3 60 26            JP      MORINP          ; Get another character
0984+  26B8             
0985+  26B8 FE 20       PUTBUF: CP      ' '             ; Is it a control code?
0986+  26BA DA 60 26            JP      C,MORINP        ; Yes - Ignore
0987+  26BD 78          PUTCTL: LD      A,B             ; Get number of bytes in buffer
0988+  26BE FE 8B               CP      LINELEN+1    ; Test for line overflow
0989+  26C0 3E 07               LD      A,CTRLG         ; Set a bell
0990+  26C2 D2 D2 26            JP      NC,OUTNBS       ; Ring bell if buffer full
0991+  26C5 79                  LD      A,C             ; Get character
0992+  26C6 71                  LD      (HL),C          ; Save in buffer
0993+  26C7 32 9C 41            LD      (LSTBIN),A      ; Save last input byte
0994+  26CA 23                  INC     HL              ; Move up buffer
0995+  26CB 04                  INC     B               ; Increment length
0996+  26CC CD EB 26    OUTIT:  CALL    OUTC            ; Output the character entered
0997+  26CF C3 60 26            JP      MORINP          ; Get another character
0998+  26D2             
0999+  26D2 CD EB 26    OUTNBS: CALL    OUTC            ; Output bell and back over it
1000+  26D5 3E 08               LD      A,BKSP          ; Set back space
1001+  26D7 C3 CC 26            JP      OUTIT           ; Output it and get more
1002+  26DA             
1003+  26DA 7C          CPDEHL: LD      A,H             ; Get H
1004+  26DB 92                  SUB     D               ; Compare with D
1005+  26DC C0                  RET     NZ              ; Different - Exit
1006+  26DD 7D                  LD      A,L             ; Get L
1007+  26DE 93                  SUB     E               ; Compare with E
1008+  26DF C9                  RET                     ; Return status
1009+  26E0             
1010+  26E0 7E          CHKSYN: LD      A,(HL)          ; Check syntax of character
1011+  26E1 E3                  EX      (SP),HL         ; Address of test byte
1012+  26E2 BE                  CP      (HL)            ; Same as in code string?
1013+  26E3 23                  INC     HL              ; Return address
1014+  26E4 E3                  EX      (SP),HL         ; Put it back
1015+  26E5 CA 6A 28            JP      Z,GETCHR        ; Yes - Get next character
1016+  26E8 C3 03 24            JP      SNERR           ; Different - ?SN Error
1017+  26EB             
1018+  26EB F5          OUTC:   PUSH    AF              ; Save character
1019+  26EC 3A 15 41            LD      A,(CTLOFG)      ; Get control "O" flag
1020+  26EF B7                  OR      A               ; Is it set?
1021+  26F0 C2 E6 31            JP      NZ,POPAF        ; Yes - don't output
1022+  26F3 F1                  POP     AF              ; Restore character
1023+  26F4 C5                  PUSH    BC              ; Save buffer length
1024+  26F5 F5                  PUSH    AF              ; Save character
1025+  26F6 FE 20               CP      ' '             ; Is it a control code?
1026+  26F8 DA 0F 27            JP      C,DINPOS        ; Yes - Don't INC POS(X)
1027+  26FB 3A 12 41            LD      A,(LWIDTH)      ; Get line width
1028+  26FE 47                  LD      B,A             ; To B
1029+  26FF 3A 7B 41            LD      A,(CURPOS)      ; Get cursor position
1030+  2702 04                  INC     B               ; Width 255?
1031+  2703 CA 0B 27            JP      Z,INCLEN        ; Yes - No width limit
1032+  2706 05                  DEC     B               ; Restore width
1033+  2707 B8                  CP      B               ; At end of line?
1034+  2708 CC 13 2B            CALL    Z,PRNTCRLF      ; Yes - output CRLF
1035+  270B 3C          INCLEN: INC     A               ; Move on one character
1036+  270C 32 7B 41            LD      (CURPOS),A      ; Save new position
1037+  270F F1          DINPOS: POP     AF              ; Restore character
1038+  2710 C1                  POP     BC              ; Restore buffer length
1039+  2711 CD D0 3C            CALL    MONOUT          ; Send it
1040+  2714 C9                  RET
1041+  2715             
1042+  2715 CD 94 3B    CLOTST: CALL    GETINP          ; Get input character
1043+  2718 E6 7F               AND     01111111B       ; Strip bit 7
1044+  271A FE 0F               CP      CTRLO           ; Is it control "O"?
1045+  271C C0                  RET     NZ              ; No don't flip flag
1046+  271D 3A 15 41            LD      A,(CTLOFG)      ; Get flag
1047+  2720 2F                  CPL                     ; Flip it
1048+  2721 32 15 41            LD      (CTLOFG),A      ; Put it back
1049+  2724 AF                  XOR     A               ; Null character
1050+  2725 C9                  RET
1051+  2726             
1052+  2726 CD 37 29    LIST:   CALL    ATOH            ; ASCII number to DE
1053+  2729 C0                  RET     NZ              ; Return if anything extra
1054+  272A C1                  POP     BC              ; Rubbish - Not needed
1055+  272B CD F1 24            CALL    SRCHLN          ; Search for line number in DE
1056+  272E C5                  PUSH    BC              ; Save address of line
1057+  272F CD 7C 27            CALL    SETLIN          ; Set up lines counter
1058+  2732 E1          LISTLP: POP     HL              ; Restore address of line
1059+  2733 4E                  LD      C,(HL)          ; Get LSB of next line
1060+  2734 23                  INC     HL
1061+  2735 46                  LD      B,(HL)          ; Get MSB of next line
1062+  2736 23                  INC     HL
1063+  2737 78                  LD      A,B             ; BC = 0 (End of program)?
1064+  2738 B1                  OR      C
1065+  2739 CA 50 24            JP      Z,PRNTOK        ; Yes - Go to command mode
1066+  273C CD 85 27            CALL    COUNT           ; Count lines
1067+  273F CD 95 28            CALL    TSTBRK          ; Test for break key
1068+  2742 C5                  PUSH    BC              ; Save address of next line
1069+  2743 CD 13 2B            CALL    PRNTCRLF        ; Output CRLF
1070+  2746 5E                  LD      E,(HL)          ; Get LSB of line number
1071+  2747 23                  INC     HL
1072+  2748 56                  LD      D,(HL)          ; Get MSB of line number
1073+  2749 23                  INC     HL
1074+  274A E5                  PUSH    HL              ; Save address of line start
1075+  274B EB                  EX      DE,HL           ; Line number to HL
1076+  274C CD 78 38            CALL    PRNTHL          ; Output line number in decimal
1077+  274F 3E 20               LD      A,' '           ; Space after line number
1078+  2751 E1                  POP     HL              ; Restore start of line address
1079+  2752 CD EB 26    LSTLP2: CALL    OUTC            ; Output character in A
1080+  2755 7E          LSTLP3: LD      A,(HL)          ; Get next byte in line
1081+  2756 B7                  OR      A               ; End of line?
1082+  2757 23                  INC     HL              ; To next byte in line
1083+  2758 CA 32 27            JP      Z,LISTLP        ; Yes - get next line
1084+  275B F2 52 27            JP      P,LSTLP2        ; No token - output it
1085+  275E D6 7F               SUB     ZEND-1          ; Find and output word
1086+  2760 4F                  LD      C,A             ; Token offset+1 to C
1087+  2761 11 62 21            LD      DE,WORDS        ; Reserved word list
1088+  2764 1A          FNDTOK: LD      A,(DE)          ; Get character in list
1089+  2765 13                  INC     DE              ; Move on to next
1090+  2766 B7                  OR      A               ; Is it start of word?
1091+  2767 F2 64 27            JP      P,FNDTOK        ; No - Keep looking for word
1092+  276A 0D                  DEC     C               ; Count words
1093+  276B C2 64 27            JP      NZ,FNDTOK       ; Not there - keep looking
1094+  276E E6 7F       OUTWRD: AND     01111111B       ; Strip bit 7
1095+  2770 CD EB 26            CALL    OUTC            ; Output first character
1096+  2773 1A                  LD      A,(DE)          ; Get next character
1097+  2774 13                  INC     DE              ; Move on to next
1098+  2775 B7                  OR      A               ; Is it end of word?
1099+  2776 F2 6E 27            JP      P,OUTWRD        ; No - output the rest
1100+  2779 C3 55 27            JP      LSTLP3          ; Next byte in line
1101+  277C             
1102+  277C E5          SETLIN: PUSH    HL              ; Set up LINES counter
1103+  277D 2A 18 41            LD      HL,(LINESN)     ; Get LINES number
1104+  2780 22 16 41            LD      (LINESC),HL     ; Save in LINES counter
1105+  2783 E1                  POP     HL
1106+  2784 C9                  RET
1107+  2785             
1108+  2785 E5          COUNT:  PUSH    HL              ; Save code string address
1109+  2786 D5                  PUSH    DE
1110+  2787 2A 16 41            LD      HL,(LINESC)     ; Get LINES counter
1111+  278A 11 FF FF            LD      DE,-1
1112+  278D ED 5A               ADC     HL,DE           ; Decrement
1113+  278F 22 16 41            LD      (LINESC),HL     ; Put it back
1114+  2792 D1                  POP     DE
1115+  2793 E1                  POP     HL              ; Restore code string address
1116+  2794 F0                  RET     P               ; Return if more lines to go
1117+  2795 E5                  PUSH    HL              ; Save code string address
1118+  2796 2A 18 41            LD      HL,(LINESN)     ; Get LINES number
1119+  2799 22 16 41            LD      (LINESC),HL     ; Reset LINES counter
1120+  279C CD 94 3B            CALL    GETINP          ; Get input character
1121+  279F FE 03               CP      CTRLC           ; Is it control "C"?
1122+  27A1 CA A8 27            JP      Z,RSLNBK        ; Yes - Reset LINES and break
1123+  27A4 E1                  POP     HL              ; Restore code string address
1124+  27A5 C3 85 27            JP      COUNT           ; Keep on counting
1125+  27A8             
1126+  27A8 2A 18 41    RSLNBK: LD      HL,(LINESN)     ; Get LINES number
1127+  27AB 22 16 41            LD      (LINESC),HL     ; Reset LINES counter
1128+  27AE C3 A7 20            JP      BRKRET          ; Go and output "Break"
1129+  27B1             
1130+  27B1 3E 64       FOR:    LD      A,64H           ; Flag "FOR" assignment
1131+  27B3 32 9B 41            LD      (FORFLG),A      ; Save "FOR" flag
1132+  27B6 CD 19 2A            CALL    LET             ; Set up initial index
1133+  27B9 C1                  POP     BC              ; Drop RETurn address
1134+  27BA E5                  PUSH    HL              ; Save code string address
1135+  27BB CD 02 2A            CALL    DATA            ; Get next statement address
1136+  27BE 22 97 41            LD      (LOOPST),HL     ; Save it for start of loop
1137+  27C1 21 02 00            LD      HL,2            ; Offset for "FOR" block
1138+  27C4 39                  ADD     HL,SP           ; Point to it
1139+  27C5 CD B0 23    FORSLP: CALL    LOKFOR          ; Look for existing "FOR" block
1140+  27C8 D1                  POP     DE              ; Get code string address
1141+  27C9 C2 E1 27            JP      NZ,FORFND       ; No nesting found
1142+  27CC 09                  ADD     HL,BC           ; Move into "FOR" block
1143+  27CD D5                  PUSH    DE              ; Save code string address
1144+  27CE 2B                  DEC     HL
1145+  27CF 56                  LD      D,(HL)          ; Get MSB of loop statement
1146+  27D0 2B                  DEC     HL
1147+  27D1 5E                  LD      E,(HL)          ; Get LSB of loop statement
1148+  27D2 23                  INC     HL
1149+  27D3 23                  INC     HL
1150+  27D4 E5                  PUSH    HL              ; Save block address
1151+  27D5 2A 97 41            LD      HL,(LOOPST)     ; Get address of loop statement
1152+  27D8 CD DA 26            CALL    CPDEHL          ; Compare the FOR loops
1153+  27DB E1                  POP     HL              ; Restore block address
1154+  27DC C2 C5 27            JP      NZ,FORSLP       ; Different FORs - Find another
1155+  27DF D1                  POP     DE              ; Restore code string address
1156+  27E0 F9                  LD      SP,HL           ; Remove all nested loops
1157+  27E1             
1158+  27E1 EB          FORFND: EX      DE,HL           ; Code string address to HL
1159+  27E2 0E 08               LD      C,8
1160+  27E4 CD E0 23            CALL    CHKSTK          ; Check for 8 levels of stack
1161+  27E7 E5                  PUSH    HL              ; Save code string address
1162+  27E8 2A 97 41            LD      HL,(LOOPST)     ; Get first statement of loop
1163+  27EB E3                  EX      (SP),HL         ; Save and restore code string
1164+  27EC E5                  PUSH    HL              ; Re-save code string address
1165+  27ED 2A 2C 41            LD      HL,(LINEAT)     ; Get current line number
1166+  27F0 E3                  EX      (SP),HL         ; Save and restore code string
1167+  27F1 CD DB 2C            CALL    TSTNUM          ; Make sure it's a number
1168+  27F4 CD E0 26            CALL    CHKSYN          ; Make sure "TO" is next
1169+  27F7 A6                  .BYTE   ZTO          ; "TO" token
1170+  27F8 CD D8 2C            CALL    GETNUM          ; Get "TO" expression value
1171+  27FB E5                  PUSH    HL              ; Save code string address
1172+  27FC CD 2A 37            CALL    BCDEFP          ; Move "TO" value to BCDE
1173+  27FF E1                  POP     HL              ; Restore code string address
1174+  2800 C5                  PUSH    BC              ; Save "TO" value in block
1175+  2801 D5                  PUSH    DE
1176+  2802 01 00 81            LD      BC,8100H        ; BCDE - 1 (default STEP)
1177+  2805 51                  LD      D,C             ; C=0
1178+  2806 5A                  LD      E,D             ; D=0
1179+  2807 7E                  LD      A,(HL)          ; Get next byte in code string
1180+  2808 FE AB               CP      ZSTEP           ; See if "STEP" is stated
1181+  280A 3E 01               LD      A,1             ; Sign of step = 1
1182+  280C C2 1D 28            JP      NZ,SAVSTP       ; No STEP given - Default to 1
1183+  280F CD 6A 28            CALL    GETCHR          ; Jump over "STEP" token
1184+  2812 CD D8 2C            CALL    GETNUM          ; Get step value
1185+  2815 E5                  PUSH    HL              ; Save code string address
1186+  2816 CD 2A 37            CALL    BCDEFP          ; Move STEP to BCDE
1187+  2819 CD DE 36            CALL    TSTSGN          ; Test sign of FPREG
1188+  281C E1                  POP     HL              ; Restore code string address
1189+  281D C5          SAVSTP: PUSH    BC              ; Save the STEP value in block
1190+  281E D5                  PUSH    DE
1191+  281F F5                  PUSH    AF              ; Save sign of STEP
1192+  2820 33                  INC     SP              ; Don't save flags
1193+  2821 E5                  PUSH    HL              ; Save code string address
1194+  2822 2A 9E 41            LD      HL,(BRKLIN)     ; Get address of index variable
1195+  2825 E3                  EX      (SP),HL         ; Save and restore code string
1196+  2826 06 81       PUTFID: LD      B,ZFOR          ; "FOR" block marker
1197+  2828 C5                  PUSH    BC              ; Save it
1198+  2829 33                  INC     SP              ; Don't save C
1199+  282A             
1200+  282A CD 95 28    RUNCNT: CALL    TSTBRK          ; Execution driver - Test break
1201+  282D 22 9E 41            LD      (BRKLIN),HL     ; Save code address for break
1202+  2830 7E                  LD      A,(HL)          ; Get next byte in code string
1203+  2831 FE 3A               CP      ':'             ; Multi statement line?
1204+  2833 CA 4A 28            JP      Z,EXCUTE        ; Yes - Execute it
1205+  2836 B7                  OR      A               ; End of line?
1206+  2837 C2 03 24            JP      NZ,SNERR        ; No - Syntax error
1207+  283A 23                  INC     HL              ; Point to address of next line
1208+  283B 7E                  LD      A,(HL)          ; Get LSB of line pointer
1209+  283C 23                  INC     HL
1210+  283D B6                  OR      (HL)            ; Is it zero (End of prog)?
1211+  283E CA BC 28            JP      Z,ENDPRG        ; Yes - Terminate execution
1212+  2841 23                  INC     HL              ; Point to line number
1213+  2842 5E                  LD      E,(HL)          ; Get LSB of line number
1214+  2843 23                  INC     HL
1215+  2844 56                  LD      D,(HL)          ; Get MSB of line number
1216+  2845 EB                  EX      DE,HL           ; Line number to HL
1217+  2846 22 2C 41            LD      (LINEAT),HL     ; Save as current line number
1218+  2849 EB                  EX      DE,HL           ; Line number back to DE
1219+  284A CD 6A 28    EXCUTE: CALL    GETCHR          ; Get key word
1220+  284D 11 2A 28            LD      DE,RUNCNT       ; Where to RETurn to
1221+  2850 D5                  PUSH    DE              ; Save for RETurn
1222+  2851 C8          IFJMP:  RET     Z               ; Go to RUNCNT if end of STMT
1223+  2852 D6 80       ONJMP:  SUB     ZEND            ; Is it a token?
1224+  2854 DA 19 2A            JP      C,LET           ; No - try to assign it
1225+  2857 FE 25               CP      ZNEW+1-ZEND     ; END to NEW ?
1226+  2859 D2 03 24            JP      NC,SNERR        ; Not a key word - ?SN Error
1227+  285C 07                  RLCA                    ; Double it
1228+  285D 4F                  LD      C,A             ; BC = Offset into table
1229+  285E 06 00               LD      B,0
1230+  2860 EB                  EX      DE,HL           ; Save code string address
1231+  2861 21 81 22            LD      HL,WORDTB       ; Keyword address table
1232+  2864 09                  ADD     HL,BC           ; Point to routine address
1233+  2865 4E                  LD      C,(HL)          ; Get LSB of routine address
1234+  2866 23                  INC     HL
1235+  2867 46                  LD      B,(HL)          ; Get MSB of routine address
1236+  2868 C5                  PUSH    BC              ; Save routine address
1237+  2869 EB                  EX      DE,HL           ; Restore code string address
1238+  286A             
1239+  286A 23          GETCHR: INC     HL              ; Point to next character
1240+  286B 7E                  LD      A,(HL)          ; Get next code string byte
1241+  286C FE 3A               CP      ':'             ; Z if ':'
1242+  286E D0                  RET     NC              ; NC if > "9"
1243+  286F FE 20               CP      ' '
1244+  2871 CA 6A 28            JP      Z,GETCHR        ; Skip over spaces
1245+  2874 FE 30               CP      '0'
1246+  2876 3F                  CCF                     ; NC if < '0'
1247+  2877 3C                  INC     A               ; Test for zero - Leave carry
1248+  2878 3D                  DEC     A               ; Z if Null
1249+  2879 C9                  RET
1250+  287A             
1251+  287A EB          RESTOR: EX      DE,HL           ; Save code string address
1252+  287B 2A 2E 41            LD      HL,(BASTXT)     ; Point to start of program
1253+  287E CA 8F 28            JP      Z,RESTNL        ; Just RESTORE - reset pointer
1254+  2881 EB                  EX      DE,HL           ; Restore code string address
1255+  2882 CD 37 29            CALL    ATOH            ; Get line number to DE
1256+  2885 E5                  PUSH    HL              ; Save code string address
1257+  2886 CD F1 24            CALL    SRCHLN          ; Search for line number in DE
1258+  2889 60                  LD      H,B             ; HL = Address of line
1259+  288A 69                  LD      L,C
1260+  288B D1                  POP     DE              ; Restore code string address
1261+  288C D2 D8 29            JP      NC,ULERR        ; ?UL Error if not found
1262+  288F 2B          RESTNL: DEC     HL              ; Byte before DATA statement
1263+  2890 22 AC 41    UPDATA: LD      (NXTDAT),HL     ; Update DATA pointer
1264+  2893 EB                  EX      DE,HL           ; Restore code string address
1265+  2894 C9                  RET
1266+  2895             
1267+  2895             
1268+  2895 DF          TSTBRK: RST     18H             ; Check input status
1269+  2896 C8                  RET     Z               ; No key, go back
1270+  2897 D7                  RST     10H             ; Get the key into A
1271+  2898 FE 1B               CP      ESC             ; Escape key?
1272+  289A 28 11               JR      Z,BRK           ; Yes, break
1273+  289C FE 03               CP      CTRLC           ; <Ctrl-C>
1274+  289E 28 0D               JR      Z,BRK           ; Yes, break
1275+  28A0 FE 13               CP      CTRLS           ; Stop scrolling?
1276+  28A2 C0                  RET     NZ              ; Other key, ignore
1277+  28A3             
1278+  28A3             
1279+  28A3 D7          STALL:  RST     10H             ; Wait for key
1280+  28A4 FE 11               CP      CTRLQ           ; Resume scrolling?
1281+  28A6 C8                  RET      Z              ; Release the chokehold
1282+  28A7 FE 03               CP      CTRLC           ; Second break?
1283+  28A9 28 07               JR      Z,STOP          ; Break during hold exits prog
1284+  28AB 18 F6               JR      STALL           ; Loop until <Ctrl-Q> or <brk>
1285+  28AD             
1286+  28AD 3E FF       BRK     LD      A,$FF           ; Set BRKFLG
1287+  28AF 32 1D 41            LD      (BRKFLG),A      ; Store it
1288+  28B2             
1289+  28B2             
1290+  28B2 C0          STOP:   RET     NZ              ; Exit if anything else
1291+  28B3 F6                  .BYTE   0F6H            ; Flag "STOP"
1292+  28B4 C0          PEND:   RET     NZ              ; Exit if anything else
1293+  28B5 22 9E 41            LD      (BRKLIN),HL     ; Save point of break
1294+  28B8 21                  .BYTE   21H             ; Skip "OR 11111111B"
1295+  28B9 F6 FF       INPBRK: OR      11111111B       ; Flag "Break" wanted
1296+  28BB C1                  POP     BC              ; Return not needed and more
1297+  28BC 2A 2C 41    ENDPRG: LD      HL,(LINEAT)     ; Get current line number
1298+  28BF F5                  PUSH    AF              ; Save STOP / END status
1299+  28C0 7D                  LD      A,L             ; Is it direct break?
1300+  28C1 A4                  AND     H
1301+  28C2 3C                  INC     A               ; Line is -1 if direct break
1302+  28C3 CA CF 28            JP      Z,NOLIN         ; Yes - No line number
1303+  28C6 22 A2 41            LD      (ERRLIN),HL     ; Save line of break
1304+  28C9 2A 9E 41            LD      HL,(BRKLIN)     ; Get point of break
1305+  28CC 22 A4 41            LD      (CONTAD),HL     ; Save point to CONTinue
1306+  28CF AF          NOLIN:  XOR     A
1307+  28D0 32 15 41            LD      (CTLOFG),A      ; Enable output
1308+  28D3 CD 06 2B            CALL    STTLIN          ; Start a new line
1309+  28D6 F1                  POP     AF              ; Restore STOP / END status
1310+  28D7 21 A6 23            LD      HL,BRKMSG       ; "Break" message
1311+  28DA C2 39 24            JP      NZ,ERRIN        ; "in line" wanted?
1312+  28DD C3 50 24            JP      PRNTOK          ; Go to command mode
1313+  28E0             
1314+  28E0 2A A4 41    CONT:   LD      HL,(CONTAD)     ; Get CONTinue address
1315+  28E3 7C                  LD      A,H             ; Is it zero?
1316+  28E4 B5                  OR      L
1317+  28E5 11 42 00            LD      DE,CN            ; ?CN Error
1318+  28E8 CA 1E 24            JP      Z,ERROR         ; Yes - output "?CN Error"
1319+  28EB EB                  EX      DE,HL           ; Save code string address
1320+  28EC 2A A2 41            LD      HL,(ERRLIN)     ; Get line of last break
1321+  28EF 22 2C 41            LD      (LINEAT),HL     ; Set up current line number
1322+  28F2 EB                  EX      DE,HL           ; Restore code string address
1323+  28F3 C9                  RET                     ; CONTinue where left off
1324+  28F4             
1325+  28F4 CD 39 34    NULL:   CALL    GETINT          ; Get integer 0-255
1326+  28F7 C0                  RET     NZ              ; Return if bad value
1327+  28F8 32 11 41            LD      (NULLS),A       ; Set nulls number
1328+  28FB C9                  RET
1329+  28FC             
1330+  28FC             
1331+  28FC E5          ACCSUM: PUSH    HL              ; Save address in array
1332+  28FD 2A 1A 41            LD      HL,(CHKSUM)     ; Get check sum
1333+  2900 06 00               LD      B,0             ; BC - Value of byte
1334+  2902 4F                  LD      C,A
1335+  2903 09                  ADD     HL,BC           ; Add byte to check sum
1336+  2904 22 1A 41            LD      (CHKSUM),HL     ; Re-save check sum
1337+  2907 E1                  POP     HL              ; Restore address in array
1338+  2908 C9                  RET
1339+  2909             
1340+  2909 7E          CHKLTR: LD      A,(HL)          ; Get byte
1341+  290A FE 41               CP      'A'             ; < 'a' ?
1342+  290C D8                  RET     C               ; Carry set if not letter
1343+  290D FE 5B               CP      'Z'+1           ; > 'z' ?
1344+  290F 3F                  CCF
1345+  2910 C9                  RET                     ; Carry set if not letter
1346+  2911             
1347+  2911 CD 6A 28    FPSINT: CALL    GETCHR          ; Get next character
1348+  2914 CD D8 2C    POSINT: CALL    GETNUM          ; Get integer 0 to 32767
1349+  2917 CD DE 36    DEPINT: CALL    TSTSGN          ; Test sign of FPREG
1350+  291A FA 32 29            JP      M,FCERR         ; Negative - ?FC Error
1351+  291D 3A B7 41    DEINT:  LD      A,(FPEXP)       ; Get integer value to DE
1352+  2920 FE 90               CP      80H+16          ; Exponent in range (16 bits)?
1353+  2922 DA 86 37            JP      C,FPINT         ; Yes - convert it
1354+  2925 01 80 90            LD      BC,9080H        ; BCDE = -32768
1355+  2928 11 00 00            LD      DE,0000
1356+  292B E5                  PUSH    HL              ; Save code string address
1357+  292C CD 59 37            CALL    CMPNUM          ; Compare FPREG with BCDE
1358+  292F E1                  POP     HL              ; Restore code string address
1359+  2930 51                  LD      D,C             ; MSB to D
1360+  2931 C8                  RET     Z               ; Return if in range
1361+  2932 1E 1E       FCERR:  LD      E,FC            ; ?FC Error
1362+  2934 C3 1E 24            JP      ERROR           ; Output error-
1363+  2937             
1364+  2937 2B          ATOH:   DEC     HL              ; ASCII number to DE binary
1365+  2938 11 00 00    GETLN:  LD      DE,0            ; Get number to DE
1366+  293B CD 6A 28    GTLNLP: CALL    GETCHR          ; Get next character
1367+  293E D0                  RET     NC              ; Exit if not a digit
1368+  293F E5                  PUSH    HL              ; Save code string address
1369+  2940 F5                  PUSH    AF              ; Save digit
1370+  2941 21 98 19            LD      HL,65529/10     ; Largest number 65529
1371+  2944 CD DA 26            CALL    CPDEHL          ; Number in range?
1372+  2947 DA 03 24            JP      C,SNERR         ; No - ?SN Error
1373+  294A 62                  LD      H,D             ; HL = Number
1374+  294B 6B                  LD      L,E
1375+  294C 19                  ADD     HL,DE           ; Times 2
1376+  294D 29                  ADD     HL,HL           ; Times 4
1377+  294E 19                  ADD     HL,DE           ; Times 5
1378+  294F 29                  ADD     HL,HL           ; Times 10
1379+  2950 F1                  POP     AF              ; Restore digit
1380+  2951 D6 30               SUB     '0'             ; Make it 0 to 9
1381+  2953 5F                  LD      E,A             ; DE = Value of digit
1382+  2954 16 00               LD      D,0
1383+  2956 19                  ADD     HL,DE           ; Add to number
1384+  2957 EB                  EX      DE,HL           ; Number to DE
1385+  2958 E1                  POP     HL              ; Restore code string address
1386+  2959 C3 3B 29            JP      GTLNLP          ; Go to next character
1387+  295C             
1388+  295C CA 21 25    CLEAR:  JP      Z,INTVAR        ; Just "CLEAR" Keep parameters
1389+  295F CD 14 29            CALL    POSINT          ; Get integer 0 to 32767 to DE
1390+  2962 2B                  DEC     HL              ; Cancel increment
1391+  2963 CD 6A 28            CALL    GETCHR          ; Get next character
1392+  2966 E5                  PUSH    HL              ; Save code string address
1393+  2967 2A 7F 41            LD      HL,(LSTRAM)     ; Get end of RAM
1394+  296A CA 7F 29            JP      Z,STORED        ; No value given - Use stored
1395+  296D E1                  POP     HL              ; Restore code string address
1396+  296E CD E0 26            CALL    CHKSYN          ; Check for comma
1397+  2971 2C                  .BYTE      ','
1398+  2972 D5                  PUSH    DE              ; Save number
1399+  2973 CD 14 29            CALL    POSINT          ; Get integer 0 to 32767
1400+  2976 2B                  DEC     HL              ; Cancel increment
1401+  2977 CD 6A 28            CALL    GETCHR          ; Get next character
1402+  297A C2 03 24            JP      NZ,SNERR        ; ?SN Error if more on line
1403+  297D E3                  EX      (SP),HL         ; Save code string address
1404+  297E EB                  EX      DE,HL           ; Number to DE
1405+  297F 7D          STORED: LD      A,L             ; Get LSB of new RAM top
1406+  2980 93                  SUB     E               ; Subtract LSB of string space
1407+  2981 5F                  LD      E,A             ; Save LSB
1408+  2982 7C                  LD      A,H             ; Get MSB of new RAM top
1409+  2983 9A                  SBC     A,D             ; Subtract MSB of string space
1410+  2984 57                  LD      D,A             ; Save MSB
1411+  2985 DA F8 23            JP      C,OMERR         ; ?OM Error if not enough mem
1412+  2988 E5                  PUSH    HL              ; Save RAM top
1413+  2989 2A A6 41            LD      HL,(PROGND)     ; Get program end
1414+  298C 01 28 00            LD      BC,40           ; 40 Bytes minimum working RAM
1415+  298F 09                  ADD     HL,BC           ; Get lowest address
1416+  2990 CD DA 26            CALL    CPDEHL          ; Enough memory?
1417+  2993 D2 F8 23            JP      NC,OMERR        ; No - ?OM Error
1418+  2996 EB                  EX      DE,HL           ; RAM top to HL
1419+  2997 22 2A 41            LD      (STRSPC),HL     ; Set new string space
1420+  299A E1                  POP     HL              ; End of memory to use
1421+  299B 22 7F 41            LD      (LSTRAM),HL     ; Set new top of RAM
1422+  299E E1                  POP     HL              ; Restore code string address
1423+  299F C3 21 25            JP      INTVAR          ; Initialise variables
1424+  29A2             
1425+  29A2 CA 1D 25    RUN:    JP      Z,RUNFST        ; RUN from start if just RUN
1426+  29A5 CD 21 25            CALL    INTVAR          ; Initialise variables
1427+  29A8 01 2A 28            LD      BC,RUNCNT       ; Execution driver loop
1428+  29AB C3 BE 29            JP      RUNLIN          ; RUN from line number
1429+  29AE             
1430+  29AE 0E 03       GOSUB:  LD      C,3             ; 3 Levels of stack needed
1431+  29B0 CD E0 23            CALL    CHKSTK          ; Check for 3 levels of stack
1432+  29B3 C1                  POP     BC              ; Get return address
1433+  29B4 E5                  PUSH    HL              ; Save code string for RETURN
1434+  29B5 E5                  PUSH    HL              ; And for GOSUB routine
1435+  29B6 2A 2C 41            LD      HL,(LINEAT)     ; Get current line
1436+  29B9 E3                  EX      (SP),HL         ; Into stack - Code string out
1437+  29BA 3E 8C               LD      A,ZGOSUB        ; "GOSUB" token
1438+  29BC F5                  PUSH    AF              ; Save token
1439+  29BD 33                  INC     SP              ; Don't save flags
1440+  29BE             
1441+  29BE C5          RUNLIN: PUSH    BC              ; Save return address
1442+  29BF CD 37 29    GOTO:   CALL    ATOH            ; ASCII number to DE binary
1443+  29C2 CD 04 2A            CALL    REM             ; Get end of line
1444+  29C5 E5                  PUSH    HL              ; Save end of line
1445+  29C6 2A 2C 41            LD      HL,(LINEAT)     ; Get current line
1446+  29C9 CD DA 26            CALL    CPDEHL          ; Line after current?
1447+  29CC E1                  POP     HL              ; Restore end of line
1448+  29CD 23                  INC     HL              ; Start of next line
1449+  29CE DC F4 24            CALL    C,SRCHLP        ; Line is after current line
1450+  29D1 D4 F1 24            CALL    NC,SRCHLN       ; Line is before current line
1451+  29D4 60                  LD      H,B             ; Set up code string address
1452+  29D5 69                  LD      L,C
1453+  29D6 2B                  DEC     HL              ; Incremented after
1454+  29D7 D8                  RET     C               ; Line found
1455+  29D8 1E 27       ULERR:  LD      E,UL            ; ?UL Error
1456+  29DA C3 1E 24            JP      ERROR           ; Output error message
1457+  29DD             
1458+  29DD C0          RETURN: RET     NZ              ; Return if not just RETURN
1459+  29DE 16 FF               LD      D,-1            ; Flag "GOSUB" search
1460+  29E0 CD AC 23            CALL    BAKSTK          ; Look "GOSUB" block
1461+  29E3 F9                  LD      SP,HL           ; Kill all FORs in subroutine
1462+  29E4 FE 8C               CP      ZGOSUB          ; Test for "GOSUB" token
1463+  29E6 1E 18               LD      E,RG            ; ?RG Error
1464+  29E8 C2 1E 24            JP      NZ,ERROR        ; Error if no "GOSUB" found
1465+  29EB E1                  POP     HL              ; Get RETURN line number
1466+  29EC 22 2C 41            LD      (LINEAT),HL     ; Save as current
1467+  29EF 23                  INC     HL              ; Was it from direct statement?
1468+  29F0 7C                  LD      A,H
1469+  29F1 B5                  OR      L               ; Return to line
1470+  29F2 C2 FC 29            JP      NZ,RETLIN       ; No - Return to line
1471+  29F5 3A 9C 41            LD      A,(LSTBIN)      ; Any INPUT in subroutine?
1472+  29F8 B7                  OR      A               ; If so buffer is corrupted
1473+  29F9 C2 4F 24            JP      NZ,POPNOK       ; Yes - Go to command mode
1474+  29FC 21 2A 28    RETLIN: LD      HL,RUNCNT       ; Execution driver loop
1475+  29FF E3                  EX      (SP),HL         ; Into stack - Code string out
1476+  2A00 3E                  .BYTE      3EH             ; Skip "POP HL"
1477+  2A01 E1          NXTDTA: POP     HL              ; Restore code string address
1478+  2A02             
1479+  2A02 01 3A       DATA:   .BYTE      01H,3AH         ; ':' End of statement
1480+  2A04 0E 00       REM:    LD      C,0             ; 00  End of statement
1481+  2A06 06 00               LD      B,0
1482+  2A08 79          NXTSTL: LD      A,C             ; Statement and byte
1483+  2A09 48                  LD      C,B
1484+  2A0A 47                  LD      B,A             ; Statement end byte
1485+  2A0B 7E          NXTSTT: LD      A,(HL)          ; Get byte
1486+  2A0C B7                  OR      A               ; End of line?
1487+  2A0D C8                  RET     Z               ; Yes - Exit
1488+  2A0E B8                  CP      B               ; End of statement?
1489+  2A0F C8                  RET     Z               ; Yes - Exit
1490+  2A10 23                  INC     HL              ; Next byte
1491+  2A11 FE 22               CP      '"'             ; Literal string?
1492+  2A13 CA 08 2A            JP      Z,NXTSTL        ; Yes - Look for another '"'
1493+  2A16 C3 0B 2A            JP      NXTSTT          ; Keep looking
1494+  2A19             
1495+  2A19 CD CE 2E    LET:    CALL    GETVAR          ; Get variable name
1496+  2A1C CD E0 26            CALL    CHKSYN          ; Make sure "=" follows
1497+  2A1F B4                  .BYTE      ZEQUAL          ; "=" token
1498+  2A20 D5                  PUSH    DE              ; Save address of variable
1499+  2A21 3A 7D 41            LD      A,(TYPE)        ; Get data type
1500+  2A24 F5                  PUSH    AF              ; Save type
1501+  2A25 CD EA 2C            CALL    EVAL            ; Evaluate expression
1502+  2A28 F1                  POP     AF              ; Restore type
1503+  2A29 E3                  EX      (SP),HL         ; Save code - Get var addr
1504+  2A2A 22 9E 41            LD      (BRKLIN),HL     ; Save address of variable
1505+  2A2D 1F                  RRA                     ; Adjust type
1506+  2A2E CD DD 2C            CALL    CHKTYP          ; Check types are the same
1507+  2A31 CA 6C 2A            JP      Z,LETNUM        ; Numeric - Move value
1508+  2A34 E5          LETSTR: PUSH    HL              ; Save address of string var
1509+  2A35 2A B4 41            LD      HL,(FPREG)      ; Pointer to string entry
1510+  2A38 E5                  PUSH    HL              ; Save it on stack
1511+  2A39 23                  INC     HL              ; Skip over length
1512+  2A3A 23                  INC     HL
1513+  2A3B 5E                  LD      E,(HL)          ; LSB of string address
1514+  2A3C 23                  INC     HL
1515+  2A3D 56                  LD      D,(HL)          ; MSB of string address
1516+  2A3E 2A 2E 41            LD      HL,(BASTXT)     ; Point to start of program
1517+  2A41 CD DA 26            CALL    CPDEHL          ; Is string before program?
1518+  2A44 D2 5B 2A            JP      NC,CRESTR       ; Yes - Create string entry
1519+  2A47 2A 2A 41            LD      HL,(STRSPC)     ; Point to string space
1520+  2A4A CD DA 26            CALL    CPDEHL          ; Is string literal in program?
1521+  2A4D D1                  POP     DE              ; Restore address of string
1522+  2A4E D2 63 2A            JP      NC,MVSTPT       ; Yes - Set up pointer
1523+  2A51 21 8F 41            LD      HL,TMPSTR       ; Temporary string pool
1524+  2A54 CD DA 26            CALL    CPDEHL          ; Is string in temporary pool?
1525+  2A57 D2 63 2A            JP      NC,MVSTPT       ; No - Set up pointer
1526+  2A5A 3E                  .BYTE   3EH             ; Skip "POP DE"
1527+  2A5B D1          CRESTR: POP     DE              ; Restore address of string
1528+  2A5C CD 12 33            CALL    BAKTMP          ; Back to last tmp-str entry
1529+  2A5F EB                  EX      DE,HL           ; Address of string entry
1530+  2A60 CD 4B 31            CALL    SAVSTR          ; Save string in string area
1531+  2A63 CD 12 33    MVSTPT: CALL    BAKTMP          ; Back to last tmp-str entry
1532+  2A66 E1                  POP     HL              ; Get string pointer
1533+  2A67 CD 39 37            CALL    DETHL4          ; Move string pointer to var
1534+  2A6A E1                  POP     HL              ; Restore code string address
1535+  2A6B C9                  RET
1536+  2A6C             
1537+  2A6C E5          LETNUM: PUSH    HL              ; Save address of variable
1538+  2A6D CD 36 37            CALL    FPTHL           ; Move value to variable
1539+  2A70 D1                  POP     DE              ; Restore address of variable
1540+  2A71 E1                  POP     HL              ; Restore code string address
1541+  2A72 C9                  RET
1542+  2A73             
1543+  2A73 CD 39 34    ON:     CALL    GETINT          ; Get integer 0-255
1544+  2A76 7E                  LD      A,(HL)          ; Get "GOTO" or "GOSUB" token
1545+  2A77 47                  LD      B,A             ; Save in B
1546+  2A78 FE 8C               CP      ZGOSUB          ; "GOSUB" token?
1547+  2A7A CA 82 2A            JP      Z,ONGO          ; Yes - Find line number
1548+  2A7D CD E0 26            CALL    CHKSYN          ; Make sure it's "GOTO"
1549+  2A80 88                  .BYTE   ZGOTO           ; "GOTO" token
1550+  2A81 2B                  DEC     HL              ; Cancel increment
1551+  2A82 4B          ONGO:   LD      C,E             ; Integer of branch value
1552+  2A83 0D          ONGOLP: DEC     C               ; Count branches
1553+  2A84 78                  LD      A,B             ; Get "GOTO" or "GOSUB" token
1554+  2A85 CA 52 28            JP      Z,ONJMP         ; Go to that line if right one
1555+  2A88 CD 38 29            CALL    GETLN           ; Get line number to DE
1556+  2A8B FE 2C               CP      ','             ; Another line number?
1557+  2A8D C0                  RET     NZ              ; No - Drop through
1558+  2A8E C3 83 2A            JP      ONGOLP          ; Yes - loop
1559+  2A91             
1560+  2A91 CD EA 2C    IF:     CALL    EVAL            ; Evaluate expression
1561+  2A94 7E                  LD      A,(HL)          ; Get token
1562+  2A95 FE 88               CP      ZGOTO           ; "GOTO" token?
1563+  2A97 CA 9F 2A            JP      Z,IFGO          ; Yes - Get line
1564+  2A9A CD E0 26            CALL    CHKSYN          ; Make sure it's "THEN"
1565+  2A9D A9                  .BYTE      ZTHEN           ; "THEN" token
1566+  2A9E 2B                  DEC     HL              ; Cancel increment
1567+  2A9F CD DB 2C    IFGO:   CALL    TSTNUM          ; Make sure it's numeric
1568+  2AA2 CD DE 36            CALL    TSTSGN          ; Test state of expression
1569+  2AA5 CA 04 2A            JP      Z,REM           ; False - Drop through
1570+  2AA8 CD 6A 28            CALL    GETCHR          ; Get next character
1571+  2AAB DA BF 29            JP      C,GOTO          ; Number - GOTO that line
1572+  2AAE C3 51 28            JP      IFJMP           ; Otherwise do statement
1573+  2AB1             
1574+  2AB1 2B          MRPRNT: DEC     HL              ; DEC 'cos GETCHR INCs
1575+  2AB2 CD 6A 28            CALL    GETCHR          ; Get next character
1576+  2AB5 CA 13 2B    PRINT:  JP      Z,PRNTCRLF      ; CRLF if just PRINT
1577+  2AB8 C8          PRNTLP: RET     Z               ; End of list - Exit
1578+  2AB9 FE A5               CP      ZTAB            ; "TAB(" token?
1579+  2ABB CA 46 2B            JP      Z,DOTAB         ; Yes - Do TAB routine
1580+  2ABE FE A8               CP      ZSPC            ; "SPC(" token?
1581+  2AC0 CA 46 2B            JP      Z,DOTAB         ; Yes - Do SPC routine
1582+  2AC3 E5                  PUSH    HL              ; Save code string address
1583+  2AC4 FE 2C               CP      ','             ; Comma?
1584+  2AC6 CA 2F 2B            JP      Z,DOCOM         ; Yes - Move to next zone
1585+  2AC9 FE 3B               CP      59 ;";"         ; Semi-colon?
1586+  2ACB CA 69 2B            JP      Z,NEXITM        ; Do semi-colon routine
1587+  2ACE C1                  POP     BC              ; Code string address to BC
1588+  2ACF CD EA 2C            CALL    EVAL            ; Evaluate expression
1589+  2AD2 E5                  PUSH    HL              ; Save code string address
1590+  2AD3 3A 7D 41            LD      A,(TYPE)        ; Get variable type
1591+  2AD6 B7                  OR      A               ; Is it a string variable?
1592+  2AD7 C2 FF 2A            JP      NZ,PRNTST       ; Yes - Output string contents
1593+  2ADA CD 83 38            CALL    NUMASC          ; Convert number to text
1594+  2ADD CD 6F 31            CALL    CRTST           ; Create temporary string
1595+  2AE0 36 20               LD      (HL),' '        ; Followed by a space
1596+  2AE2 2A B4 41            LD      HL,(FPREG)      ; Get length of output
1597+  2AE5 34                  INC     (HL)            ; Plus 1 for the space
1598+  2AE6 2A B4 41            LD      HL,(FPREG)      ; < Not needed >
1599+  2AE9 3A 12 41            LD      A,(LWIDTH)      ; Get width of line
1600+  2AEC 47                  LD      B,A             ; To B
1601+  2AED 04                  INC     B               ; Width 255 (No limit)?
1602+  2AEE CA FB 2A            JP      Z,PRNTNB        ; Yes - Output number string
1603+  2AF1 04                  INC     B               ; Adjust it
1604+  2AF2 3A 7B 41            LD      A,(CURPOS)      ; Get cursor position
1605+  2AF5 86                  ADD     A,(HL)          ; Add length of string
1606+  2AF6 3D                  DEC     A               ; Adjust it
1607+  2AF7 B8                  CP      B               ; Will output fit on this line?
1608+  2AF8 D4 13 2B            CALL    NC,PRNTCRLF     ; No - CRLF first
1609+  2AFB CD B4 31    PRNTNB: CALL    PRS1            ; Output string at (HL)
1610+  2AFE AF                  XOR     A               ; Skip CALL by setting 'z' flag
1611+  2AFF C4 B4 31    PRNTST: CALL    NZ,PRS1         ; Output string at (HL)
1612+  2B02 E1                  POP     HL              ; Restore code string address
1613+  2B03 C3 B1 2A            JP      MRPRNT          ; See if more to PRINT
1614+  2B06             
1615+  2B06 3A 7B 41    STTLIN: LD      A,(CURPOS)      ; Make sure on new line
1616+  2B09 B7                  OR      A               ; Already at start?
1617+  2B0A C8                  RET     Z               ; Yes - Do nothing
1618+  2B0B C3 13 2B            JP      PRNTCRLF        ; Start a new line
1619+  2B0E             
1620+  2B0E 36 00       ENDINP: LD      (HL),0          ; Mark end of buffer
1621+  2B10 21 C8 41            LD      HL,BUFFER-1     ; Point to buffer
1622+  2B13 3E 0D       PRNTCRLF: LD    A,CR            ; Load a CR
1623+  2B15 CD EB 26            CALL    OUTC            ; Output character
1624+  2B18 3E 0A               LD      A,LF            ; Load a LF
1625+  2B1A CD EB 26            CALL    OUTC            ; Output character
1626+  2B1D AF          DONULL: XOR     A               ; Set to position 0
1627+  2B1E 32 7B 41            LD      (CURPOS),A      ; Store it
1628+  2B21 3A 11 41            LD      A,(NULLS)       ; Get number of nulls
1629+  2B24 3D          NULLP:  DEC     A               ; Count them
1630+  2B25 C8                  RET     Z               ; Return if done
1631+  2B26 F5                  PUSH    AF              ; Save count
1632+  2B27 AF                  XOR     A               ; Load a null
1633+  2B28 CD EB 26            CALL    OUTC            ; Output it
1634+  2B2B F1                  POP     AF              ; Restore count
1635+  2B2C C3 24 2B            JP      NULLP           ; Keep counting
1636+  2B2F             
1637+  2B2F 3A 13 41    DOCOM:  LD      A,(COMMAN)      ; Get comma width
1638+  2B32 47                  LD      B,A             ; Save in B
1639+  2B33 3A 7B 41            LD      A,(CURPOS)      ; Get current position
1640+  2B36 B8                  CP      B               ; Within the limit?
1641+  2B37 D4 13 2B            CALL    NC,PRNTCRLF     ; No - output CRLF
1642+  2B3A D2 69 2B            JP      NC,NEXITM       ; Get next item
1643+  2B3D D6 0E       ZONELP: SUB     14              ; Next zone of 14 characters
1644+  2B3F D2 3D 2B            JP      NC,ZONELP       ; Repeat if more zones
1645+  2B42 2F                  CPL                     ; Number of spaces to output
1646+  2B43 C3 5E 2B            JP      ASPCS           ; Output them
1647+  2B46             
1648+  2B46 F5          DOTAB:  PUSH    AF              ; Save token
1649+  2B47 CD 36 34            CALL    FNDNUM          ; Evaluate expression
1650+  2B4A CD E0 26            CALL    CHKSYN          ; Make sure ")" follows
1651+  2B4D 29                  .BYTE   ")"
1652+  2B4E 2B                  DEC     HL              ; Back space on to ")"
1653+  2B4F F1                  POP     AF              ; Restore token
1654+  2B50 D6 A8               SUB     ZSPC            ; Was it "SPC(" ?
1655+  2B52 E5                  PUSH    HL              ; Save code string address
1656+  2B53 CA 59 2B            JP      Z,DOSPC         ; Yes - Do 'E' spaces
1657+  2B56 3A 7B 41            LD      A,(CURPOS)      ; Get current position
1658+  2B59 2F          DOSPC:  CPL                     ; Number of spaces to print to
1659+  2B5A 83                  ADD     A,E             ; Total number to print
1660+  2B5B D2 69 2B            JP      NC,NEXITM       ; TAB < Current POS(X)
1661+  2B5E 3C          ASPCS:  INC     A               ; Output A spaces
1662+  2B5F 47                  LD      B,A             ; Save number to print
1663+  2B60 3E 20               LD      A,' '           ; Space
1664+  2B62 CD EB 26    SPCLP:  CALL    OUTC            ; Output character in A
1665+  2B65 05                  DEC     B               ; Count them
1666+  2B66 C2 62 2B            JP      NZ,SPCLP        ; Repeat if more
1667+  2B69 E1          NEXITM: POP     HL              ; Restore code string address
1668+  2B6A CD 6A 28            CALL    GETCHR          ; Get next character
1669+  2B6D C3 B8 2A            JP      PRNTLP          ; More to print
1670+  2B70             
1671+  2B70 3F5265646F20REDO:   .BYTE   "?Redo from start",CR,LF,0
1671+  2B76 66726F6D2073746172740D0A00
1672+  2B83             
1673+  2B83 3A 9D 41    BADINP: LD      A,(READFG)      ; READ or INPUT?
1674+  2B86 B7                  OR      A
1675+  2B87 C2 FD 23            JP      NZ,DATSNR       ; READ - ?SN Error
1676+  2B8A C1                  POP     BC              ; Throw away code string addr
1677+  2B8B 21 70 2B            LD      HL,REDO         ; "Redo from start" message
1678+  2B8E CD B1 31            CALL    PRS             ; Output string
1679+  2B91 C3 50 25            JP      DOAGN           ; Do last INPUT again
1680+  2B94             
1681+  2B94 CD 1C 31    INPUT:  CALL    IDTEST          ; Test for illegal direct
1682+  2B97 7E                  LD      A,(HL)          ; Get character after "INPUT"
1683+  2B98 FE 22               CP      '"'             ; Is there a prompt string?
1684+  2B9A 3E 00               LD      A,0             ; Clear A and leave flags
1685+  2B9C 32 15 41            LD      (CTLOFG),A      ; Enable output
1686+  2B9F C2 AE 2B            JP      NZ,NOPMPT       ; No prompt - get input
1687+  2BA2 CD 70 31            CALL    QTSTR           ; Get string terminated by '"'
1688+  2BA5 CD E0 26            CALL    CHKSYN          ; Check for ';' after prompt
1689+  2BA8 3B                  .BYTE   ';'
1690+  2BA9 E5                  PUSH    HL              ; Save code string address
1691+  2BAA CD B4 31            CALL    PRS1            ; Output prompt string
1692+  2BAD 3E                  .BYTE   3EH             ; Skip "PUSH HL"
1693+  2BAE E5          NOPMPT: PUSH    HL              ; Save code string address
1694+  2BAF CD 54 25            CALL    PROMPT          ; Get input with "? " prompt
1695+  2BB2 C1                  POP     BC              ; Restore code string address
1696+  2BB3 DA B9 28            JP      C,INPBRK        ; Break pressed - Exit
1697+  2BB6 23                  INC     HL              ; Next byte
1698+  2BB7 7E                  LD      A,(HL)          ; Get it
1699+  2BB8 B7                  OR      A               ; End of line?
1700+  2BB9 2B                  DEC     HL              ; Back again
1701+  2BBA C5                  PUSH    BC              ; Re-save code string address
1702+  2BBB CA 01 2A            JP      Z,NXTDTA        ; Yes - Find next DATA stmt
1703+  2BBE 36 2C               LD      (HL),','        ; Store comma as separator
1704+  2BC0 C3 C8 2B            JP      NXTITM          ; Get next item
1705+  2BC3             
1706+  2BC3 E5          READ:   PUSH    HL              ; Save code string address
1707+  2BC4 2A AC 41            LD      HL,(NXTDAT)     ; Next DATA statement
1708+  2BC7 F6                  .BYTE   0F6H            ; Flag "READ"
1709+  2BC8 AF          NXTITM: XOR     A               ; Flag "INPUT"
1710+  2BC9 32 9D 41            LD      (READFG),A      ; Save "READ"/"INPUT" flag
1711+  2BCC E3                  EX      (SP),HL         ; Get code str' , Save pointer
1712+  2BCD C3 D4 2B            JP      GTVLUS          ; Get values
1713+  2BD0             
1714+  2BD0 CD E0 26    NEDMOR: CALL    CHKSYN          ; Check for comma between items
1715+  2BD3 2C                  .BYTE      ','
1716+  2BD4 CD CE 2E    GTVLUS: CALL    GETVAR          ; Get variable name
1717+  2BD7 E3                  EX      (SP),HL         ; Save code str" , Get pointer
1718+  2BD8 D5                  PUSH    DE              ; Save variable address
1719+  2BD9 7E                  LD      A,(HL)          ; Get next "INPUT"/"DATA" byte
1720+  2BDA FE 2C               CP      ','             ; Comma?
1721+  2BDC CA FC 2B            JP      Z,ANTVLU        ; Yes - Get another value
1722+  2BDF 3A 9D 41            LD      A,(READFG)      ; Is it READ?
1723+  2BE2 B7                  OR      A
1724+  2BE3 C2 69 2C            JP      NZ,FDTLP        ; Yes - Find next DATA stmt
1725+  2BE6 3E 3F               LD      A,'?'           ; More INPUT needed
1726+  2BE8 CD EB 26            CALL    OUTC            ; Output character
1727+  2BEB CD 54 25            CALL    PROMPT          ; Get INPUT with prompt
1728+  2BEE D1                  POP     DE              ; Variable address
1729+  2BEF C1                  POP     BC              ; Code string address
1730+  2BF0 DA B9 28            JP      C,INPBRK        ; Break pressed
1731+  2BF3 23                  INC     HL              ; Point to next DATA byte
1732+  2BF4 7E                  LD      A,(HL)          ; Get byte
1733+  2BF5 B7                  OR      A               ; Is it zero (No input) ?
1734+  2BF6 2B                  DEC     HL              ; Back space INPUT pointer
1735+  2BF7 C5                  PUSH    BC              ; Save code string address
1736+  2BF8 CA 01 2A            JP      Z,NXTDTA        ; Find end of buffer
1737+  2BFB D5                  PUSH    DE              ; Save variable address
1738+  2BFC 3A 7D 41    ANTVLU: LD      A,(TYPE)        ; Check data type
1739+  2BFF B7                  OR      A               ; Is it numeric?
1740+  2C00 CA 26 2C            JP      Z,INPBIN        ; Yes - Convert to binary
1741+  2C03 CD 6A 28            CALL    GETCHR          ; Get next character
1742+  2C06 57                  LD      D,A             ; Save input character
1743+  2C07 47                  LD      B,A             ; Again
1744+  2C08 FE 22               CP      '"'             ; Start of literal sting?
1745+  2C0A CA 1A 2C            JP      Z,STRENT        ; Yes - Create string entry
1746+  2C0D 3A 9D 41            LD      A,(READFG)      ; "READ" or "INPUT" ?
1747+  2C10 B7                  OR      A
1748+  2C11 57                  LD      D,A             ; Save 00 if "INPUT"
1749+  2C12 CA 17 2C            JP      Z,ITMSEP        ; "INPUT" - End with 00
1750+  2C15 16 3A               LD      D,':'           ; "DATA" - End with 00 or ':'
1751+  2C17 06 2C       ITMSEP: LD      B,','           ; Item separator
1752+  2C19 2B                  DEC     HL              ; Back space for DTSTR
1753+  2C1A CD 73 31    STRENT: CALL    DTSTR           ; Get string terminated by D
1754+  2C1D EB                  EX      DE,HL           ; String address to DE
1755+  2C1E 21 31 2C            LD      HL,LTSTND       ; Where to go after LETSTR
1756+  2C21 E3                  EX      (SP),HL         ; Save HL , get input pointer
1757+  2C22 D5                  PUSH    DE              ; Save address of string
1758+  2C23 C3 34 2A            JP      LETSTR          ; Assign string to variable
1759+  2C26             
1760+  2C26 CD 6A 28    INPBIN: CALL    GETCHR          ; Get next character
1761+  2C29 CD E5 37            CALL    ASCTFP          ; Convert ASCII to FP number
1762+  2C2C E3                  EX      (SP),HL         ; Save input ptr, Get var addr
1763+  2C2D CD 36 37            CALL    FPTHL           ; Move FPREG to variable
1764+  2C30 E1                  POP     HL              ; Restore input pointer
1765+  2C31 2B          LTSTND: DEC     HL              ; DEC 'cos GETCHR INCs
1766+  2C32 CD 6A 28            CALL    GETCHR          ; Get next character
1767+  2C35 CA 3D 2C            JP      Z,MORDT         ; End of line - More needed?
1768+  2C38 FE 2C               CP      ','             ; Another value?
1769+  2C3A C2 83 2B            JP      NZ,BADINP       ; No - Bad input
1770+  2C3D E3          MORDT:  EX      (SP),HL         ; Get code string address
1771+  2C3E 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
1772+  2C3F CD 6A 28            CALL    GETCHR          ; Get next character
1773+  2C42 C2 D0 2B            JP      NZ,NEDMOR       ; More needed - Get it
1774+  2C45 D1                  POP     DE              ; Restore DATA pointer
1775+  2C46 3A 9D 41            LD      A,(READFG)      ; "READ" or "INPUT" ?
1776+  2C49 B7                  OR      A
1777+  2C4A EB                  EX      DE,HL           ; DATA pointer to HL
1778+  2C4B C2 90 28            JP      NZ,UPDATA       ; Update DATA pointer if "READ"
1779+  2C4E D5                  PUSH    DE              ; Save code string address
1780+  2C4F B6                  OR      (HL)            ; More input given?
1781+  2C50 21 58 2C            LD      HL,EXTIG        ; "?Extra ignored" message
1782+  2C53 C4 B1 31            CALL    NZ,PRS          ; Output string if extra given
1783+  2C56 E1                  POP     HL              ; Restore code string address
1784+  2C57 C9                  RET
1785+  2C58             
1786+  2C58 3F4578747261EXTIG:  .BYTE   "?Extra ignored",CR,LF,0
1786+  2C5E 2069676E6F7265640D0A00
1787+  2C69             
1788+  2C69 CD 02 2A    FDTLP:  CALL    DATA            ; Get next statement
1789+  2C6C B7                  OR      A               ; End of line?
1790+  2C6D C2 82 2C            JP      NZ,FANDT        ; No - See if DATA statement
1791+  2C70 23                  INC     HL
1792+  2C71 7E                  LD      A,(HL)          ; End of program?
1793+  2C72 23                  INC     HL
1794+  2C73 B6                  OR      (HL)            ; 00 00 Ends program
1795+  2C74 1E 1B               LD      E,OD            ; ?OD Error
1796+  2C76 CA 1E 24            JP      Z,ERROR         ; Yes - Out of DATA
1797+  2C79 23                  INC     HL
1798+  2C7A 5E                  LD      E,(HL)          ; LSB of line number
1799+  2C7B 23                  INC     HL
1800+  2C7C 56                  LD      D,(HL)          ; MSB of line number
1801+  2C7D EB                  EX      DE,HL
1802+  2C7E 22 99 41            LD      (DATLIN),HL     ; Set line of current DATA item
1803+  2C81 EB                  EX      DE,HL
1804+  2C82 CD 6A 28    FANDT:  CALL    GETCHR          ; Get next character
1805+  2C85 FE 83               CP      ZDATA           ; "DATA" token
1806+  2C87 C2 69 2C            JP      NZ,FDTLP        ; No "DATA" - Keep looking
1807+  2C8A C3 FC 2B            JP      ANTVLU          ; Found - Convert input
1808+  2C8D             
1809+  2C8D 11 00 00    NEXT:   LD      DE,0            ; In case no index given
1810+  2C90 C4 CE 2E    NEXT1:  CALL    NZ,GETVAR       ; Get index address
1811+  2C93 22 9E 41            LD      (BRKLIN),HL     ; Save code string address
1812+  2C96 CD AC 23            CALL    BAKSTK          ; Look for "FOR" block
1813+  2C99 C2 0B 24            JP      NZ,NFERR        ; No "FOR" - ?NF Error
1814+  2C9C F9                  LD      SP,HL           ; Clear nested loops
1815+  2C9D D5                  PUSH    DE              ; Save index address
1816+  2C9E 7E                  LD      A,(HL)          ; Get sign of STEP
1817+  2C9F 23                  INC     HL
1818+  2CA0 F5                  PUSH    AF              ; Save sign of STEP
1819+  2CA1 D5                  PUSH    DE              ; Save index address
1820+  2CA2 CD 1C 37            CALL    PHLTFP          ; Move index value to FPREG
1821+  2CA5 E3                  EX      (SP),HL         ; Save address of TO value
1822+  2CA6 E5                  PUSH    HL              ; Save address of index
1823+  2CA7 CD 89 34            CALL    ADDPHL          ; Add STEP to index value
1824+  2CAA E1                  POP     HL              ; Restore address of index
1825+  2CAB CD 36 37            CALL    FPTHL           ; Move value to index variable
1826+  2CAE E1                  POP     HL              ; Restore address of TO value
1827+  2CAF CD 2D 37            CALL    LOADFP          ; Move TO value to BCDE
1828+  2CB2 E5                  PUSH    HL              ; Save address of line of FOR
1829+  2CB3 CD 59 37            CALL    CMPNUM          ; Compare index with TO value
1830+  2CB6 E1                  POP     HL              ; Restore address of line num
1831+  2CB7 C1                  POP     BC              ; Address of sign of STEP
1832+  2CB8 90                  SUB     B               ; Compare with expected sign
1833+  2CB9 CD 2D 37            CALL    LOADFP          ; BC = Loop stmt,DE = Line num
1834+  2CBC CA C8 2C            JP      Z,KILFOR        ; Loop finished - Terminate it
1835+  2CBF EB                  EX      DE,HL           ; Loop statement line number
1836+  2CC0 22 2C 41            LD      (LINEAT),HL     ; Set loop line number
1837+  2CC3 69                  LD      L,C             ; Set code string to loop
1838+  2CC4 60                  LD      H,B
1839+  2CC5 C3 26 28            JP      PUTFID          ; Put back "FOR" and continue
1840+  2CC8             
1841+  2CC8 F9          KILFOR: LD      SP,HL           ; Remove "FOR" block
1842+  2CC9 2A 9E 41            LD      HL,(BRKLIN)     ; Code string after "NEXT"
1843+  2CCC 7E                  LD      A,(HL)          ; Get next byte in code string
1844+  2CCD FE 2C               CP      ','             ; More NEXTs ?
1845+  2CCF C2 2A 28            JP      NZ,RUNCNT       ; No - Do next statement
1846+  2CD2 CD 6A 28            CALL    GETCHR          ; Position to index name
1847+  2CD5 CD 90 2C            CALL    NEXT1           ; Re-enter NEXT routine
1848+  2CD8             ; < will not RETurn to here , Exit to RUNCNT or Loop >
1849+  2CD8             
1850+  2CD8 CD EA 2C    GETNUM: CALL    EVAL            ; Get a numeric expression
1851+  2CDB F6          TSTNUM: .BYTE      0F6H            ; Clear carry (numeric)
1852+  2CDC 37          TSTSTR: SCF                     ; Set carry (string)
1853+  2CDD 3A 7D 41    CHKTYP: LD      A,(TYPE)        ; Check types match
1854+  2CE0 8F                  ADC     A,A             ; Expected + actual
1855+  2CE1 B7                  OR      A               ; Clear carry , set parity
1856+  2CE2 E8                  RET     PE              ; Even parity - Types match
1857+  2CE3 C3 1B 24            JP      TMERR           ; Different types - Error
1858+  2CE6             
1859+  2CE6 CD E0 26    OPNPAR: CALL    CHKSYN          ; Make sure "(" follows
1860+  2CE9 28                  .BYTE   "("
1861+  2CEA 2B          EVAL:   DEC     HL              ; Evaluate expression & save
1862+  2CEB 16 00               LD      D,0             ; Precedence value
1863+  2CED D5          EVAL1:  PUSH    DE              ; Save precedence
1864+  2CEE 0E 01               LD      C,1
1865+  2CF0 CD E0 23            CALL    CHKSTK          ; Check for 1 level of stack
1866+  2CF3 CD 61 2D            CALL    OPRND           ; Get next expression value
1867+  2CF6 22 A0 41    EVAL2:  LD      (NXTOPR),HL     ; Save address of next operator
1868+  2CF9 2A A0 41    EVAL3:  LD      HL,(NXTOPR)     ; Restore address of next opr
1869+  2CFC C1                  POP     BC              ; Precedence value and operator
1870+  2CFD 78                  LD      A,B             ; Get precedence value
1871+  2CFE FE 78               CP      78H             ; "AND" or "OR" ?
1872+  2D00 D4 DB 2C            CALL    NC,TSTNUM       ; No - Make sure it's a number
1873+  2D03 7E                  LD      A,(HL)          ; Get next operator / function
1874+  2D04 16 00               LD      D,0             ; Clear Last relation
1875+  2D06 D6 B3       RLTLP:  SUB     ZGTR            ; ">" Token
1876+  2D08 DA 22 2D            JP      C,FOPRND        ; + - * / ^ AND OR - Test it
1877+  2D0B FE 03               CP      ZLTH+1-ZGTR     ; < = >
1878+  2D0D D2 22 2D            JP      NC,FOPRND       ; Function - Call it
1879+  2D10 FE 01               CP      ZEQUAL-ZGTR     ; "="
1880+  2D12 17                  RLA                     ; <- Test for legal
1881+  2D13 AA                  XOR     D               ; <- combinations of < = >
1882+  2D14 BA                  CP      D               ; <- by combining last token
1883+  2D15 57                  LD      D,A             ; <- with current one
1884+  2D16 DA 03 24            JP      C,SNERR         ; Error if "<<' '==" or ">>"
1885+  2D19 22 95 41            LD      (CUROPR),HL     ; Save address of current token
1886+  2D1C CD 6A 28            CALL    GETCHR          ; Get next character
1887+  2D1F C3 06 2D            JP      RLTLP           ; Treat the two as one
1888+  2D22             
1889+  2D22 7A          FOPRND: LD      A,D             ; < = > found ?
1890+  2D23 B7                  OR      A
1891+  2D24 C2 49 2E            JP      NZ,TSTRED       ; Yes - Test for reduction
1892+  2D27 7E                  LD      A,(HL)          ; Get operator token
1893+  2D28 22 95 41            LD      (CUROPR),HL     ; Save operator address
1894+  2D2B D6 AC               SUB     ZPLUS           ; Operator or function?
1895+  2D2D D8                  RET     C               ; Neither - Exit
1896+  2D2E FE 07               CP      ZOR+1-ZPLUS     ; Is it + - * / ^ AND OR ?
1897+  2D30 D0                  RET     NC              ; No - Exit
1898+  2D31 5F                  LD      E,A             ; Coded operator
1899+  2D32 3A 7D 41            LD      A,(TYPE)        ; Get data type
1900+  2D35 3D                  DEC     A               ; FF = numeric , 00 = string
1901+  2D36 B3                  OR      E               ; Combine with coded operator
1902+  2D37 7B                  LD      A,E             ; Get coded operator
1903+  2D38 CA A7 32            JP      Z,CONCAT        ; String concatenation
1904+  2D3B 07                  RLCA                    ; Times 2
1905+  2D3C 83                  ADD     A,E             ; Times 3
1906+  2D3D 5F                  LD      E,A             ; To DE (D is 0)
1907+  2D3E 21 CB 22            LD      HL,PRITAB       ; Precedence table
1908+  2D41 19                  ADD     HL,DE           ; To the operator concerned
1909+  2D42 78                  LD      A,B             ; Last operator precedence
1910+  2D43 56                  LD      D,(HL)          ; Get evaluation precedence
1911+  2D44 BA                  CP      D               ; Compare with eval precedence
1912+  2D45 D0                  RET     NC              ; Exit if higher precedence
1913+  2D46 23                  INC     HL              ; Point to routine address
1914+  2D47 CD DB 2C            CALL    TSTNUM          ; Make sure it's a number
1915+  2D4A             
1916+  2D4A C5          STKTHS: PUSH    BC              ; Save last precedence & token
1917+  2D4B 01 F9 2C            LD      BC,EVAL3        ; Where to go on prec' break
1918+  2D4E C5                  PUSH    BC              ; Save on stack for return
1919+  2D4F 43                  LD      B,E             ; Save operator
1920+  2D50 4A                  LD      C,D             ; Save precedence
1921+  2D51 CD 0F 37            CALL    STAKFP          ; Move value to stack
1922+  2D54 58                  LD      E,B             ; Restore operator
1923+  2D55 51                  LD      D,C             ; Restore precedence
1924+  2D56 4E                  LD      C,(HL)          ; Get LSB of routine address
1925+  2D57 23                  INC     HL
1926+  2D58 46                  LD      B,(HL)          ; Get MSB of routine address
1927+  2D59 23                  INC     HL
1928+  2D5A C5                  PUSH    BC              ; Save routine address
1929+  2D5B 2A 95 41            LD      HL,(CUROPR)     ; Address of current operator
1930+  2D5E C3 ED 2C            JP      EVAL1           ; Loop until prec' break
1931+  2D61             
1932+  2D61 AF          OPRND:  XOR     A               ; Get operand routine
1933+  2D62 32 7D 41            LD      (TYPE),A        ; Set numeric expected
1934+  2D65 CD 6A 28            CALL    GETCHR          ; Get next character
1935+  2D68 1E 48               LD      E,MO            ; ?MO Error
1936+  2D6A CA 1E 24            JP      Z,ERROR         ; No operand - Error
1937+  2D6D DA E5 37            JP      C,ASCTFP        ; Number - Get value
1938+  2D70 CD 09 29            CALL    CHKLTR          ; See if a letter
1939+  2D73 D2 C8 2D            JP      NC,CONVAR       ; Letter - Find variable
1940+  2D76 FE 26               CP		'&'				; &H = HEX, &B = BINARY
1941+  2D78 20 12               JR		NZ, NOTAMP
1942+  2D7A CD 6A 28            CALL    GETCHR          ; Get next character
1943+  2D7D FE 48               CP      'H'             ; Hex number indicated? [function added]
1944+  2D7F CA 29 3C            JP      Z,HEXTFP        ; Convert Hex to FPREG
1945+  2D82 FE 42               CP      'B'             ; Binary number indicated? [function added]
1946+  2D84 CA 99 3C            JP      Z,BINTFP        ; Convert Bin to FPREG
1947+  2D87 1E 11               LD      E,SN            ; If neither then a ?SN Error
1948+  2D89 CA 1E 24            JP      Z,ERROR         ; 
1949+  2D8C FE AC       NOTAMP: CP      ZPLUS           ; '+' Token ?
1950+  2D8E CA 61 2D            JP      Z,OPRND         ; Yes - Look for operand
1951+  2D91 FE 2E               CP      '.'             ; '.' ?
1952+  2D93 CA E5 37            JP      Z,ASCTFP        ; Yes - Create FP number
1953+  2D96 FE AD               CP      ZMINUS          ; '-' Token ?
1954+  2D98 CA B7 2D            JP      Z,MINUS         ; Yes - Do minus
1955+  2D9B FE 22               CP      '"'             ; Literal string ?
1956+  2D9D CA 70 31            JP      Z,QTSTR         ; Get string terminated by '"'
1957+  2DA0 FE AA               CP      ZNOT            ; "NOT" Token ?
1958+  2DA2 CA A9 2E            JP      Z,EVNOT         ; Yes - Eval NOT expression
1959+  2DA5 FE A7               CP      ZFN             ; "FN" Token ?
1960+  2DA7 CA D4 30            JP      Z,DOFN          ; Yes - Do FN routine
1961+  2DAA D6 B6               SUB     ZSGN            ; Is it a function?
1962+  2DAC D2 D9 2D            JP      NC,FNOFST       ; Yes - Evaluate function
1963+  2DAF CD E6 2C    EVLPAR: CALL    OPNPAR          ; Evaluate expression in "()"
1964+  2DB2 CD E0 26            CALL    CHKSYN          ; Make sure ")" follows
1965+  2DB5 29                  .BYTE   ")"
1966+  2DB6 C9                  RET
1967+  2DB7             
1968+  2DB7 16 7D       MINUS:  LD      D,7DH           ; '-' precedence
1969+  2DB9 CD ED 2C            CALL    EVAL1           ; Evaluate until prec' break
1970+  2DBC 2A A0 41            LD      HL,(NXTOPR)     ; Get next operator address
1971+  2DBF E5                  PUSH    HL              ; Save next operator address
1972+  2DC0 CD 07 37            CALL    INVSGN          ; Negate value
1973+  2DC3 CD DB 2C    RETNUM: CALL    TSTNUM          ; Make sure it's a number
1974+  2DC6 E1                  POP     HL              ; Restore next operator address
1975+  2DC7 C9                  RET
1976+  2DC8             
1977+  2DC8 CD CE 2E    CONVAR: CALL    GETVAR          ; Get variable address to DE
1978+  2DCB E5          FRMEVL: PUSH    HL              ; Save code string address
1979+  2DCC EB                  EX      DE,HL           ; Variable address to HL
1980+  2DCD 22 B4 41            LD      (FPREG),HL      ; Save address of variable
1981+  2DD0 3A 7D 41            LD      A,(TYPE)        ; Get type
1982+  2DD3 B7                  OR      A               ; Numeric?
1983+  2DD4 CC 1C 37            CALL    Z,PHLTFP        ; Yes - Move contents to FPREG
1984+  2DD7 E1                  POP     HL              ; Restore code string address
1985+  2DD8 C9                  RET
1986+  2DD9             
1987+  2DD9 06 00       FNOFST: LD      B,0             ; Get address of function
1988+  2DDB 07                  RLCA                    ; Double function offset
1989+  2DDC 4F                  LD      C,A             ; BC = Offset in function table
1990+  2DDD C5                  PUSH    BC              ; Save adjusted token value
1991+  2DDE CD 6A 28            CALL    GETCHR          ; Get next character
1992+  2DE1 79                  LD      A,C             ; Get adjusted token value
1993+  2DE2 FE 31               CP      2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
1994+  2DE4 DA 00 2E            JP      C,FNVAL         ; No - Do function
1995+  2DE7 CD E6 2C            CALL    OPNPAR          ; Evaluate expression  (X,...
1996+  2DEA CD E0 26            CALL    CHKSYN          ; Make sure ',' follows
1997+  2DED 2C                  .BYTE      ','
1998+  2DEE CD DC 2C            CALL    TSTSTR          ; Make sure it's a string
1999+  2DF1 EB                  EX      DE,HL           ; Save code string address
2000+  2DF2 2A B4 41            LD      HL,(FPREG)      ; Get address of string
2001+  2DF5 E3                  EX      (SP),HL         ; Save address of string
2002+  2DF6 E5                  PUSH    HL              ; Save adjusted token value
2003+  2DF7 EB                  EX      DE,HL           ; Restore code string address
2004+  2DF8 CD 39 34            CALL    GETINT          ; Get integer 0-255
2005+  2DFB EB                  EX      DE,HL           ; Save code string address
2006+  2DFC E3                  EX      (SP),HL         ; Save integer,HL = adj' token
2007+  2DFD C3 08 2E            JP      GOFUNC          ; Jump to string function
2008+  2E00             
2009+  2E00 CD AF 2D    FNVAL:  CALL    EVLPAR          ; Evaluate expression
2010+  2E03 E3                  EX      (SP),HL         ; HL = Adjusted token value
2011+  2E04 11 C3 2D            LD      DE,RETNUM       ; Return number from function
2012+  2E07 D5                  PUSH    DE              ; Save on stack
2013+  2E08 01 28 21    GOFUNC: LD      BC,FNCTAB       ; Function routine addresses
2014+  2E0B 09                  ADD     HL,BC           ; Point to right address
2015+  2E0C 4E                  LD      C,(HL)          ; Get LSB of address
2016+  2E0D 23                  INC     HL              ;
2017+  2E0E 66                  LD      H,(HL)          ; Get MSB of address
2018+  2E0F 69                  LD      L,C             ; Address to HL
2019+  2E10 E9                  JP      (HL)            ; Jump to function
2020+  2E11             
2021+  2E11 15          SGNEXP: DEC     D               ; Dee to flag negative exponent
2022+  2E12 FE AD               CP      ZMINUS          ; '-' token ?
2023+  2E14 C8                  RET     Z               ; Yes - Return
2024+  2E15 FE 2D               CP      '-'             ; '-' ASCII ?
2025+  2E17 C8                  RET     Z               ; Yes - Return
2026+  2E18 14                  INC     D               ; Inc to flag positive exponent
2027+  2E19 FE 2B               CP      '+'             ; '+' ASCII ?
2028+  2E1B C8                  RET     Z               ; Yes - Return
2029+  2E1C FE AC               CP      ZPLUS           ; '+' token ?
2030+  2E1E C8                  RET     Z               ; Yes - Return
2031+  2E1F 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
2032+  2E20 C9                  RET                     ; Return "NZ"
2033+  2E21             
2034+  2E21 F6          POR:    .BYTE      0F6H            ; Flag "OR"
2035+  2E22 AF          PAND:   XOR     A               ; Flag "AND"
2036+  2E23 F5                  PUSH    AF              ; Save "AND" / "OR" flag
2037+  2E24 CD DB 2C            CALL    TSTNUM          ; Make sure it's a number
2038+  2E27 CD 1D 29            CALL    DEINT           ; Get integer -32768 to 32767
2039+  2E2A F1                  POP     AF              ; Restore "AND" / "OR" flag
2040+  2E2B EB                  EX      DE,HL           ; <- Get last
2041+  2E2C C1                  POP     BC              ; <-  value
2042+  2E2D E3                  EX      (SP),HL         ; <-  from
2043+  2E2E EB                  EX      DE,HL           ; <-  stack
2044+  2E2F CD 1F 37            CALL    FPBCDE          ; Move last value to FPREG
2045+  2E32 F5                  PUSH    AF              ; Save "AND" / "OR" flag
2046+  2E33 CD 1D 29            CALL    DEINT           ; Get integer -32768 to 32767
2047+  2E36 F1                  POP     AF              ; Restore "AND" / "OR" flag
2048+  2E37 C1                  POP     BC              ; Get value
2049+  2E38 79                  LD      A,C             ; Get LSB
2050+  2E39 21 92 30            LD      HL,ACPASS       ; Address of save AC as current
2051+  2E3C C2 44 2E            JP      NZ,POR1         ; Jump if OR
2052+  2E3F A3                  AND     E               ; "AND" LSBs
2053+  2E40 4F                  LD      C,A             ; Save LSB
2054+  2E41 78                  LD      A,B             ; Get MBS
2055+  2E42 A2                  AND     D               ; "AND" MSBs
2056+  2E43 E9                  JP      (HL)            ; Save AC as current (ACPASS)
2057+  2E44             
2058+  2E44 B3          POR1:   OR      E               ; "OR" LSBs
2059+  2E45 4F                  LD      C,A             ; Save LSB
2060+  2E46 78                  LD      A,B             ; Get MSB
2061+  2E47 B2                  OR      D               ; "OR" MSBs
2062+  2E48 E9                  JP      (HL)            ; Save AC as current (ACPASS)
2063+  2E49             
2064+  2E49 21 5B 2E    TSTRED: LD      HL,CMPLOG       ; Logical compare routine
2065+  2E4C 3A 7D 41            LD      A,(TYPE)        ; Get data type
2066+  2E4F 1F                  RRA                     ; Carry set = string
2067+  2E50 7A                  LD      A,D             ; Get last precedence value
2068+  2E51 17                  RLA                     ; Times 2 plus carry
2069+  2E52 5F                  LD      E,A             ; To E
2070+  2E53 16 64               LD      D,64H           ; Relational precedence
2071+  2E55 78                  LD      A,B             ; Get current precedence
2072+  2E56 BA                  CP      D               ; Compare with last
2073+  2E57 D0                  RET     NC              ; Eval if last was rel' or log'
2074+  2E58 C3 4A 2D            JP      STKTHS          ; Stack this one and get next
2075+  2E5B             
2076+  2E5B 5D 2E       CMPLOG: .WORD   CMPLG1          ; Compare two values / strings
2077+  2E5D 79          CMPLG1: LD      A,C             ; Get data type
2078+  2E5E B7                  OR      A
2079+  2E5F 1F                  RRA
2080+  2E60 C1                  POP     BC              ; Get last expression to BCDE
2081+  2E61 D1                  POP     DE
2082+  2E62 F5                  PUSH    AF              ; Save status
2083+  2E63 CD DD 2C            CALL    CHKTYP          ; Check that types match
2084+  2E66 21 9F 2E            LD      HL,CMPRES       ; Result to comparison
2085+  2E69 E5                  PUSH    HL              ; Save for RETurn
2086+  2E6A CA 59 37            JP      Z,CMPNUM        ; Compare values if numeric
2087+  2E6D AF                  XOR     A               ; Compare two strings
2088+  2E6E 32 7D 41            LD      (TYPE),A        ; Set type to numeric
2089+  2E71 D5                  PUSH    DE              ; Save string name
2090+  2E72 CD F4 32            CALL    GSTRCU          ; Get current string
2091+  2E75 7E                  LD      A,(HL)          ; Get length of string
2092+  2E76 23                  INC     HL
2093+  2E77 23                  INC     HL
2094+  2E78 4E                  LD      C,(HL)          ; Get LSB of address
2095+  2E79 23                  INC     HL
2096+  2E7A 46                  LD      B,(HL)          ; Get MSB of address
2097+  2E7B D1                  POP     DE              ; Restore string name
2098+  2E7C C5                  PUSH    BC              ; Save address of string
2099+  2E7D F5                  PUSH    AF              ; Save length of string
2100+  2E7E CD F8 32            CALL    GSTRDE          ; Get second string
2101+  2E81 CD 2D 37            CALL    LOADFP          ; Get address of second string
2102+  2E84 F1                  POP     AF              ; Restore length of string 1
2103+  2E85 57                  LD      D,A             ; Length to D
2104+  2E86 E1                  POP     HL              ; Restore address of string 1
2105+  2E87 7B          CMPSTR: LD      A,E             ; Bytes of string 2 to do
2106+  2E88 B2                  OR      D               ; Bytes of string 1 to do
2107+  2E89 C8                  RET     Z               ; Exit if all bytes compared
2108+  2E8A 7A                  LD      A,D             ; Get bytes of string 1 to do
2109+  2E8B D6 01               SUB     1
2110+  2E8D D8                  RET     C               ; Exit if end of string 1
2111+  2E8E AF                  XOR     A
2112+  2E8F BB                  CP      E               ; Bytes of string 2 to do
2113+  2E90 3C                  INC     A
2114+  2E91 D0                  RET     NC              ; Exit if end of string 2
2115+  2E92 15                  DEC     D               ; Count bytes in string 1
2116+  2E93 1D                  DEC     E               ; Count bytes in string 2
2117+  2E94 0A                  LD      A,(BC)          ; Byte in string 2
2118+  2E95 BE                  CP      (HL)            ; Compare to byte in string 1
2119+  2E96 23                  INC     HL              ; Move up string 1
2120+  2E97 03                  INC     BC              ; Move up string 2
2121+  2E98 CA 87 2E            JP      Z,CMPSTR        ; Same - Try next bytes
2122+  2E9B 3F                  CCF                     ; Flag difference (">" or "<")
2123+  2E9C C3 E9 36            JP      FLGDIF          ; "<" gives -1 , ">" gives +1
2124+  2E9F             
2125+  2E9F 3C          CMPRES: INC     A               ; Increment current value
2126+  2EA0 8F                  ADC     A,A             ; Double plus carry
2127+  2EA1 C1                  POP     BC              ; Get other value
2128+  2EA2 A0                  AND     B               ; Combine them
2129+  2EA3 C6 FF               ADD     A,-1            ; Carry set if different
2130+  2EA5 9F                  SBC     A,A             ; 00 - Equal , FF - Different
2131+  2EA6 C3 F0 36            JP      FLGREL          ; Set current value & continue
2132+  2EA9             
2133+  2EA9 16 5A       EVNOT:  LD      D,5AH           ; Precedence value for "NOT"
2134+  2EAB CD ED 2C            CALL    EVAL1           ; Eval until precedence break
2135+  2EAE CD DB 2C            CALL    TSTNUM          ; Make sure it's a number
2136+  2EB1 CD 1D 29            CALL    DEINT           ; Get integer -32768 - 32767
2137+  2EB4 7B                  LD      A,E             ; Get LSB
2138+  2EB5 2F                  CPL                     ; Invert LSB
2139+  2EB6 4F                  LD      C,A             ; Save "NOT" of LSB
2140+  2EB7 7A                  LD      A,D             ; Get MSB
2141+  2EB8 2F                  CPL                     ; Invert MSB
2142+  2EB9 CD 92 30            CALL    ACPASS          ; Save AC as current
2143+  2EBC C1                  POP     BC              ; Clean up stack
2144+  2EBD C3 F9 2C            JP      EVAL3           ; Continue evaluation
2145+  2EC0             
2146+  2EC0 2B          DIMRET: DEC     HL              ; DEC 'cos GETCHR INCs
2147+  2EC1 CD 6A 28            CALL    GETCHR          ; Get next character
2148+  2EC4 C8                  RET     Z               ; End of DIM statement
2149+  2EC5 CD E0 26            CALL    CHKSYN          ; Make sure ',' follows
2150+  2EC8 2C                  .BYTE      ','
2151+  2EC9 01 C0 2E    DIM:    LD      BC,DIMRET       ; Return to "DIMRET"
2152+  2ECC C5                  PUSH    BC              ; Save on stack
2153+  2ECD F6                  .BYTE      0F6H            ; Flag "Create" variable
2154+  2ECE AF          GETVAR: XOR     A               ; Find variable address,to DE
2155+  2ECF 32 7C 41            LD      (LCRFLG),A      ; Set locate / create flag
2156+  2ED2 46                  LD      B,(HL)          ; Get First byte of name
2157+  2ED3 CD 09 29    GTFNAM: CALL    CHKLTR          ; See if a letter
2158+  2ED6 DA 03 24            JP      C,SNERR         ; ?SN Error if not a letter
2159+  2ED9 AF                  XOR     A
2160+  2EDA 4F                  LD      C,A             ; Clear second byte of name
2161+  2EDB 32 7D 41            LD      (TYPE),A        ; Set type to numeric
2162+  2EDE CD 6A 28            CALL    GETCHR          ; Get next character
2163+  2EE1 DA EA 2E            JP      C,SVNAM2        ; Numeric - Save in name
2164+  2EE4 CD 09 29            CALL    CHKLTR          ; See if a letter
2165+  2EE7 DA F7 2E            JP      C,CHARTY        ; Not a letter - Check type
2166+  2EEA 4F          SVNAM2: LD      C,A             ; Save second byte of name
2167+  2EEB CD 6A 28    ENDNAM: CALL    GETCHR          ; Get next character
2168+  2EEE DA EB 2E            JP      C,ENDNAM        ; Numeric - Get another
2169+  2EF1 CD 09 29            CALL    CHKLTR          ; See if a letter
2170+  2EF4 D2 EB 2E            JP      NC,ENDNAM       ; Letter - Get another
2171+  2EF7 D6 24       CHARTY: SUB     '$'             ; String variable?
2172+  2EF9 C2 06 2F            JP      NZ,NOTSTR       ; No - Numeric variable
2173+  2EFC 3C                  INC     A               ; A = 1 (string type)
2174+  2EFD 32 7D 41            LD      (TYPE),A        ; Set type to string
2175+  2F00 0F                  RRCA                    ; A = 80H , Flag for string
2176+  2F01 81                  ADD     A,C             ; 2nd byte of name has bit 7 on
2177+  2F02 4F                  LD      C,A             ; Resave second byte on name
2178+  2F03 CD 6A 28            CALL    GETCHR          ; Get next character
2179+  2F06 3A 9B 41    NOTSTR: LD      A,(FORFLG)      ; Array name needed ?
2180+  2F09 3D                  DEC     A
2181+  2F0A CA B3 2F            JP      Z,ARLDSV        ; Yes - Get array name
2182+  2F0D F2 16 2F            JP      P,NSCFOR        ; No array with "FOR" or "FN"
2183+  2F10 7E                  LD      A,(HL)          ; Get byte again
2184+  2F11 D6 28               SUB     '('             ; Subscripted variable?
2185+  2F13 CA 8B 2F            JP      Z,SBSCPT        ; Yes - Sort out subscript
2186+  2F16             
2187+  2F16 AF          NSCFOR: XOR     A               ; Simple variable
2188+  2F17 32 9B 41            LD      (FORFLG),A      ; Clear "FOR" flag
2189+  2F1A E5                  PUSH    HL              ; Save code string address
2190+  2F1B 50                  LD      D,B             ; DE = Variable name to find
2191+  2F1C 59                  LD      E,C
2192+  2F1D 2A AE 41            LD      HL,(FNRGNM)     ; FN argument name
2193+  2F20 CD DA 26            CALL    CPDEHL          ; Is it the FN argument?
2194+  2F23 11 B0 41            LD      DE,FNARG        ; Point to argument value
2195+  2F26 CA 1F 36            JP      Z,POPHRT        ; Yes - Return FN argument value
2196+  2F29 2A A8 41            LD      HL,(VAREND)     ; End of variables
2197+  2F2C EB                  EX      DE,HL           ; Address of end of search
2198+  2F2D 2A A6 41            LD      HL,(PROGND)     ; Start of variables address
2199+  2F30 CD DA 26    FNDVAR: CALL    CPDEHL          ; End of variable list table?
2200+  2F33 CA 49 2F            JP      Z,CFEVAL        ; Yes - Called from EVAL?
2201+  2F36 79                  LD      A,C             ; Get second byte of name
2202+  2F37 96                  SUB     (HL)            ; Compare with name in list
2203+  2F38 23                  INC     HL              ; Move on to first byte
2204+  2F39 C2 3E 2F            JP      NZ,FNTHR        ; Different - Find another
2205+  2F3C 78                  LD      A,B             ; Get first byte of name
2206+  2F3D 96                  SUB     (HL)            ; Compare with name in list
2207+  2F3E 23          FNTHR:  INC     HL              ; Move on to LSB of value
2208+  2F3F CA 7D 2F            JP      Z,RETADR        ; Found - Return address
2209+  2F42 23                  INC     HL              ; <- Skip
2210+  2F43 23                  INC     HL              ; <- over
2211+  2F44 23                  INC     HL              ; <- F.P.
2212+  2F45 23                  INC     HL              ; <- value
2213+  2F46 C3 30 2F            JP      FNDVAR          ; Keep looking
2214+  2F49             
2215+  2F49 E1          CFEVAL: POP     HL              ; Restore code string address
2216+  2F4A E3                  EX      (SP),HL         ; Get return address
2217+  2F4B D5                  PUSH    DE              ; Save address of variable
2218+  2F4C 11 CB 2D            LD      DE,FRMEVL       ; Return address in EVAL
2219+  2F4F CD DA 26            CALL    CPDEHL          ; Called from EVAL ?
2220+  2F52 D1                  POP     DE              ; Restore address of variable
2221+  2F53 CA 80 2F            JP      Z,RETNUL        ; Yes - Return null variable
2222+  2F56 E3                  EX      (SP),HL         ; Put back return
2223+  2F57 E5                  PUSH    HL              ; Save code string address
2224+  2F58 C5                  PUSH    BC              ; Save variable name
2225+  2F59 01 06 00            LD      BC,6            ; 2 byte name plus 4 byte data
2226+  2F5C 2A AA 41            LD      HL,(ARREND)     ; End of arrays
2227+  2F5F E5                  PUSH    HL              ; Save end of arrays
2228+  2F60 09                  ADD     HL,BC           ; Move up 6 bytes
2229+  2F61 C1                  POP     BC              ; Source address in BC
2230+  2F62 E5                  PUSH    HL              ; Save new end address
2231+  2F63 CD CF 23            CALL    MOVUP           ; Move arrays up
2232+  2F66 E1                  POP     HL              ; Restore new end address
2233+  2F67 22 AA 41            LD      (ARREND),HL     ; Set new end address
2234+  2F6A 60                  LD      H,B             ; End of variables to HL
2235+  2F6B 69                  LD      L,C
2236+  2F6C 22 A8 41            LD      (VAREND),HL     ; Set new end address
2237+  2F6F             
2238+  2F6F 2B          ZEROLP: DEC     HL              ; Back through to zero variable
2239+  2F70 36 00               LD      (HL),0          ; Zero byte in variable
2240+  2F72 CD DA 26            CALL    CPDEHL          ; Done them all?
2241+  2F75 C2 6F 2F            JP      NZ,ZEROLP       ; No - Keep on going
2242+  2F78 D1                  POP     DE              ; Get variable name
2243+  2F79 73                  LD      (HL),E          ; Store second character
2244+  2F7A 23                  INC     HL
2245+  2F7B 72                  LD      (HL),D          ; Store first character
2246+  2F7C 23                  INC     HL
2247+  2F7D EB          RETADR: EX      DE,HL           ; Address of variable in DE
2248+  2F7E E1                  POP     HL              ; Restore code string address
2249+  2F7F C9                  RET
2250+  2F80             
2251+  2F80 32 B7 41    RETNUL: LD      (FPEXP),A       ; Set result to zero
2252+  2F83 21 9C 23            LD      HL,ZERBYT       ; Also set a null string
2253+  2F86 22 B4 41            LD      (FPREG),HL      ; Save for EVAL
2254+  2F89 E1                  POP     HL              ; Restore code string address
2255+  2F8A C9                  RET
2256+  2F8B             
2257+  2F8B E5          SBSCPT: PUSH    HL              ; Save code string address
2258+  2F8C 2A 7C 41            LD      HL,(LCRFLG)     ; Locate/Create and Type
2259+  2F8F E3                  EX      (SP),HL         ; Save and get code string
2260+  2F90 57                  LD      D,A             ; Zero number of dimensions
2261+  2F91 D5          SCPTLP: PUSH    DE              ; Save number of dimensions
2262+  2F92 C5                  PUSH    BC              ; Save array name
2263+  2F93 CD 11 29            CALL    FPSINT          ; Get subscript (0-32767)
2264+  2F96 C1                  POP     BC              ; Restore array name
2265+  2F97 F1                  POP     AF              ; Get number of dimensions
2266+  2F98 EB                  EX      DE,HL
2267+  2F99 E3                  EX      (SP),HL         ; Save subscript value
2268+  2F9A E5                  PUSH    HL              ; Save LCRFLG and TYPE
2269+  2F9B EB                  EX      DE,HL
2270+  2F9C 3C                  INC     A               ; Count dimensions
2271+  2F9D 57                  LD      D,A             ; Save in D
2272+  2F9E 7E                  LD      A,(HL)          ; Get next byte in code string
2273+  2F9F FE 2C               CP      ','             ; Comma (more to come)?
2274+  2FA1 CA 91 2F            JP      Z,SCPTLP        ; Yes - More subscripts
2275+  2FA4 CD E0 26            CALL    CHKSYN          ; Make sure ")" follows
2276+  2FA7 29                  .BYTE      ")"
2277+  2FA8 22 A0 41            LD      (NXTOPR),HL     ; Save code string address
2278+  2FAB E1                  POP     HL              ; Get LCRFLG and TYPE
2279+  2FAC 22 7C 41            LD      (LCRFLG),HL     ; Restore Locate/create & type
2280+  2FAF 1E 00               LD      E,0             ; Flag not CSAVE* or CLOAD*
2281+  2FB1 D5                  PUSH    DE              ; Save number of dimensions (D)
2282+  2FB2 11                  .BYTE      11H             ; Skip "PUSH HL" and "PUSH AF'
2283+  2FB3             
2284+  2FB3 E5          ARLDSV: PUSH    HL              ; Save code string address
2285+  2FB4 F5                  PUSH    AF              ; A = 00 , Flags set = Z,N
2286+  2FB5 2A A8 41            LD      HL,(VAREND)     ; Start of arrays
2287+  2FB8 3E                  .BYTE      3EH             ; Skip "ADD HL,DE"
2288+  2FB9 19          FNDARY: ADD     HL,DE           ; Move to next array start
2289+  2FBA EB                  EX      DE,HL
2290+  2FBB 2A AA 41            LD      HL,(ARREND)     ; End of arrays
2291+  2FBE EB                  EX      DE,HL           ; Current array pointer
2292+  2FBF CD DA 26            CALL    CPDEHL          ; End of arrays found?
2293+  2FC2 CA EB 2F            JP      Z,CREARY        ; Yes - Create array
2294+  2FC5 7E                  LD      A,(HL)          ; Get second byte of name
2295+  2FC6 B9                  CP      C               ; Compare with name given
2296+  2FC7 23                  INC     HL              ; Move on
2297+  2FC8 C2 CD 2F            JP      NZ,NXTARY       ; Different - Find next array
2298+  2FCB 7E                  LD      A,(HL)          ; Get first byte of name
2299+  2FCC B8                  CP      B               ; Compare with name given
2300+  2FCD 23          NXTARY: INC     HL              ; Move on
2301+  2FCE 5E                  LD      E,(HL)          ; Get LSB of next array address
2302+  2FCF 23                  INC     HL
2303+  2FD0 56                  LD      D,(HL)          ; Get MSB of next array address
2304+  2FD1 23                  INC     HL
2305+  2FD2 C2 B9 2F            JP      NZ,FNDARY       ; Not found - Keep looking
2306+  2FD5 3A 7C 41            LD      A,(LCRFLG)      ; Found Locate or Create it?
2307+  2FD8 B7                  OR      A
2308+  2FD9 C2 0F 24            JP      NZ,DDERR        ; Create - ?DD Error
2309+  2FDC F1                  POP     AF              ; Locate - Get number of dim'ns
2310+  2FDD 44                  LD      B,H             ; BC Points to array dim'ns
2311+  2FDE 4D                  LD      C,L
2312+  2FDF CA 1F 36            JP      Z,POPHRT        ; Jump if array load/save
2313+  2FE2 96                  SUB     (HL)            ; Same number of dimensions?
2314+  2FE3 CA 49 30            JP      Z,FINDEL        ; Yes - Find element
2315+  2FE6 1E 2A       BSERR:  LD      E,BS            ; ?BS Error
2316+  2FE8 C3 1E 24            JP      ERROR           ; Output error
2317+  2FEB             
2318+  2FEB 11 04 00    CREARY: LD      DE,4            ; 4 Bytes per entry
2319+  2FEE F1                  POP     AF              ; Array to save or 0 dim'ns?
2320+  2FEF CA 32 29            JP      Z,FCERR         ; Yes - ?FC Error
2321+  2FF2 71                  LD      (HL),C          ; Save second byte of name
2322+  2FF3 23                  INC     HL
2323+  2FF4 70                  LD      (HL),B          ; Save first byte of name
2324+  2FF5 23                  INC     HL
2325+  2FF6 4F                  LD      C,A             ; Number of dimensions to C
2326+  2FF7 CD E0 23            CALL    CHKSTK          ; Check if enough memory
2327+  2FFA 23                  INC     HL              ; Point to number of dimensions
2328+  2FFB 23                  INC     HL
2329+  2FFC 22 95 41            LD      (CUROPR),HL     ; Save address of pointer
2330+  2FFF 71                  LD      (HL),C          ; Set number of dimensions
2331+  3000 23                  INC     HL
2332+  3001 3A 7C 41            LD      A,(LCRFLG)      ; Locate of Create?
2333+  3004 17                  RLA                     ; Carry set = Create
2334+  3005 79                  LD      A,C             ; Get number of dimensions
2335+  3006 01 0B 00    CRARLP: LD      BC,10+1         ; Default dimension size 10
2336+  3009 D2 0E 30            JP      NC,DEFSIZ       ; Locate - Set default size
2337+  300C C1                  POP     BC              ; Get specified dimension size
2338+  300D 03                  INC     BC              ; Include zero element
2339+  300E 71          DEFSIZ: LD      (HL),C          ; Save LSB of dimension size
2340+  300F 23                  INC     HL
2341+  3010 70                  LD      (HL),B          ; Save MSB of dimension size
2342+  3011 23                  INC     HL
2343+  3012 F5                  PUSH    AF              ; Save num' of dim'ns an status
2344+  3013 E5                  PUSH    HL              ; Save address of dim'n size
2345+  3014 CD CA 37            CALL    MLDEBC          ; Multiply DE by BC to find
2346+  3017 EB                  EX      DE,HL           ; amount of mem needed (to DE)
2347+  3018 E1                  POP     HL              ; Restore address of dimension
2348+  3019 F1                  POP     AF              ; Restore number of dimensions
2349+  301A 3D                  DEC     A               ; Count them
2350+  301B C2 06 30            JP      NZ,CRARLP       ; Do next dimension if more
2351+  301E F5                  PUSH    AF              ; Save locate/create flag
2352+  301F 42                  LD      B,D             ; MSB of memory needed
2353+  3020 4B                  LD      C,E             ; LSB of memory needed
2354+  3021 EB                  EX      DE,HL
2355+  3022 19                  ADD     HL,DE           ; Add bytes to array start
2356+  3023 DA F8 23            JP      C,OMERR         ; Too big - Error
2357+  3026 CD E9 23            CALL    ENFMEM          ; See if enough memory
2358+  3029 22 AA 41            LD      (ARREND),HL     ; Save new end of array
2359+  302C             
2360+  302C 2B          ZERARY: DEC     HL              ; Back through array data
2361+  302D 36 00               LD      (HL),0          ; Set array element to zero
2362+  302F CD DA 26            CALL    CPDEHL          ; All elements zeroed?
2363+  3032 C2 2C 30            JP      NZ,ZERARY       ; No - Keep on going
2364+  3035 03                  INC     BC              ; Number of bytes + 1
2365+  3036 57                  LD      D,A             ; A=0
2366+  3037 2A 95 41            LD      HL,(CUROPR)     ; Get address of array
2367+  303A 5E                  LD      E,(HL)          ; Number of dimensions
2368+  303B EB                  EX      DE,HL           ; To HL
2369+  303C 29                  ADD     HL,HL           ; Two bytes per dimension size
2370+  303D 09                  ADD     HL,BC           ; Add number of bytes
2371+  303E EB                  EX      DE,HL           ; Bytes needed to DE
2372+  303F 2B                  DEC     HL
2373+  3040 2B                  DEC     HL
2374+  3041 73                  LD      (HL),E          ; Save LSB of bytes needed
2375+  3042 23                  INC     HL
2376+  3043 72                  LD      (HL),D          ; Save MSB of bytes needed
2377+  3044 23                  INC     HL
2378+  3045 F1                  POP     AF              ; Locate / Create?
2379+  3046 DA 6D 30            JP      C,ENDDIM        ; A is 0 , End if create
2380+  3049 47          FINDEL: LD      B,A             ; Find array element
2381+  304A 4F                  LD      C,A
2382+  304B 7E                  LD      A,(HL)          ; Number of dimensions
2383+  304C 23                  INC     HL
2384+  304D 16                  .BYTE      16H             ; Skip "POP HL"
2385+  304E E1          FNDELP: POP     HL              ; Address of next dim' size
2386+  304F 5E                  LD      E,(HL)          ; Get LSB of dim'n size
2387+  3050 23                  INC     HL
2388+  3051 56                  LD      D,(HL)          ; Get MSB of dim'n size
2389+  3052 23                  INC     HL
2390+  3053 E3                  EX      (SP),HL         ; Save address - Get index
2391+  3054 F5                  PUSH    AF              ; Save number of dim'ns
2392+  3055 CD DA 26            CALL    CPDEHL          ; Dimension too large?
2393+  3058 D2 E6 2F            JP      NC,BSERR        ; Yes - ?BS Error
2394+  305B E5                  PUSH    HL              ; Save index
2395+  305C CD CA 37            CALL    MLDEBC          ; Multiply previous by size
2396+  305F D1                  POP     DE              ; Index supplied to DE
2397+  3060 19                  ADD     HL,DE           ; Add index to pointer
2398+  3061 F1                  POP     AF              ; Number of dimensions
2399+  3062 3D                  DEC     A               ; Count them
2400+  3063 44                  LD      B,H             ; MSB of pointer
2401+  3064 4D                  LD      C,L             ; LSB of pointer
2402+  3065 C2 4E 30            JP      NZ,FNDELP       ; More - Keep going
2403+  3068 29                  ADD     HL,HL           ; 4 Bytes per element
2404+  3069 29                  ADD     HL,HL
2405+  306A C1                  POP     BC              ; Start of array
2406+  306B 09                  ADD     HL,BC           ; Point to element
2407+  306C EB                  EX      DE,HL           ; Address of element to DE
2408+  306D 2A A0 41    ENDDIM: LD      HL,(NXTOPR)     ; Got code string address
2409+  3070 C9                  RET
2410+  3071             
2411+  3071 2A AA 41    FRE:    LD      HL,(ARREND)     ; Start of free memory
2412+  3074 EB                  EX      DE,HL           ; To DE
2413+  3075 21 00 00            LD      HL,0            ; End of free memory
2414+  3078 39                  ADD     HL,SP           ; Current stack value
2415+  3079 3A 7D 41            LD      A,(TYPE)        ; Dummy argument type
2416+  307C B7                  OR      A
2417+  307D CA 8D 30            JP      Z,FRENUM        ; Numeric - Free variable space
2418+  3080 CD F4 32            CALL    GSTRCU          ; Current string to pool
2419+  3083 CD F4 31            CALL    GARBGE          ; Garbage collection
2420+  3086 2A 2A 41            LD      HL,(STRSPC)     ; Bottom of string space in use
2421+  3089 EB                  EX      DE,HL           ; To DE
2422+  308A 2A 93 41            LD      HL,(STRBOT)     ; Bottom of string space
2423+  308D 7D          FRENUM: LD      A,L             ; Get LSB of end
2424+  308E 93                  SUB     E               ; Subtract LSB of beginning
2425+  308F 4F                  LD      C,A             ; Save difference if C
2426+  3090 7C                  LD      A,H             ; Get MSB of end
2427+  3091 9A                  SBC     A,D             ; Subtract MSB of beginning
2428+  3092 41          ACPASS: LD      B,C             ; Return integer AC
2429+  3093 50          ABPASS: LD      D,B             ; Return integer AB
2430+  3094 1E 00               LD      E,0
2431+  3096 21 7D 41            LD      HL,TYPE         ; Point to type
2432+  3099 73                  LD      (HL),E          ; Set type to numeric
2433+  309A 06 90               LD      B,80H+16        ; 16 bit integer
2434+  309C C3 F5 36            JP      RETINT          ; Return the integr
2435+  309F             
2436+  309F 3A 7B 41    POS:    LD      A,(CURPOS)      ; Get cursor position
2437+  30A2 47          PASSA:  LD      B,A             ; Put A into AB
2438+  30A3 AF                  XOR     A               ; Zero A
2439+  30A4 C3 93 30            JP      ABPASS          ; Return integer AB
2440+  30A7             
2441+  30A7 CD 2A 31    DEF:    CALL    CHEKFN          ; Get "FN" and name
2442+  30AA CD 1C 31            CALL    IDTEST          ; Test for illegal direct
2443+  30AD 01 02 2A            LD      BC,DATA         ; To get next statement
2444+  30B0 C5                  PUSH    BC              ; Save address for RETurn
2445+  30B1 D5                  PUSH    DE              ; Save address of function ptr
2446+  30B2 CD E0 26            CALL    CHKSYN          ; Make sure "(" follows
2447+  30B5 28                  .BYTE      "("
2448+  30B6 CD CE 2E            CALL    GETVAR          ; Get argument variable name
2449+  30B9 E5                  PUSH    HL              ; Save code string address
2450+  30BA EB                  EX      DE,HL           ; Argument address to HL
2451+  30BB 2B                  DEC     HL
2452+  30BC 56                  LD      D,(HL)          ; Get first byte of arg name
2453+  30BD 2B                  DEC     HL
2454+  30BE 5E                  LD      E,(HL)          ; Get second byte of arg name
2455+  30BF E1                  POP     HL              ; Restore code string address
2456+  30C0 CD DB 2C            CALL    TSTNUM          ; Make sure numeric argument
2457+  30C3 CD E0 26            CALL    CHKSYN          ; Make sure ")" follows
2458+  30C6 29                  .BYTE      ")"
2459+  30C7 CD E0 26            CALL    CHKSYN          ; Make sure "=" follows
2460+  30CA B4                  .BYTE      ZEQUAL          ; "=" token
2461+  30CB 44                  LD      B,H             ; Code string address to BC
2462+  30CC 4D                  LD      C,L
2463+  30CD E3                  EX      (SP),HL         ; Save code str , Get FN ptr
2464+  30CE 71                  LD      (HL),C          ; Save LSB of FN code string
2465+  30CF 23                  INC     HL
2466+  30D0 70                  LD      (HL),B          ; Save MSB of FN code string
2467+  30D1 C3 69 31            JP      SVSTAD          ; Save address and do function
2468+  30D4             
2469+  30D4 CD 2A 31    DOFN:   CALL    CHEKFN          ; Make sure FN follows
2470+  30D7 D5                  PUSH    DE              ; Save function pointer address
2471+  30D8 CD AF 2D            CALL    EVLPAR          ; Evaluate expression in "()"
2472+  30DB CD DB 2C            CALL    TSTNUM          ; Make sure numeric result
2473+  30DE E3                  EX      (SP),HL         ; Save code str , Get FN ptr
2474+  30DF 5E                  LD      E,(HL)          ; Get LSB of FN code string
2475+  30E0 23                  INC     HL
2476+  30E1 56                  LD      D,(HL)          ; Get MSB of FN code string
2477+  30E2 23                  INC     HL
2478+  30E3 7A                  LD      A,D             ; And function DEFined?
2479+  30E4 B3                  OR      E
2480+  30E5 CA 13 24            JP      Z,UFERR         ; No - ?UF Error
2481+  30E8 7E                  LD      A,(HL)          ; Get LSB of argument address
2482+  30E9 23                  INC     HL
2483+  30EA 66                  LD      H,(HL)          ; Get MSB of argument address
2484+  30EB 6F                  LD      L,A             ; HL = Arg variable address
2485+  30EC E5                  PUSH    HL              ; Save it
2486+  30ED 2A AE 41            LD      HL,(FNRGNM)     ; Get old argument name
2487+  30F0 E3                  EX      (SP),HL ;       ; Save old , Get new
2488+  30F1 22 AE 41            LD      (FNRGNM),HL     ; Set new argument name
2489+  30F4 2A B2 41            LD      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
2490+  30F7 E5                  PUSH    HL              ; Save it
2491+  30F8 2A B0 41            LD      HL,(FNARG)      ; Get MSB,EXP of old arg value
2492+  30FB E5                  PUSH    HL              ; Save it
2493+  30FC 21 B0 41            LD      HL,FNARG        ; HL = Value of argument
2494+  30FF D5                  PUSH    DE              ; Save FN code string address
2495+  3100 CD 36 37            CALL    FPTHL           ; Move FPREG to argument
2496+  3103 E1                  POP     HL              ; Get FN code string address
2497+  3104 CD D8 2C            CALL    GETNUM          ; Get value from function
2498+  3107 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
2499+  3108 CD 6A 28            CALL    GETCHR          ; Get next character
2500+  310B C2 03 24            JP      NZ,SNERR        ; Bad character in FN - Error
2501+  310E E1                  POP     HL              ; Get MSB,EXP of old arg
2502+  310F 22 B0 41            LD      (FNARG),HL      ; Restore it
2503+  3112 E1                  POP     HL              ; Get LSB,NLSB of old arg
2504+  3113 22 B2 41            LD      (FNARG+2),HL    ; Restore it
2505+  3116 E1                  POP     HL              ; Get name of old arg
2506+  3117 22 AE 41            LD      (FNRGNM),HL     ; Restore it
2507+  311A E1                  POP     HL              ; Restore code string address
2508+  311B C9                  RET
2509+  311C             
2510+  311C E5          IDTEST: PUSH    HL              ; Save code string address
2511+  311D 2A 2C 41            LD      HL,(LINEAT)     ; Get current line number
2512+  3120 23                  INC     HL              ; -1 means direct statement
2513+  3121 7C                  LD      A,H
2514+  3122 B5                  OR      L
2515+  3123 E1                  POP     HL              ; Restore code string address
2516+  3124 C0                  RET     NZ              ; Return if in program
2517+  3125 1E 33               LD      E,ID            ; ?ID Error
2518+  3127 C3 1E 24            JP      ERROR
2519+  312A             
2520+  312A CD E0 26    CHEKFN: CALL    CHKSYN          ; Make sure FN follows
2521+  312D A7                  .BYTE      ZFN             ; "FN" token
2522+  312E 3E 80               LD      A,80H
2523+  3130 32 9B 41            LD      (FORFLG),A      ; Flag FN name to find
2524+  3133 B6                  OR      (HL)            ; FN name has bit 7 set
2525+  3134 47                  LD      B,A             ; in first byte of name
2526+  3135 CD D3 2E            CALL    GTFNAM          ; Get FN name
2527+  3138 C3 DB 2C            JP      TSTNUM          ; Make sure numeric function
2528+  313B             
2529+  313B CD DB 2C    STR:    CALL    TSTNUM          ; Make sure it's a number
2530+  313E CD 83 38            CALL    NUMASC          ; Turn number into text
2531+  3141 CD 6F 31    STR1:   CALL    CRTST           ; Create string entry for it
2532+  3144 CD F4 32            CALL    GSTRCU          ; Current string to pool
2533+  3147 01 4F 33            LD      BC,TOPOOL       ; Save in string pool
2534+  314A C5                  PUSH    BC              ; Save address on stack
2535+  314B             
2536+  314B 7E          SAVSTR: LD      A,(HL)          ; Get string length
2537+  314C 23                  INC     HL
2538+  314D 23                  INC     HL
2539+  314E E5                  PUSH    HL              ; Save pointer to string
2540+  314F CD CA 31            CALL    TESTR           ; See if enough string space
2541+  3152 E1                  POP     HL              ; Restore pointer to string
2542+  3153 4E                  LD      C,(HL)          ; Get LSB of address
2543+  3154 23                  INC     HL
2544+  3155 46                  LD      B,(HL)          ; Get MSB of address
2545+  3156 CD 63 31            CALL    CRTMST          ; Create string entry
2546+  3159 E5                  PUSH    HL              ; Save pointer to MSB of addr
2547+  315A 6F                  LD      L,A             ; Length of string
2548+  315B CD E7 32            CALL    TOSTRA          ; Move to string area
2549+  315E D1                  POP     DE              ; Restore pointer to MSB
2550+  315F C9                  RET
2551+  3160             
2552+  3160 CD CA 31    MKTMST: CALL    TESTR           ; See if enough string space
2553+  3163 21 8F 41    CRTMST: LD      HL,TMPSTR       ; Temporary string
2554+  3166 E5                  PUSH    HL              ; Save it
2555+  3167 77                  LD      (HL),A          ; Save length of string
2556+  3168 23                  INC     HL
2557+  3169 23          SVSTAD: INC     HL
2558+  316A 73                  LD      (HL),E          ; Save LSB of address
2559+  316B 23                  INC     HL
2560+  316C 72                  LD      (HL),D          ; Save MSB of address
2561+  316D E1                  POP     HL              ; Restore pointer
2562+  316E C9                  RET
2563+  316F             
2564+  316F 2B          CRTST:  DEC     HL              ; DEC - INCed after
2565+  3170 06 22       QTSTR:  LD      B,'"'           ; Terminating quote
2566+  3172 50                  LD      D,B             ; Quote to D
2567+  3173 E5          DTSTR:  PUSH    HL              ; Save start
2568+  3174 0E FF               LD      C,-1            ; Set counter to -1
2569+  3176 23          QTSTLP: INC     HL              ; Move on
2570+  3177 7E                  LD      A,(HL)          ; Get byte
2571+  3178 0C                  INC     C               ; Count bytes
2572+  3179 B7                  OR      A               ; End of line?
2573+  317A CA 85 31            JP      Z,CRTSTE        ; Yes - Create string entry
2574+  317D BA                  CP      D               ; Terminator D found?
2575+  317E CA 85 31            JP      Z,CRTSTE        ; Yes - Create string entry
2576+  3181 B8                  CP      B               ; Terminator B found?
2577+  3182 C2 76 31            JP      NZ,QTSTLP       ; No - Keep looking
2578+  3185 FE 22       CRTSTE: CP      '"'             ; End with '"'?
2579+  3187 CC 6A 28            CALL    Z,GETCHR        ; Yes - Get next character
2580+  318A E3                  EX      (SP),HL         ; Starting quote
2581+  318B 23                  INC     HL              ; First byte of string
2582+  318C EB                  EX      DE,HL           ; To DE
2583+  318D 79                  LD      A,C             ; Get length
2584+  318E CD 63 31            CALL    CRTMST          ; Create string entry
2585+  3191 11 8F 41    TSTOPL: LD      DE,TMPSTR       ; Temporary string
2586+  3194 2A 81 41            LD      HL,(TMSTPT)     ; Temporary string pool pointer
2587+  3197 22 B4 41            LD      (FPREG),HL      ; Save address of string ptr
2588+  319A 3E 01               LD      A,1
2589+  319C 32 7D 41            LD      (TYPE),A        ; Set type to string
2590+  319F CD 39 37            CALL    DETHL4          ; Move string to pool
2591+  31A2 CD DA 26            CALL    CPDEHL          ; Out of string pool?
2592+  31A5 22 81 41            LD      (TMSTPT),HL     ; Save new pointer
2593+  31A8 E1                  POP     HL              ; Restore code string address
2594+  31A9 7E                  LD      A,(HL)          ; Get next code byte
2595+  31AA C0                  RET     NZ              ; Return if pool OK
2596+  31AB 1E 3F               LD      E,ST            ; ?ST Error
2597+  31AD C3 1E 24            JP      ERROR           ; String pool overflow
2598+  31B0             
2599+  31B0 23          PRNUMS: INC     HL              ; Skip leading space
2600+  31B1 CD 6F 31    PRS:    CALL    CRTST           ; Create string entry for it
2601+  31B4 CD F4 32    PRS1:   CALL    GSTRCU          ; Current string to pool
2602+  31B7 CD 2D 37            CALL    LOADFP          ; Move string block to BCDE
2603+  31BA 1C                  INC     E               ; Length + 1
2604+  31BB 1D          PRSLP:  DEC     E               ; Count characters
2605+  31BC C8                  RET     Z               ; End of string
2606+  31BD 0A                  LD      A,(BC)          ; Get byte to output
2607+  31BE CD EB 26            CALL    OUTC            ; Output character in A
2608+  31C1 FE 0D               CP      CR              ; Return?
2609+  31C3 CC 1D 2B            CALL    Z,DONULL        ; Yes - Do nulls
2610+  31C6 03                  INC     BC              ; Next byte in string
2611+  31C7 C3 BB 31            JP      PRSLP           ; More characters to output
2612+  31CA             
2613+  31CA B7          TESTR:  OR      A               ; Test if enough room
2614+  31CB 0E                  .BYTE      0EH             ; No garbage collection done
2615+  31CC F1          GRBDON: POP     AF              ; Garbage collection done
2616+  31CD F5                  PUSH    AF              ; Save status
2617+  31CE 2A 2A 41            LD      HL,(STRSPC)     ; Bottom of string space in use
2618+  31D1 EB                  EX      DE,HL           ; To DE
2619+  31D2 2A 93 41            LD      HL,(STRBOT)     ; Bottom of string area
2620+  31D5 2F                  CPL                     ; Negate length (Top down)
2621+  31D6 4F                  LD      C,A             ; -Length to BC
2622+  31D7 06 FF               LD      B,-1            ; BC = -ve length of string
2623+  31D9 09                  ADD     HL,BC           ; Add to bottom of space in use
2624+  31DA 23                  INC     HL              ; Plus one for 2's complement
2625+  31DB CD DA 26            CALL    CPDEHL          ; Below string RAM area?
2626+  31DE DA E8 31            JP      C,TESTOS        ; Tidy up if not done else err
2627+  31E1 22 93 41            LD      (STRBOT),HL     ; Save new bottom of area
2628+  31E4 23                  INC     HL              ; Point to first byte of string
2629+  31E5 EB                  EX      DE,HL           ; Address to DE
2630+  31E6 F1          POPAF:  POP     AF              ; Throw away status push
2631+  31E7 C9                  RET
2632+  31E8             
2633+  31E8 F1          TESTOS: POP     AF              ; Garbage collect been done?
2634+  31E9 1E 39               LD      E,OS            ; ?OS Error
2635+  31EB CA 1E 24            JP      Z,ERROR         ; Yes - Not enough string apace
2636+  31EE BF                  CP      A               ; Flag garbage collect done
2637+  31EF F5                  PUSH    AF              ; Save status
2638+  31F0 01 CC 31            LD      BC,GRBDON       ; Garbage collection done
2639+  31F3 C5                  PUSH    BC              ; Save for RETurn
2640+  31F4 2A 7F 41    GARBGE: LD      HL,(LSTRAM)     ; Get end of RAM pointer
2641+  31F7 22 93 41    GARBLP: LD      (STRBOT),HL     ; Reset string pointer
2642+  31FA 21 00 00            LD      HL,0
2643+  31FD E5                  PUSH    HL              ; Flag no string found
2644+  31FE 2A 2A 41            LD      HL,(STRSPC)     ; Get bottom of string space
2645+  3201 E5                  PUSH    HL              ; Save bottom of string space
2646+  3202 21 83 41            LD      HL,TMSTPL       ; Temporary string pool
2647+  3205 EB          GRBLP:  EX      DE,HL
2648+  3206 2A 81 41            LD      HL,(TMSTPT)     ; Temporary string pool pointer
2649+  3209 EB                  EX      DE,HL
2650+  320A CD DA 26            CALL    CPDEHL          ; Temporary string pool done?
2651+  320D 01 05 32            LD      BC,GRBLP        ; Loop until string pool done
2652+  3210 C2 59 32            JP      NZ,STPOOL       ; No - See if in string area
2653+  3213 2A A6 41            LD      HL,(PROGND)     ; Start of simple variables
2654+  3216 EB          SMPVAR: EX      DE,HL
2655+  3217 2A A8 41            LD      HL,(VAREND)     ; End of simple variables
2656+  321A EB                  EX      DE,HL
2657+  321B CD DA 26            CALL    CPDEHL          ; All simple strings done?
2658+  321E CA 2C 32            JP      Z,ARRLP         ; Yes - Do string arrays
2659+  3221 7E                  LD      A,(HL)          ; Get type of variable
2660+  3222 23                  INC     HL
2661+  3223 23                  INC     HL
2662+  3224 B7                  OR      A               ; "S" flag set if string
2663+  3225 CD 5C 32            CALL    STRADD          ; See if string in string area
2664+  3228 C3 16 32            JP      SMPVAR          ; Loop until simple ones done
2665+  322B             
2666+  322B C1          GNXARY: POP     BC              ; Scrap address of this array
2667+  322C EB          ARRLP:  EX      DE,HL
2668+  322D 2A AA 41            LD      HL,(ARREND)     ; End of string arrays
2669+  3230 EB                  EX      DE,HL
2670+  3231 CD DA 26            CALL    CPDEHL          ; All string arrays done?
2671+  3234 CA 82 32            JP      Z,SCNEND        ; Yes - Move string if found
2672+  3237 CD 2D 37            CALL    LOADFP          ; Get array name to BCDE
2673+  323A 7B                  LD      A,E             ; Get type of array     
2674+  323B E5                  PUSH    HL              ; Save address of num of dim'ns
2675+  323C 09                  ADD     HL,BC           ; Start of next array
2676+  323D B7                  OR      A               ; Test type of array
2677+  323E F2 2B 32            JP      P,GNXARY        ; Numeric array - Ignore it
2678+  3241 22 95 41            LD      (CUROPR),HL     ; Save address of next array
2679+  3244 E1                  POP     HL              ; Get address of num of dim'ns
2680+  3245 4E                  LD      C,(HL)          ; BC = Number of dimensions
2681+  3246 06 00               LD      B,0
2682+  3248 09                  ADD     HL,BC           ; Two bytes per dimension size
2683+  3249 09                  ADD     HL,BC
2684+  324A 23                  INC     HL              ; Plus one for number of dim'ns
2685+  324B EB          GRBARY: EX      DE,HL
2686+  324C 2A 95 41            LD      HL,(CUROPR)     ; Get address of next array
2687+  324F EB                  EX      DE,HL
2688+  3250 CD DA 26            CALL    CPDEHL          ; Is this array finished?
2689+  3253 CA 2C 32            JP      Z,ARRLP         ; Yes - Get next one
2690+  3256 01 4B 32            LD      BC,GRBARY       ; Loop until array all done
2691+  3259 C5          STPOOL: PUSH    BC              ; Save return address
2692+  325A F6 80               OR      80H             ; Flag string type
2693+  325C 7E          STRADD: LD      A,(HL)          ; Get string length
2694+  325D 23                  INC     HL
2695+  325E 23                  INC     HL
2696+  325F 5E                  LD      E,(HL)          ; Get LSB of string address
2697+  3260 23                  INC     HL
2698+  3261 56                  LD      D,(HL)          ; Get MSB of string address
2699+  3262 23                  INC     HL
2700+  3263 F0                  RET     P               ; Not a string - Return
2701+  3264 B7                  OR      A               ; Set flags on string length
2702+  3265 C8                  RET     Z               ; Null string - Return
2703+  3266 44                  LD      B,H             ; Save variable pointer
2704+  3267 4D                  LD      C,L
2705+  3268 2A 93 41            LD      HL,(STRBOT)     ; Bottom of new area
2706+  326B CD DA 26            CALL    CPDEHL          ; String been done?
2707+  326E 60                  LD      H,B             ; Restore variable pointer
2708+  326F 69                  LD      L,C
2709+  3270 D8                  RET     C               ; String done - Ignore
2710+  3271 E1                  POP     HL              ; Return address
2711+  3272 E3                  EX      (SP),HL         ; Lowest available string area
2712+  3273 CD DA 26            CALL    CPDEHL          ; String within string area?
2713+  3276 E3                  EX      (SP),HL         ; Lowest available string area
2714+  3277 E5                  PUSH    HL              ; Re-save return address
2715+  3278 60                  LD      H,B             ; Restore variable pointer
2716+  3279 69                  LD      L,C
2717+  327A D0                  RET     NC              ; Outside string area - Ignore
2718+  327B C1                  POP     BC              ; Get return , Throw 2 away
2719+  327C F1                  POP     AF              ; 
2720+  327D F1                  POP     AF              ; 
2721+  327E E5                  PUSH    HL              ; Save variable pointer
2722+  327F D5                  PUSH    DE              ; Save address of current
2723+  3280 C5                  PUSH    BC              ; Put back return address
2724+  3281 C9                  RET                     ; Go to it
2725+  3282             
2726+  3282 D1          SCNEND: POP     DE              ; Addresses of strings
2727+  3283 E1                  POP     HL              ; 
2728+  3284 7D                  LD      A,L             ; HL = 0 if no more to do
2729+  3285 B4                  OR      H
2730+  3286 C8                  RET     Z               ; No more to do - Return
2731+  3287 2B                  DEC     HL
2732+  3288 46                  LD      B,(HL)          ; MSB of address of string
2733+  3289 2B                  DEC     HL
2734+  328A 4E                  LD      C,(HL)          ; LSB of address of string
2735+  328B E5                  PUSH    HL              ; Save variable address
2736+  328C 2B                  DEC     HL
2737+  328D 2B                  DEC     HL
2738+  328E 6E                  LD      L,(HL)          ; HL = Length of string
2739+  328F 26 00               LD      H,0
2740+  3291 09                  ADD     HL,BC           ; Address of end of string+1
2741+  3292 50                  LD      D,B             ; String address to DE
2742+  3293 59                  LD      E,C
2743+  3294 2B                  DEC     HL              ; Last byte in string
2744+  3295 44                  LD      B,H             ; Address to BC
2745+  3296 4D                  LD      C,L
2746+  3297 2A 93 41            LD      HL,(STRBOT)     ; Current bottom of string area
2747+  329A CD D2 23            CALL    MOVSTR          ; Move string to new address
2748+  329D E1                  POP     HL              ; Restore variable address
2749+  329E 71                  LD      (HL),C          ; Save new LSB of address
2750+  329F 23                  INC     HL
2751+  32A0 70                  LD      (HL),B          ; Save new MSB of address
2752+  32A1 69                  LD      L,C             ; Next string area+1 to HL
2753+  32A2 60                  LD      H,B
2754+  32A3 2B                  DEC     HL              ; Next string area address
2755+  32A4 C3 F7 31            JP      GARBLP          ; Look for more strings
2756+  32A7             
2757+  32A7 C5          CONCAT: PUSH    BC              ; Save prec' opr & code string
2758+  32A8 E5                  PUSH    HL              ; 
2759+  32A9 2A B4 41            LD      HL,(FPREG)      ; Get first string
2760+  32AC E3                  EX      (SP),HL         ; Save first string
2761+  32AD CD 61 2D            CALL    OPRND           ; Get second string
2762+  32B0 E3                  EX      (SP),HL         ; Restore first string
2763+  32B1 CD DC 2C            CALL    TSTSTR          ; Make sure it's a string
2764+  32B4 7E                  LD      A,(HL)          ; Get length of second string
2765+  32B5 E5                  PUSH    HL              ; Save first string
2766+  32B6 2A B4 41            LD      HL,(FPREG)      ; Get second string
2767+  32B9 E5                  PUSH    HL              ; Save second string
2768+  32BA 86                  ADD     A,(HL)          ; Add length of second string
2769+  32BB 1E 3C               LD      E,LS            ; ?LS Error
2770+  32BD DA 1E 24            JP      C,ERROR         ; String too long - Error
2771+  32C0 CD 60 31            CALL    MKTMST          ; Make temporary string
2772+  32C3 D1                  POP     DE              ; Get second string to DE
2773+  32C4 CD F8 32            CALL    GSTRDE          ; Move to string pool if needed
2774+  32C7 E3                  EX      (SP),HL         ; Get first string
2775+  32C8 CD F7 32            CALL    GSTRHL          ; Move to string pool if needed
2776+  32CB E5                  PUSH    HL              ; Save first string
2777+  32CC 2A 91 41            LD      HL,(TMPSTR+2)   ; Temporary string address
2778+  32CF EB                  EX      DE,HL           ; To DE
2779+  32D0 CD DE 32            CALL    SSTSA           ; First string to string area
2780+  32D3 CD DE 32            CALL    SSTSA           ; Second string to string area
2781+  32D6 21 F6 2C            LD      HL,EVAL2        ; Return to evaluation loop
2782+  32D9 E3                  EX      (SP),HL         ; Save return,get code string
2783+  32DA E5                  PUSH    HL              ; Save code string address
2784+  32DB C3 91 31            JP      TSTOPL          ; To temporary string to pool
2785+  32DE             
2786+  32DE E1          SSTSA:  POP     HL              ; Return address
2787+  32DF E3                  EX      (SP),HL         ; Get string block,save return
2788+  32E0 7E                  LD      A,(HL)          ; Get length of string
2789+  32E1 23                  INC     HL
2790+  32E2 23                  INC     HL
2791+  32E3 4E                  LD      C,(HL)          ; Get LSB of string address
2792+  32E4 23                  INC     HL
2793+  32E5 46                  LD      B,(HL)          ; Get MSB of string address
2794+  32E6 6F                  LD      L,A             ; Length to L
2795+  32E7 2C          TOSTRA: INC     L               ; INC - DECed after
2796+  32E8 2D          TSALP:  DEC     L               ; Count bytes moved
2797+  32E9 C8                  RET     Z               ; End of string - Return
2798+  32EA 0A                  LD      A,(BC)          ; Get source
2799+  32EB 12                  LD      (DE),A          ; Save destination
2800+  32EC 03                  INC     BC              ; Next source
2801+  32ED 13                  INC     DE              ; Next destination
2802+  32EE C3 E8 32            JP      TSALP           ; Loop until string moved
2803+  32F1             
2804+  32F1 CD DC 2C    GETSTR: CALL    TSTSTR          ; Make sure it's a string
2805+  32F4 2A B4 41    GSTRCU: LD      HL,(FPREG)      ; Get current string
2806+  32F7 EB          GSTRHL: EX      DE,HL           ; Save DE
2807+  32F8 CD 12 33    GSTRDE: CALL    BAKTMP          ; Was it last tmp-str?
2808+  32FB EB                  EX      DE,HL           ; Restore DE
2809+  32FC C0                  RET     NZ              ; No - Return
2810+  32FD D5                  PUSH    DE              ; Save string
2811+  32FE 50                  LD      D,B             ; String block address to DE
2812+  32FF 59                  LD      E,C
2813+  3300 1B                  DEC     DE              ; Point to length
2814+  3301 4E                  LD      C,(HL)          ; Get string length
2815+  3302 2A 93 41            LD      HL,(STRBOT)     ; Current bottom of string area
2816+  3305 CD DA 26            CALL    CPDEHL          ; Last one in string area?
2817+  3308 C2 10 33            JP      NZ,POPHL        ; No - Return
2818+  330B 47                  LD      B,A             ; Clear B (A=0)
2819+  330C 09                  ADD     HL,BC           ; Remove string from str' area
2820+  330D 22 93 41            LD      (STRBOT),HL     ; Save new bottom of str' area
2821+  3310 E1          POPHL:  POP     HL              ; Restore string
2822+  3311 C9                  RET
2823+  3312             
2824+  3312 2A 81 41    BAKTMP: LD      HL,(TMSTPT)     ; Get temporary string pool top
2825+  3315 2B                  DEC     HL              ; Back
2826+  3316 46                  LD      B,(HL)          ; Get MSB of address
2827+  3317 2B                  DEC     HL              ; Back
2828+  3318 4E                  LD      C,(HL)          ; Get LSB of address
2829+  3319 2B                  DEC     HL              ; Back
2830+  331A 2B                  DEC     HL              ; Back
2831+  331B CD DA 26            CALL    CPDEHL          ; String last in string pool?
2832+  331E C0                  RET     NZ              ; Yes - Leave it
2833+  331F 22 81 41            LD      (TMSTPT),HL     ; Save new string pool top
2834+  3322 C9                  RET
2835+  3323             
2836+  3323 01 A2 30    LEN:    LD      BC,PASSA        ; To return integer A
2837+  3326 C5                  PUSH    BC              ; Save address
2838+  3327 CD F1 32    GETLEN: CALL    GETSTR          ; Get string and its length
2839+  332A AF                  XOR     A
2840+  332B 57                  LD      D,A             ; Clear D
2841+  332C 32 7D 41            LD      (TYPE),A        ; Set type to numeric
2842+  332F 7E                  LD      A,(HL)          ; Get length of string
2843+  3330 B7                  OR      A               ; Set status flags
2844+  3331 C9                  RET
2845+  3332             
2846+  3332 01 A2 30    ASC:    LD      BC,PASSA        ; To return integer A
2847+  3335 C5                  PUSH    BC              ; Save address
2848+  3336 CD 27 33    GTFLNM: CALL    GETLEN          ; Get length of string
2849+  3339 CA 32 29            JP      Z,FCERR         ; Null string - Error
2850+  333C 23                  INC     HL
2851+  333D 23                  INC     HL
2852+  333E 5E                  LD      E,(HL)          ; Get LSB of address
2853+  333F 23                  INC     HL
2854+  3340 56                  LD      D,(HL)          ; Get MSB of address
2855+  3341 1A                  LD      A,(DE)          ; Get first byte of string
2856+  3342 C9                  RET
2857+  3343             
2858+  3343 3E 01       CHR:    LD      A,1             ; One character string
2859+  3345 CD 60 31            CALL    MKTMST          ; Make a temporary string
2860+  3348 CD 3C 34            CALL    MAKINT          ; Make it integer A
2861+  334B 2A 91 41            LD      HL,(TMPSTR+2)   ; Get address of string
2862+  334E 73                  LD      (HL),E          ; Save character
2863+  334F C1          TOPOOL: POP     BC              ; Clean up stack
2864+  3350 C3 91 31            JP      TSTOPL          ; Temporary string to pool
2865+  3353             
2866+  3353 CD EC 33    LEFT:   CALL    LFRGNM          ; Get number and ending ")"
2867+  3356 AF                  XOR     A               ; Start at first byte in string
2868+  3357 E3          RIGHT1: EX      (SP),HL         ; Save code string,Get string
2869+  3358 4F                  LD      C,A             ; Starting position in string
2870+  3359 E5          MID1:   PUSH    HL              ; Save string block address
2871+  335A 7E                  LD      A,(HL)          ; Get length of string
2872+  335B B8                  CP      B               ; Compare with number given
2873+  335C DA 61 33            JP      C,ALLFOL        ; All following bytes required
2874+  335F 78                  LD      A,B             ; Get new length
2875+  3360 11                  .BYTE      11H             ; Skip "LD C,0"
2876+  3361 0E 00       ALLFOL: LD      C,0             ; First byte of string
2877+  3363 C5                  PUSH    BC              ; Save position in string
2878+  3364 CD CA 31            CALL    TESTR           ; See if enough string space
2879+  3367 C1                  POP     BC              ; Get position in string
2880+  3368 E1                  POP     HL              ; Restore string block address
2881+  3369 E5                  PUSH    HL              ; And re-save it
2882+  336A 23                  INC     HL
2883+  336B 23                  INC     HL
2884+  336C 46                  LD      B,(HL)          ; Get LSB of address
2885+  336D 23                  INC     HL
2886+  336E 66                  LD      H,(HL)          ; Get MSB of address
2887+  336F 68                  LD      L,B             ; HL = address of string
2888+  3370 06 00               LD      B,0             ; BC = starting address
2889+  3372 09                  ADD     HL,BC           ; Point to that byte
2890+  3373 44                  LD      B,H             ; BC = source string
2891+  3374 4D                  LD      C,L
2892+  3375 CD 63 31            CALL    CRTMST          ; Create a string entry
2893+  3378 6F                  LD      L,A             ; Length of new string
2894+  3379 CD E7 32            CALL    TOSTRA          ; Move string to string area
2895+  337C D1                  POP     DE              ; Clear stack
2896+  337D CD F8 32            CALL    GSTRDE          ; Move to string pool if needed
2897+  3380 C3 91 31            JP      TSTOPL          ; Temporary string to pool
2898+  3383             
2899+  3383 CD EC 33    RIGHT:  CALL    LFRGNM          ; Get number and ending ")"
2900+  3386 D1                  POP     DE              ; Get string length
2901+  3387 D5                  PUSH    DE              ; And re-save
2902+  3388 1A                  LD      A,(DE)          ; Get length
2903+  3389 90                  SUB     B               ; Move back N bytes
2904+  338A C3 57 33            JP      RIGHT1          ; Go and get sub-string
2905+  338D             
2906+  338D EB          MID:    EX      DE,HL           ; Get code string address
2907+  338E 7E                  LD      A,(HL)          ; Get next byte ',' or ")"
2908+  338F CD F1 33            CALL    MIDNUM          ; Get number supplied
2909+  3392 04                  INC     B               ; Is it character zero?
2910+  3393 05                  DEC     B
2911+  3394 CA 32 29            JP      Z,FCERR         ; Yes - Error
2912+  3397 C5                  PUSH    BC              ; Save starting position
2913+  3398 1E FF               LD      E,255           ; All of string
2914+  339A FE 29               CP      ')'             ; Any length given?
2915+  339C CA A6 33            JP      Z,RSTSTR        ; No - Rest of string
2916+  339F CD E0 26            CALL    CHKSYN          ; Make sure ',' follows
2917+  33A2 2C                  .BYTE      ','
2918+  33A3 CD 39 34            CALL    GETINT          ; Get integer 0-255
2919+  33A6 CD E0 26    RSTSTR: CALL    CHKSYN          ; Make sure ")" follows
2920+  33A9 29                  .BYTE      ")"
2921+  33AA F1                  POP     AF              ; Restore starting position
2922+  33AB E3                  EX      (SP),HL         ; Get string,8ave code string
2923+  33AC 01 59 33            LD      BC,MID1         ; Continuation of MID$ routine
2924+  33AF C5                  PUSH    BC              ; Save for return
2925+  33B0 3D                  DEC     A               ; Starting position-1
2926+  33B1 BE                  CP      (HL)            ; Compare with length
2927+  33B2 06 00               LD      B,0             ; Zero bytes length
2928+  33B4 D0                  RET     NC              ; Null string if start past end
2929+  33B5 4F                  LD      C,A             ; Save starting position-1
2930+  33B6 7E                  LD      A,(HL)          ; Get length of string
2931+  33B7 91                  SUB     C               ; Subtract start
2932+  33B8 BB                  CP      E               ; Enough string for it?
2933+  33B9 47                  LD      B,A             ; Save maximum length available
2934+  33BA D8                  RET     C               ; Truncate string if needed
2935+  33BB 43                  LD      B,E             ; Set specified length
2936+  33BC C9                  RET                     ; Go and create string
2937+  33BD             
2938+  33BD CD 27 33    VAL:    CALL    GETLEN          ; Get length of string
2939+  33C0 CA FE 34            JP      Z,RESZER        ; Result zero
2940+  33C3 5F                  LD      E,A             ; Save length
2941+  33C4 23                  INC     HL
2942+  33C5 23                  INC     HL
2943+  33C6 7E                  LD      A,(HL)          ; Get LSB of address
2944+  33C7 23                  INC     HL
2945+  33C8 66                  LD      H,(HL)          ; Get MSB of address
2946+  33C9 6F                  LD      L,A             ; HL = String address
2947+  33CA E5                  PUSH    HL              ; Save string address
2948+  33CB 19                  ADD     HL,DE
2949+  33CC 46                  LD      B,(HL)          ; Get end of string+1 byte
2950+  33CD 72                  LD      (HL),D          ; Zero it to terminate
2951+  33CE E3                  EX      (SP),HL         ; Save string end,get start
2952+  33CF C5                  PUSH    BC              ; Save end+1 byte
2953+  33D0 7E                  LD      A,(HL)          ; Get starting byte
2954+  33D1 FE 24       		CP		'$'				; Hex number indicated? [function added]
2955+  33D3 C2 DB 33    		JP		NZ,VAL1
2956+  33D6 CD 29 3C    		CALL	HEXTFP			; Convert Hex to FPREG
2957+  33D9 18 0D       		JR		VAL3
2958+  33DB FE 25       VAL1:	CP		'%'				; Binary number indicated? [function added]
2959+  33DD C2 E5 33    		JP		NZ,VAL2
2960+  33E0 CD 99 3C    		CALL	BINTFP			; Convert Bin to FPREG
2961+  33E3 18 03       		JR		VAL3
2962+  33E5 CD E5 37    VAL2:   CALL    ASCTFP          ; Convert ASCII string to FP
2963+  33E8 C1          VAL3:   POP     BC              ; Restore end+1 byte
2964+  33E9 E1                  POP     HL              ; Restore end+1 address
2965+  33EA 70                  LD      (HL),B          ; Put back original byte
2966+  33EB C9                  RET
2967+  33EC             
2968+  33EC EB          LFRGNM: EX      DE,HL           ; Code string address to HL
2969+  33ED CD E0 26            CALL    CHKSYN          ; Make sure ")" follows
2970+  33F0 29                  .BYTE      ")"
2971+  33F1 C1          MIDNUM: POP     BC              ; Get return address
2972+  33F2 D1                  POP     DE              ; Get number supplied
2973+  33F3 C5                  PUSH    BC              ; Re-save return address
2974+  33F4 43                  LD      B,E             ; Number to B
2975+  33F5 C9                  RET
2976+  33F6             
2977+  33F6 CD 3C 34    INP:    CALL    MAKINT          ; Make it integer A
2978+  33F9 32 0F 41            LD      (INPORT),A      ; Set input port
2979+  33FC CD 0E 41            CALL    INPSUB          ; Get input from port
2980+  33FF C3 A2 30            JP      PASSA           ; Return integer A
2981+  3402             
2982+  3402 CD 26 34    POUT:   CALL    SETIO           ; Set up port number
2983+  3405 C3 D6 40            JP      OUTSUB          ; Output data and return
2984+  3408             
2985+  3408 CD 26 34    WAIT:   CALL    SETIO           ; Set up port number
2986+  340B F5                  PUSH    AF              ; Save AND mask
2987+  340C 1E 00               LD      E,0             ; Assume zero if none given
2988+  340E 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
2989+  340F CD 6A 28            CALL    GETCHR          ; Get next character
2990+  3412 CA 1C 34            JP      Z,NOXOR         ; No XOR byte given
2991+  3415 CD E0 26            CALL    CHKSYN          ; Make sure ',' follows
2992+  3418 2C                  .BYTE      ','
2993+  3419 CD 39 34            CALL    GETINT          ; Get integer 0-255 to XOR with
2994+  341C C1          NOXOR:  POP     BC              ; Restore AND mask
2995+  341D CD 0E 41    WAITLP: CALL    INPSUB          ; Get input
2996+  3420 AB                  XOR     E               ; Flip selected bits
2997+  3421 A0                  AND     B               ; Result non-zero?
2998+  3422 CA 1D 34            JP      Z,WAITLP        ; No = keep waiting
2999+  3425 C9                  RET
3000+  3426             
3001+  3426 CD 39 34    SETIO:  CALL    GETINT          ; Get integer 0-255
3002+  3429 32 0F 41            LD      (INPORT),A      ; Set input port
3003+  342C 32 D7 40            LD      (OTPORT),A      ; Set output port
3004+  342F CD E0 26            CALL    CHKSYN          ; Make sure ',' follows
3005+  3432 2C                  .BYTE      ','
3006+  3433 C3 39 34            JP      GETINT          ; Get integer 0-255 and return
3007+  3436             
3008+  3436 CD 6A 28    FNDNUM: CALL    GETCHR          ; Get next character
3009+  3439 CD D8 2C    GETINT: CALL    GETNUM          ; Get a number from 0 to 255
3010+  343C CD 17 29    MAKINT: CALL    DEPINT          ; Make sure value 0 - 255
3011+  343F 7A                  LD      A,D             ; Get MSB of number
3012+  3440 B7                  OR      A               ; Zero?
3013+  3441 C2 32 29            JP      NZ,FCERR        ; No - Error
3014+  3444 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
3015+  3445 CD 6A 28            CALL    GETCHR          ; Get next character
3016+  3448 7B                  LD      A,E             ; Get number to A
3017+  3449 C9                  RET
3018+  344A             
3019+  344A 21 03 21    TEST:	LD		HL,TSTMSG		; Load text message
3020+  344D CD B1 31    		CALL	PRS				; Print it
3021+  3450 C3 50 24    		JP		PRNTOK			; Return to direct mode
3022+  3453             		
3023+  3453             ; CLRMEM - Clears the memory (sets to 0) from start address to #FFFF
3024+  3453 CD 1D 29    CLRMEM: CALL	DEINT			; Get start memory address into DE
3025+  3456 21 7F 41    CLRP:	LD		HL,LSTRAM		; Load top RAM address into HL
3026+  3459 3E 00       		LD		A,00H			; Set zero value to set in memory
3027+  345B 12          		LD		(DE),A			; Set the memory address to zero
3028+  345C 13          		INC		DE				; Next memory location
3029+  345D B7          		OR		A				; Reset C flag
3030+  345E ED 52       		SBC		HL,DE			; Compare HL with DE to see if we've
3031+  3460 19          		ADD		HL,DE			; reached the end of free RAM
3032+  3461 C2 56 34    		JP		NZ,CLRP
3033+  3464 12          		LD		(DE),A			; Clear the final memory location
3034+  3465 21 F1 20    		LD		HL,CLRMSG		; Load completion message
3035+  3468 CD B1 31    		CALL	PRS				; Print it
3036+  346B C3 50 24    		JP		PRNTOK			; Return to direct mode		
3037+  346E             
3038+  346E CD 1D 29    PEEK:   CALL    DEINT           ; Get memory address
3039+  3471 1A                  LD      A,(DE)          ; Get byte in memory
3040+  3472 C3 A2 30            JP      PASSA           ; Return integer A
3041+  3475             
3042+  3475 CD D8 2C    POKE:   CALL    GETNUM          ; Get memory address
3043+  3478 CD 1D 29            CALL    DEINT           ; Get integer -32768 to 3276
3044+  347B D5                  PUSH    DE              ; Save memory address
3045+  347C CD E0 26            CALL    CHKSYN          ; Make sure ',' follows
3046+  347F 2C                  .BYTE      ','
3047+  3480 CD 39 34            CALL    GETINT          ; Get integer 0-255
3048+  3483 D1                  POP     DE              ; Restore memory address
3049+  3484 12                  LD      (DE),A          ; Load it into memory
3050+  3485 C9                  RET
3051+  3486             
3052+  3486 21 5C 39    ROUND:  LD      HL,HALF         ; Add 0.5 to FPREG
3053+  3489 CD 2D 37    ADDPHL: CALL    LOADFP          ; Load FP at (HL) to BCDE
3054+  348C C3 98 34            JP      FPADD           ; Add BCDE to FPREG
3055+  348F             
3056+  348F CD 2D 37    SUBPHL: CALL    LOADFP          ; FPREG = -FPREG + number at HL
3057+  3492 21                  .BYTE      21H             ; Skip "POP BC" and "POP DE"
3058+  3493 C1          PSUB:   POP     BC              ; Get FP number from stack
3059+  3494 D1                  POP     DE
3060+  3495 CD 07 37    SUBCDE: CALL    INVSGN          ; Negate FPREG
3061+  3498 78          FPADD:  LD      A,B             ; Get FP exponent
3062+  3499 B7                  OR      A               ; Is number zero?
3063+  349A C8                  RET     Z               ; Yes - Nothing to add
3064+  349B 3A B7 41            LD      A,(FPEXP)       ; Get FPREG exponent
3065+  349E B7                  OR      A               ; Is this number zero?
3066+  349F CA 1F 37            JP      Z,FPBCDE        ; Yes - Move BCDE to FPREG
3067+  34A2 90                  SUB     B               ; BCDE number larger?
3068+  34A3 D2 B2 34            JP      NC,NOSWAP       ; No - Don't swap them
3069+  34A6 2F                  CPL                     ; Two's complement
3070+  34A7 3C                  INC     A               ;  FP exponent
3071+  34A8 EB                  EX      DE,HL
3072+  34A9 CD 0F 37            CALL    STAKFP          ; Put FPREG on stack
3073+  34AC EB                  EX      DE,HL
3074+  34AD CD 1F 37            CALL    FPBCDE          ; Move BCDE to FPREG
3075+  34B0 C1                  POP     BC              ; Restore number from stack
3076+  34B1 D1                  POP     DE
3077+  34B2 FE 19       NOSWAP: CP      24+1            ; Second number insignificant?
3078+  34B4 D0                  RET     NC              ; Yes - First number is result
3079+  34B5 F5                  PUSH    AF              ; Save number of bits to scale
3080+  34B6 CD 44 37            CALL    SIGNS           ; Set MSBs & sign of result
3081+  34B9 67                  LD      H,A             ; Save sign of result
3082+  34BA F1                  POP     AF              ; Restore scaling factor
3083+  34BB CD 5D 35            CALL    SCALE           ; Scale BCDE to same exponent
3084+  34BE B4                  OR      H               ; Result to be positive?
3085+  34BF 21 B4 41            LD      HL,FPREG        ; Point to FPREG
3086+  34C2 F2 D8 34            JP      P,MINCDE        ; No - Subtract FPREG from CDE
3087+  34C5 CD 3D 35            CALL    PLUCDE          ; Add FPREG to CDE
3088+  34C8 D2 1E 35            JP      NC,RONDUP       ; No overflow - Round it up
3089+  34CB 23                  INC     HL              ; Point to exponent
3090+  34CC 34                  INC     (HL)            ; Increment it
3091+  34CD CA 17 24            JP      Z,OVERR         ; Number overflowed - Error
3092+  34D0 2E 01               LD      L,1             ; 1 bit to shift right
3093+  34D2 CD 73 35            CALL    SHRT1           ; Shift result right
3094+  34D5 C3 1E 35            JP      RONDUP          ; Round it up
3095+  34D8             
3096+  34D8 AF          MINCDE: XOR     A               ; Clear A and carry
3097+  34D9 90                  SUB     B               ; Negate exponent
3098+  34DA 47                  LD      B,A             ; Re-save exponent
3099+  34DB 7E                  LD      A,(HL)          ; Get LSB of FPREG
3100+  34DC 9B                  SBC     A, E            ; Subtract LSB of BCDE
3101+  34DD 5F                  LD      E,A             ; Save LSB of BCDE
3102+  34DE 23                  INC     HL
3103+  34DF 7E                  LD      A,(HL)          ; Get NMSB of FPREG
3104+  34E0 9A                  SBC     A,D             ; Subtract NMSB of BCDE
3105+  34E1 57                  LD      D,A             ; Save NMSB of BCDE
3106+  34E2 23                  INC     HL
3107+  34E3 7E                  LD      A,(HL)          ; Get MSB of FPREG
3108+  34E4 99                  SBC     A,C             ; Subtract MSB of BCDE
3109+  34E5 4F                  LD      C,A             ; Save MSB of BCDE
3110+  34E6 DC 49 35    CONPOS: CALL    C,COMPL         ; Overflow - Make it positive
3111+  34E9             
3112+  34E9 68          BNORM:  LD      L,B             ; L = Exponent
3113+  34EA 63                  LD      H,E             ; H = LSB
3114+  34EB AF                  XOR     A
3115+  34EC 47          BNRMLP: LD      B,A             ; Save bit count
3116+  34ED 79                  LD      A,C             ; Get MSB
3117+  34EE B7                  OR      A               ; Is it zero?
3118+  34EF C2 0B 35            JP      NZ,PNORM        ; No - Do it bit at a time
3119+  34F2 4A                  LD      C,D             ; MSB = NMSB
3120+  34F3 54                  LD      D,H             ; NMSB= LSB
3121+  34F4 65                  LD      H,L             ; LSB = VLSB
3122+  34F5 6F                  LD      L,A             ; VLSB= 0
3123+  34F6 78                  LD      A,B             ; Get exponent
3124+  34F7 D6 08               SUB     8               ; Count 8 bits
3125+  34F9 FE E0               CP      -24-8           ; Was number zero?
3126+  34FB C2 EC 34            JP      NZ,BNRMLP       ; No - Keep normalising
3127+  34FE AF          RESZER: XOR     A               ; Result is zero
3128+  34FF 32 B7 41    SAVEXP: LD      (FPEXP),A       ; Save result as zero
3129+  3502 C9                  RET
3130+  3503             
3131+  3503 05          NORMAL: DEC     B               ; Count bits
3132+  3504 29                  ADD     HL,HL           ; Shift HL left
3133+  3505 7A                  LD      A,D             ; Get NMSB
3134+  3506 17                  RLA                     ; Shift left with last bit
3135+  3507 57                  LD      D,A             ; Save NMSB
3136+  3508 79                  LD      A,C             ; Get MSB
3137+  3509 8F                  ADC     A,A             ; Shift left with last bit
3138+  350A 4F                  LD      C,A             ; Save MSB
3139+  350B F2 03 35    PNORM:  JP      P,NORMAL        ; Not done - Keep going
3140+  350E 78                  LD      A,B             ; Number of bits shifted
3141+  350F 5C                  LD      E,H             ; Save HL in EB
3142+  3510 45                  LD      B,L
3143+  3511 B7                  OR      A               ; Any shifting done?
3144+  3512 CA 1E 35            JP      Z,RONDUP        ; No - Round it up
3145+  3515 21 B7 41            LD      HL,FPEXP        ; Point to exponent
3146+  3518 86                  ADD     A,(HL)          ; Add shifted bits
3147+  3519 77                  LD      (HL),A          ; Re-save exponent
3148+  351A D2 FE 34            JP      NC,RESZER       ; Underflow - Result is zero
3149+  351D C8                  RET     Z               ; Result is zero
3150+  351E 78          RONDUP: LD      A,B             ; Get VLSB of number
3151+  351F 21 B7 41    RONDB:  LD      HL,FPEXP        ; Point to exponent
3152+  3522 B7                  OR      A               ; Any rounding?
3153+  3523 FC 30 35            CALL    M,FPROND        ; Yes - Round number up
3154+  3526 46                  LD      B,(HL)          ; B = Exponent
3155+  3527 23                  INC     HL
3156+  3528 7E                  LD      A,(HL)          ; Get sign of result
3157+  3529 E6 80               AND     10000000B       ; Only bit 7 needed
3158+  352B A9                  XOR     C               ; Set correct sign
3159+  352C 4F                  LD      C,A             ; Save correct sign in number
3160+  352D C3 1F 37            JP      FPBCDE          ; Move BCDE to FPREG
3161+  3530             
3162+  3530 1C          FPROND: INC     E               ; Round LSB
3163+  3531 C0                  RET     NZ              ; Return if ok
3164+  3532 14                  INC     D               ; Round NMSB
3165+  3533 C0                  RET     NZ              ; Return if ok
3166+  3534 0C                  INC     C               ; Round MSB
3167+  3535 C0                  RET     NZ              ; Return if ok
3168+  3536 0E 80               LD      C,80H           ; Set normal value
3169+  3538 34                  INC     (HL)            ; Increment exponent
3170+  3539 C0                  RET     NZ              ; Return if ok
3171+  353A C3 17 24            JP      OVERR           ; Overflow error
3172+  353D             
3173+  353D 7E          PLUCDE: LD      A,(HL)          ; Get LSB of FPREG
3174+  353E 83                  ADD     A,E             ; Add LSB of BCDE
3175+  353F 5F                  LD      E,A             ; Save LSB of BCDE
3176+  3540 23                  INC     HL
3177+  3541 7E                  LD      A,(HL)          ; Get NMSB of FPREG
3178+  3542 8A                  ADC     A,D             ; Add NMSB of BCDE
3179+  3543 57                  LD      D,A             ; Save NMSB of BCDE
3180+  3544 23                  INC     HL
3181+  3545 7E                  LD      A,(HL)          ; Get MSB of FPREG
3182+  3546 89                  ADC     A,C             ; Add MSB of BCDE
3183+  3547 4F                  LD      C,A             ; Save MSB of BCDE
3184+  3548 C9                  RET
3185+  3549             
3186+  3549 21 B8 41    COMPL:  LD      HL,SGNRES       ; Sign of result
3187+  354C 7E                  LD      A,(HL)          ; Get sign of result
3188+  354D 2F                  CPL                     ; Negate it
3189+  354E 77                  LD      (HL),A          ; Put it back
3190+  354F AF                  XOR     A
3191+  3550 6F                  LD      L,A             ; Set L to zero
3192+  3551 90                  SUB     B               ; Negate exponent,set carry
3193+  3552 47                  LD      B,A             ; Re-save exponent
3194+  3553 7D                  LD      A,L             ; Load zero
3195+  3554 9B                  SBC     A,E             ; Negate LSB
3196+  3555 5F                  LD      E,A             ; Re-save LSB
3197+  3556 7D                  LD      A,L             ; Load zero
3198+  3557 9A                  SBC     A,D             ; Negate NMSB
3199+  3558 57                  LD      D,A             ; Re-save NMSB
3200+  3559 7D                  LD      A,L             ; Load zero
3201+  355A 99                  SBC     A,C             ; Negate MSB
3202+  355B 4F                  LD      C,A             ; Re-save MSB
3203+  355C C9                  RET
3204+  355D             
3205+  355D 06 00       SCALE:  LD      B,0             ; Clear underflow
3206+  355F D6 08       SCALLP: SUB     8               ; 8 bits (a whole byte)?
3207+  3561 DA 6C 35            JP      C,SHRITE        ; No - Shift right A bits
3208+  3564 43                  LD      B,E             ; <- Shift
3209+  3565 5A                  LD      E,D             ; <- right
3210+  3566 51                  LD      D,C             ; <- eight
3211+  3567 0E 00               LD      C,0             ; <- bits
3212+  3569 C3 5F 35            JP      SCALLP          ; More bits to shift
3213+  356C             
3214+  356C C6 09       SHRITE: ADD     A,8+1           ; Adjust count
3215+  356E 6F                  LD      L,A             ; Save bits to shift
3216+  356F AF          SHRLP:  XOR     A               ; Flag for all done
3217+  3570 2D                  DEC     L               ; All shifting done?
3218+  3571 C8                  RET     Z               ; Yes - Return
3219+  3572 79                  LD      A,C             ; Get MSB
3220+  3573 1F          SHRT1:  RRA                     ; Shift it right
3221+  3574 4F                  LD      C,A             ; Re-save
3222+  3575 7A                  LD      A,D             ; Get NMSB
3223+  3576 1F                  RRA                     ; Shift right with last bit
3224+  3577 57                  LD      D,A             ; Re-save it
3225+  3578 7B                  LD      A,E             ; Get LSB
3226+  3579 1F                  RRA                     ; Shift right with last bit
3227+  357A 5F                  LD      E,A             ; Re-save it
3228+  357B 78                  LD      A,B             ; Get underflow
3229+  357C 1F                  RRA                     ; Shift right with last bit
3230+  357D 47                  LD      B,A             ; Re-save underflow
3231+  357E C3 6F 35            JP      SHRLP           ; More bits to do
3232+  3581             
3233+  3581 00 00 00 81 UNITY:  .BYTE       000H,000H,000H,081H    ; 1.00000
3234+  3585             
3235+  3585 03          LOGTAB: .BYTE      3                       ; Table used by LOG
3236+  3586 AA 56 19 80         .BYTE      0AAH,056H,019H,080H     ; 0.59898
3237+  358A F1 22 76 80         .BYTE      0F1H,022H,076H,080H     ; 0.96147
3238+  358E 45 AA 38 82         .BYTE      045H,0AAH,038H,082H     ; 2.88539
3239+  3592             
3240+  3592 CD DE 36    LOG:    CALL    TSTSGN          ; Test sign of value
3241+  3595 B7                  OR      A
3242+  3596 EA 32 29            JP      PE,FCERR        ; ?FC Error if <= zero
3243+  3599 21 B7 41            LD      HL,FPEXP        ; Point to exponent
3244+  359C 7E                  LD      A,(HL)          ; Get exponent
3245+  359D 01 35 80            LD      BC,8035H        ; BCDE = SQR(1/2)
3246+  35A0 11 F3 04            LD      DE,04F3H
3247+  35A3 90                  SUB     B               ; Scale value to be < 1
3248+  35A4 F5                  PUSH    AF              ; Save scale factor
3249+  35A5 70                  LD      (HL),B          ; Save new exponent
3250+  35A6 D5                  PUSH    DE              ; Save SQR(1/2)
3251+  35A7 C5                  PUSH    BC
3252+  35A8 CD 98 34            CALL    FPADD           ; Add SQR(1/2) to value
3253+  35AB C1                  POP     BC              ; Restore SQR(1/2)
3254+  35AC D1                  POP     DE
3255+  35AD 04                  INC     B               ; Make it SQR(2)
3256+  35AE CD 34 36            CALL    DVBCDE          ; Divide by SQR(2)
3257+  35B1 21 81 35            LD      HL,UNITY        ; Point to 1.
3258+  35B4 CD 8F 34            CALL    SUBPHL          ; Subtract FPREG from 1
3259+  35B7 21 85 35            LD      HL,LOGTAB       ; Coefficient table
3260+  35BA CD 26 3A            CALL    SUMSER          ; Evaluate sum of series
3261+  35BD 01 80 80            LD      BC,8080H        ; BCDE = -0.5
3262+  35C0 11 00 00            LD      DE,0000H
3263+  35C3 CD 98 34            CALL    FPADD           ; Subtract 0.5 from FPREG
3264+  35C6 F1                  POP     AF              ; Restore scale factor
3265+  35C7 CD 59 38            CALL    RSCALE          ; Re-scale number
3266+  35CA 01 31 80    MULLN2: LD      BC,8031H        ; BCDE = Ln(2)
3267+  35CD 11 18 72            LD      DE,7218H
3268+  35D0 21                  .BYTE      21H             ; Skip "POP BC" and "POP DE"
3269+  35D1             
3270+  35D1 C1          MULT:   POP     BC              ; Get number from stack
3271+  35D2 D1                  POP     DE
3272+  35D3 CD DE 36    FPMULT: CALL    TSTSGN          ; Test sign of FPREG
3273+  35D6 C8                  RET     Z               ; Return zero if zero
3274+  35D7 2E 00               LD      L,0             ; Flag add exponents
3275+  35D9 CD 9C 36            CALL    ADDEXP          ; Add exponents
3276+  35DC 79                  LD      A,C             ; Get MSB of multiplier
3277+  35DD 32 C6 41            LD      (MULVAL),A      ; Save MSB of multiplier
3278+  35E0 EB                  EX      DE,HL
3279+  35E1 22 C7 41            LD      (MULVAL+1),HL   ; Save rest of multiplier
3280+  35E4 01 00 00            LD      BC,0            ; Partial product (BCDE) = zero
3281+  35E7 50                  LD      D,B
3282+  35E8 58                  LD      E,B
3283+  35E9 21 E9 34            LD      HL,BNORM        ; Address of normalise
3284+  35EC E5                  PUSH    HL              ; Save for return
3285+  35ED 21 F5 35            LD      HL,MULT8        ; Address of 8 bit multiply
3286+  35F0 E5                  PUSH    HL              ; Save for NMSB,MSB
3287+  35F1 E5                  PUSH    HL              ; 
3288+  35F2 21 B4 41            LD      HL,FPREG        ; Point to number
3289+  35F5 7E          MULT8:  LD      A,(HL)          ; Get LSB of number
3290+  35F6 23                  INC     HL              ; Point to NMSB
3291+  35F7 B7                  OR      A               ; Test LSB
3292+  35F8 CA 21 36            JP      Z,BYTSFT        ; Zero - shift to next byte
3293+  35FB E5                  PUSH    HL              ; Save address of number
3294+  35FC 2E 08               LD      L,8             ; 8 bits to multiply by
3295+  35FE 1F          MUL8LP: RRA                     ; Shift LSB right
3296+  35FF 67                  LD      H,A             ; Save LSB
3297+  3600 79                  LD      A,C             ; Get MSB
3298+  3601 D2 0F 36            JP      NC,NOMADD       ; Bit was zero - Don't add
3299+  3604 E5                  PUSH    HL              ; Save LSB and count
3300+  3605 2A C7 41            LD      HL,(MULVAL+1)   ; Get LSB and NMSB
3301+  3608 19                  ADD     HL,DE           ; Add NMSB and LSB
3302+  3609 EB                  EX      DE,HL           ; Leave sum in DE
3303+  360A E1                  POP     HL              ; Restore MSB and count
3304+  360B 3A C6 41            LD      A,(MULVAL)      ; Get MSB of multiplier
3305+  360E 89                  ADC     A,C             ; Add MSB
3306+  360F 1F          NOMADD: RRA                     ; Shift MSB right
3307+  3610 4F                  LD      C,A             ; Re-save MSB
3308+  3611 7A                  LD      A,D             ; Get NMSB
3309+  3612 1F                  RRA                     ; Shift NMSB right
3310+  3613 57                  LD      D,A             ; Re-save NMSB
3311+  3614 7B                  LD      A,E             ; Get LSB
3312+  3615 1F                  RRA                     ; Shift LSB right
3313+  3616 5F                  LD      E,A             ; Re-save LSB
3314+  3617 78                  LD      A,B             ; Get VLSB
3315+  3618 1F                  RRA                     ; Shift VLSB right
3316+  3619 47                  LD      B,A             ; Re-save VLSB
3317+  361A 2D                  DEC     L               ; Count bits multiplied
3318+  361B 7C                  LD      A,H             ; Get LSB of multiplier
3319+  361C C2 FE 35            JP      NZ,MUL8LP       ; More - Do it
3320+  361F E1          POPHRT: POP     HL              ; Restore address of number
3321+  3620 C9                  RET
3322+  3621             
3323+  3621 43          BYTSFT: LD      B,E             ; Shift partial product left
3324+  3622 5A                  LD      E,D
3325+  3623 51                  LD      D,C
3326+  3624 4F                  LD      C,A
3327+  3625 C9                  RET
3328+  3626             
3329+  3626 CD 0F 37    DIV10:  CALL    STAKFP          ; Save FPREG on stack
3330+  3629 01 20 84            LD      BC,8420H        ; BCDE = 10.
3331+  362C 11 00 00            LD      DE,0000H
3332+  362F CD 1F 37            CALL    FPBCDE          ; Move 10 to FPREG
3333+  3632             
3334+  3632 C1          DIV:    POP     BC              ; Get number from stack
3335+  3633 D1                  POP     DE
3336+  3634 CD DE 36    DVBCDE: CALL    TSTSGN          ; Test sign of FPREG
3337+  3637 CA 07 24            JP      Z,DZERR         ; Error if division by zero
3338+  363A 2E FF               LD      L,-1            ; Flag subtract exponents
3339+  363C CD 9C 36            CALL    ADDEXP          ; Subtract exponents
3340+  363F 34                  INC     (HL)            ; Add 2 to exponent to adjust
3341+  3640 34                  INC     (HL)
3342+  3641 2B                  DEC     HL              ; Point to MSB
3343+  3642 7E                  LD      A,(HL)          ; Get MSB of dividend
3344+  3643 32 E2 40            LD      (DIV3),A        ; Save for subtraction
3345+  3646 2B                  DEC     HL
3346+  3647 7E                  LD      A,(HL)          ; Get NMSB of dividend
3347+  3648 32 DE 40            LD      (DIV2),A        ; Save for subtraction
3348+  364B 2B                  DEC     HL
3349+  364C 7E                  LD      A,(HL)          ; Get MSB of dividend
3350+  364D 32 DA 40            LD      (DIV1),A        ; Save for subtraction
3351+  3650 41                  LD      B,C             ; Get MSB
3352+  3651 EB                  EX      DE,HL           ; NMSB,LSB to HL
3353+  3652 AF                  XOR     A
3354+  3653 4F                  LD      C,A             ; Clear MSB of quotient
3355+  3654 57                  LD      D,A             ; Clear NMSB of quotient
3356+  3655 5F                  LD      E,A             ; Clear LSB of quotient
3357+  3656 32 E5 40            LD      (DIV4),A        ; Clear overflow count
3358+  3659 E5          DIVLP:  PUSH    HL              ; Save divisor
3359+  365A C5                  PUSH    BC
3360+  365B 7D                  LD      A,L             ; Get LSB of number
3361+  365C CD D9 40            CALL    DIVSUP          ; Subt' divisor from dividend
3362+  365F DE 00               SBC     A,0             ; Count for overflows
3363+  3661 3F                  CCF
3364+  3662 D2 6C 36            JP      NC,RESDIV       ; Restore divisor if borrow
3365+  3665 32 E5 40            LD      (DIV4),A        ; Re-save overflow count
3366+  3668 F1                  POP     AF              ; Scrap divisor
3367+  3669 F1                  POP     AF
3368+  366A 37                  SCF                     ; Set carry to
3369+  366B D2                  .BYTE      0D2H            ; Skip "POP BC" and "POP HL"
3370+  366C             
3371+  366C C1          RESDIV: POP     BC              ; Restore divisor
3372+  366D E1                  POP     HL
3373+  366E 79                  LD      A,C             ; Get MSB of quotient
3374+  366F 3C                  INC     A
3375+  3670 3D                  DEC     A
3376+  3671 1F                  RRA                     ; Bit 0 to bit 7
3377+  3672 FA 1F 35            JP      M,RONDB         ; Done - Normalise result
3378+  3675 17                  RLA                     ; Restore carry
3379+  3676 7B                  LD      A,E             ; Get LSB of quotient
3380+  3677 17                  RLA                     ; Double it
3381+  3678 5F                  LD      E,A             ; Put it back
3382+  3679 7A                  LD      A,D             ; Get NMSB of quotient
3383+  367A 17                  RLA                     ; Double it
3384+  367B 57                  LD      D,A             ; Put it back
3385+  367C 79                  LD      A,C             ; Get MSB of quotient
3386+  367D 17                  RLA                     ; Double it
3387+  367E 4F                  LD      C,A             ; Put it back
3388+  367F 29                  ADD     HL,HL           ; Double NMSB,LSB of divisor
3389+  3680 78                  LD      A,B             ; Get MSB of divisor
3390+  3681 17                  RLA                     ; Double it
3391+  3682 47                  LD      B,A             ; Put it back
3392+  3683 3A E5 40            LD      A,(DIV4)        ; Get VLSB of quotient
3393+  3686 17                  RLA                     ; Double it
3394+  3687 32 E5 40            LD      (DIV4),A        ; Put it back
3395+  368A 79                  LD      A,C             ; Get MSB of quotient
3396+  368B B2                  OR      D               ; Merge NMSB
3397+  368C B3                  OR      E               ; Merge LSB
3398+  368D C2 59 36            JP      NZ,DIVLP        ; Not done - Keep dividing
3399+  3690 E5                  PUSH    HL              ; Save divisor
3400+  3691 21 B7 41            LD      HL,FPEXP        ; Point to exponent
3401+  3694 35                  DEC     (HL)            ; Divide by 2
3402+  3695 E1                  POP     HL              ; Restore divisor
3403+  3696 C2 59 36            JP      NZ,DIVLP        ; Ok - Keep going
3404+  3699 C3 17 24            JP      OVERR           ; Overflow error
3405+  369C             
3406+  369C 78          ADDEXP: LD      A,B             ; Get exponent of dividend
3407+  369D B7                  OR      A               ; Test it
3408+  369E CA C0 36            JP      Z,OVTST3        ; Zero - Result zero
3409+  36A1 7D                  LD      A,L             ; Get add/subtract flag
3410+  36A2 21 B7 41            LD      HL,FPEXP        ; Point to exponent
3411+  36A5 AE                  XOR     (HL)            ; Add or subtract it
3412+  36A6 80                  ADD     A,B             ; Add the other exponent
3413+  36A7 47                  LD      B,A             ; Save new exponent
3414+  36A8 1F                  RRA                     ; Test exponent for overflow
3415+  36A9 A8                  XOR     B
3416+  36AA 78                  LD      A,B             ; Get exponent
3417+  36AB F2 BF 36            JP      P,OVTST2        ; Positive - Test for overflow
3418+  36AE C6 80               ADD     A,80H           ; Add excess 128
3419+  36B0 77                  LD      (HL),A          ; Save new exponent
3420+  36B1 CA 1F 36            JP      Z,POPHRT        ; Zero - Result zero
3421+  36B4 CD 44 37            CALL    SIGNS           ; Set MSBs and sign of result
3422+  36B7 77                  LD      (HL),A          ; Save new exponent
3423+  36B8 2B                  DEC     HL              ; Point to MSB
3424+  36B9 C9                  RET
3425+  36BA             
3426+  36BA CD DE 36    OVTST1: CALL    TSTSGN          ; Test sign of FPREG
3427+  36BD 2F                  CPL                     ; Invert sign
3428+  36BE E1                  POP     HL              ; Clean up stack
3429+  36BF B7          OVTST2: OR      A               ; Test if new exponent zero
3430+  36C0 E1          OVTST3: POP     HL              ; Clear off return address
3431+  36C1 F2 FE 34            JP      P,RESZER        ; Result zero
3432+  36C4 C3 17 24            JP      OVERR           ; Overflow error
3433+  36C7             
3434+  36C7 CD 2A 37    MLSP10: CALL    BCDEFP          ; Move FPREG to BCDE
3435+  36CA 78                  LD      A,B             ; Get exponent
3436+  36CB B7                  OR      A               ; Is it zero?
3437+  36CC C8                  RET     Z               ; Yes - Result is zero
3438+  36CD C6 02               ADD     A,2             ; Multiply by 4
3439+  36CF DA 17 24            JP      C,OVERR         ; Overflow - ?OV Error
3440+  36D2 47                  LD      B,A             ; Re-save exponent
3441+  36D3 CD 98 34            CALL    FPADD           ; Add BCDE to FPREG (Times 5)
3442+  36D6 21 B7 41            LD      HL,FPEXP        ; Point to exponent
3443+  36D9 34                  INC     (HL)            ; Double number (Times 10)
3444+  36DA C0                  RET     NZ              ; Ok - Return
3445+  36DB C3 17 24            JP      OVERR           ; Overflow error
3446+  36DE             
3447+  36DE 3A B7 41    TSTSGN: LD      A,(FPEXP)       ; Get sign of FPREG
3448+  36E1 B7                  OR      A
3449+  36E2 C8                  RET     Z               ; RETurn if number is zero
3450+  36E3 3A B6 41            LD      A,(FPREG+2)     ; Get MSB of FPREG
3451+  36E6 FE                  .BYTE      0FEH            ; Test sign
3452+  36E7 2F          RETREL: CPL                     ; Invert sign
3453+  36E8 17                  RLA                     ; Sign bit to carry
3454+  36E9 9F          FLGDIF: SBC     A,A             ; Carry to all bits of A
3455+  36EA C0                  RET     NZ              ; Return -1 if negative
3456+  36EB 3C                  INC     A               ; Bump to +1
3457+  36EC C9                  RET                     ; Positive - Return +1
3458+  36ED             
3459+  36ED CD DE 36    SGN:    CALL    TSTSGN          ; Test sign of FPREG
3460+  36F0 06 88       FLGREL: LD      B,80H+8         ; 8 bit integer in exponent
3461+  36F2 11 00 00            LD      DE,0            ; Zero NMSB and LSB
3462+  36F5 21 B7 41    RETINT: LD      HL,FPEXP        ; Point to exponent
3463+  36F8 4F                  LD      C,A             ; CDE = MSB,NMSB and LSB
3464+  36F9 70                  LD      (HL),B          ; Save exponent
3465+  36FA 06 00               LD      B,0             ; CDE = integer to normalise
3466+  36FC 23                  INC     HL              ; Point to sign of result
3467+  36FD 36 80               LD      (HL),80H        ; Set sign of result
3468+  36FF 17                  RLA                     ; Carry = sign of integer
3469+  3700 C3 E6 34            JP      CONPOS          ; Set sign of result
3470+  3703             
3471+  3703 CD DE 36    ABS:    CALL    TSTSGN          ; Test sign of FPREG
3472+  3706 F0                  RET     P               ; Return if positive
3473+  3707 21 B6 41    INVSGN: LD      HL,FPREG+2      ; Point to MSB
3474+  370A 7E                  LD      A,(HL)          ; Get sign of mantissa
3475+  370B EE 80               XOR     80H             ; Invert sign of mantissa
3476+  370D 77                  LD      (HL),A          ; Re-save sign of mantissa
3477+  370E C9                  RET
3478+  370F             
3479+  370F EB          STAKFP: EX      DE,HL           ; Save code string address
3480+  3710 2A B4 41            LD      HL,(FPREG)      ; LSB,NLSB of FPREG
3481+  3713 E3                  EX      (SP),HL         ; Stack them,get return
3482+  3714 E5                  PUSH    HL              ; Re-save return
3483+  3715 2A B6 41            LD      HL,(FPREG+2)    ; MSB and exponent of FPREG
3484+  3718 E3                  EX      (SP),HL         ; Stack them,get return
3485+  3719 E5                  PUSH    HL              ; Re-save return
3486+  371A EB                  EX      DE,HL           ; Restore code string address
3487+  371B C9                  RET
3488+  371C             
3489+  371C CD 2D 37    PHLTFP: CALL    LOADFP          ; Number at HL to BCDE
3490+  371F EB          FPBCDE: EX      DE,HL           ; Save code string address
3491+  3720 22 B4 41            LD      (FPREG),HL      ; Save LSB,NLSB of number
3492+  3723 60                  LD      H,B             ; Exponent of number
3493+  3724 69                  LD      L,C             ; MSB of number
3494+  3725 22 B6 41            LD      (FPREG+2),HL    ; Save MSB and exponent
3495+  3728 EB                  EX      DE,HL           ; Restore code string address
3496+  3729 C9                  RET
3497+  372A             
3498+  372A 21 B4 41    BCDEFP: LD      HL,FPREG        ; Point to FPREG
3499+  372D 5E          LOADFP: LD      E,(HL)          ; Get LSB of number
3500+  372E 23                  INC     HL
3501+  372F 56                  LD      D,(HL)          ; Get NMSB of number
3502+  3730 23                  INC     HL
3503+  3731 4E                  LD      C,(HL)          ; Get MSB of number
3504+  3732 23                  INC     HL
3505+  3733 46                  LD      B,(HL)          ; Get exponent of number
3506+  3734 23          INCHL:  INC     HL              ; Used for conditional "INC HL"
3507+  3735 C9                  RET
3508+  3736             
3509+  3736 11 B4 41    FPTHL:  LD      DE,FPREG        ; Point to FPREG
3510+  3739 06 04       DETHL4: LD      B,4             ; 4 bytes to move
3511+  373B 1A          DETHLB: LD      A,(DE)          ; Get source
3512+  373C 77                  LD      (HL),A          ; Save destination
3513+  373D 13                  INC     DE              ; Next source
3514+  373E 23                  INC     HL              ; Next destination
3515+  373F 05                  DEC     B               ; Count bytes
3516+  3740 C2 3B 37            JP      NZ,DETHLB       ; Loop if more
3517+  3743 C9                  RET
3518+  3744             
3519+  3744 21 B6 41    SIGNS:  LD      HL,FPREG+2      ; Point to MSB of FPREG
3520+  3747 7E                  LD      A,(HL)          ; Get MSB
3521+  3748 07                  RLCA                    ; Old sign to carry
3522+  3749 37                  SCF                     ; Set MSBit
3523+  374A 1F                  RRA                     ; Set MSBit of MSB
3524+  374B 77                  LD      (HL),A          ; Save new MSB
3525+  374C 3F                  CCF                     ; Complement sign
3526+  374D 1F                  RRA                     ; Old sign to carry
3527+  374E 23                  INC     HL
3528+  374F 23                  INC     HL
3529+  3750 77                  LD      (HL),A          ; Set sign of result
3530+  3751 79                  LD      A,C             ; Get MSB
3531+  3752 07                  RLCA                    ; Old sign to carry
3532+  3753 37                  SCF                     ; Set MSBit
3533+  3754 1F                  RRA                     ; Set MSBit of MSB
3534+  3755 4F                  LD      C,A             ; Save MSB
3535+  3756 1F                  RRA
3536+  3757 AE                  XOR     (HL)            ; New sign of result
3537+  3758 C9                  RET
3538+  3759             
3539+  3759 78          CMPNUM: LD      A,B             ; Get exponent of number
3540+  375A B7                  OR      A
3541+  375B CA DE 36            JP      Z,TSTSGN        ; Zero - Test sign of FPREG
3542+  375E 21 E7 36            LD      HL,RETREL       ; Return relation routine
3543+  3761 E5                  PUSH    HL              ; Save for return
3544+  3762 CD DE 36            CALL    TSTSGN          ; Test sign of FPREG
3545+  3765 79                  LD      A,C             ; Get MSB of number
3546+  3766 C8                  RET     Z               ; FPREG zero - Number's MSB
3547+  3767 21 B6 41            LD      HL,FPREG+2      ; MSB of FPREG
3548+  376A AE                  XOR     (HL)            ; Combine signs
3549+  376B 79                  LD      A,C             ; Get MSB of number
3550+  376C F8                  RET     M               ; Exit if signs different
3551+  376D CD 73 37            CALL    CMPFP           ; Compare FP numbers
3552+  3770 1F                  RRA                     ; Get carry to sign
3553+  3771 A9                  XOR     C               ; Combine with MSB of number
3554+  3772 C9                  RET
3555+  3773             
3556+  3773 23          CMPFP:  INC     HL              ; Point to exponent
3557+  3774 78                  LD      A,B             ; Get exponent
3558+  3775 BE                  CP      (HL)            ; Compare exponents
3559+  3776 C0                  RET     NZ              ; Different
3560+  3777 2B                  DEC     HL              ; Point to MBS
3561+  3778 79                  LD      A,C             ; Get MSB
3562+  3779 BE                  CP      (HL)            ; Compare MSBs
3563+  377A C0                  RET     NZ              ; Different
3564+  377B 2B                  DEC     HL              ; Point to NMSB
3565+  377C 7A                  LD      A,D             ; Get NMSB
3566+  377D BE                  CP      (HL)            ; Compare NMSBs
3567+  377E C0                  RET     NZ              ; Different
3568+  377F 2B                  DEC     HL              ; Point to LSB
3569+  3780 7B                  LD      A,E             ; Get LSB
3570+  3781 96                  SUB     (HL)            ; Compare LSBs
3571+  3782 C0                  RET     NZ              ; Different
3572+  3783 E1                  POP     HL              ; Drop RETurn
3573+  3784 E1                  POP     HL              ; Drop another RETurn
3574+  3785 C9                  RET
3575+  3786             
3576+  3786 47          FPINT:  LD      B,A             ; <- Move
3577+  3787 4F                  LD      C,A             ; <- exponent
3578+  3788 57                  LD      D,A             ; <- to all
3579+  3789 5F                  LD      E,A             ; <- bits
3580+  378A B7                  OR      A               ; Test exponent
3581+  378B C8                  RET     Z               ; Zero - Return zero
3582+  378C E5                  PUSH    HL              ; Save pointer to number
3583+  378D CD 2A 37            CALL    BCDEFP          ; Move FPREG to BCDE
3584+  3790 CD 44 37            CALL    SIGNS           ; Set MSBs & sign of result
3585+  3793 AE                  XOR     (HL)            ; Combine with sign of FPREG
3586+  3794 67                  LD      H,A             ; Save combined signs
3587+  3795 FC AA 37            CALL    M,DCBCDE        ; Negative - Decrement BCDE
3588+  3798 3E 98               LD      A,80H+24        ; 24 bits
3589+  379A 90                  SUB     B               ; Bits to shift
3590+  379B CD 5D 35            CALL    SCALE           ; Shift BCDE
3591+  379E 7C                  LD      A,H             ; Get combined sign
3592+  379F 17                  RLA                     ; Sign to carry
3593+  37A0 DC 30 35            CALL    C,FPROND        ; Negative - Round number up
3594+  37A3 06 00               LD      B,0             ; Zero exponent
3595+  37A5 DC 49 35            CALL    C,COMPL         ; If negative make positive
3596+  37A8 E1                  POP     HL              ; Restore pointer to number
3597+  37A9 C9                  RET
3598+  37AA             
3599+  37AA 1B          DCBCDE: DEC     DE              ; Decrement BCDE
3600+  37AB 7A                  LD      A,D             ; Test LSBs
3601+  37AC A3                  AND     E
3602+  37AD 3C                  INC     A
3603+  37AE C0                  RET     NZ              ; Exit if LSBs not FFFF
3604+  37AF 0B                  DEC     BC              ; Decrement MSBs
3605+  37B0 C9                  RET
3606+  37B1             
3607+  37B1 21 B7 41    INT:    LD      HL,FPEXP        ; Point to exponent
3608+  37B4 7E                  LD      A,(HL)          ; Get exponent
3609+  37B5 FE 98               CP      80H+24          ; Integer accuracy only?
3610+  37B7 3A B4 41            LD      A,(FPREG)       ; Get LSB
3611+  37BA D0                  RET     NC              ; Yes - Already integer
3612+  37BB 7E                  LD      A,(HL)          ; Get exponent
3613+  37BC CD 86 37            CALL    FPINT           ; F.P to integer
3614+  37BF 36 98               LD      (HL),80H+24     ; Save 24 bit integer
3615+  37C1 7B                  LD      A,E             ; Get LSB of number
3616+  37C2 F5                  PUSH    AF              ; Save LSB
3617+  37C3 79                  LD      A,C             ; Get MSB of number
3618+  37C4 17                  RLA                     ; Sign to carry
3619+  37C5 CD E6 34            CALL    CONPOS          ; Set sign of result
3620+  37C8 F1                  POP     AF              ; Restore LSB of number
3621+  37C9 C9                  RET
3622+  37CA             
3623+  37CA 21 00 00    MLDEBC: LD      HL,0            ; Clear partial product
3624+  37CD 78                  LD      A,B             ; Test multiplier
3625+  37CE B1                  OR      C
3626+  37CF C8                  RET     Z               ; Return zero if zero
3627+  37D0 3E 10               LD      A,16            ; 16 bits
3628+  37D2 29          MLDBLP: ADD     HL,HL           ; Shift P.P left
3629+  37D3 DA E6 2F            JP      C,BSERR         ; ?BS Error if overflow
3630+  37D6 EB                  EX      DE,HL
3631+  37D7 29                  ADD     HL,HL           ; Shift multiplier left
3632+  37D8 EB                  EX      DE,HL
3633+  37D9 D2 E0 37            JP      NC,NOMLAD       ; Bit was zero - No add
3634+  37DC 09                  ADD     HL,BC           ; Add multiplicand
3635+  37DD DA E6 2F            JP      C,BSERR         ; ?BS Error if overflow
3636+  37E0 3D          NOMLAD: DEC     A               ; Count bits
3637+  37E1 C2 D2 37            JP      NZ,MLDBLP       ; More
3638+  37E4 C9                  RET
3639+  37E5             
3640+  37E5 FE 2D       ASCTFP: CP      '-'             ; Negative?
3641+  37E7 F5                  PUSH    AF              ; Save it and flags
3642+  37E8 CA F1 37            JP      Z,CNVNUM        ; Yes - Convert number
3643+  37EB FE 2B               CP      '+'             ; Positive?
3644+  37ED CA F1 37            JP      Z,CNVNUM        ; Yes - Convert number
3645+  37F0 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
3646+  37F1 CD FE 34    CNVNUM: CALL    RESZER          ; Set result to zero
3647+  37F4 47                  LD      B,A             ; Digits after point counter
3648+  37F5 57                  LD      D,A             ; Sign of exponent
3649+  37F6 5F                  LD      E,A             ; Exponent of ten
3650+  37F7 2F                  CPL
3651+  37F8 4F                  LD      C,A             ; Before or after point flag
3652+  37F9 CD 6A 28    MANLP:  CALL    GETCHR          ; Get next character
3653+  37FC DA 42 38            JP      C,ADDIG         ; Digit - Add to number
3654+  37FF FE 2E               CP      '.'
3655+  3801 CA 1D 38            JP      Z,DPOINT        ; '.' - Flag point
3656+  3804 FE 45               CP      'E'
3657+  3806 C2 21 38            JP      NZ,CONEXP       ; Not 'E' - Scale number
3658+  3809 CD 6A 28            CALL    GETCHR          ; Get next character
3659+  380C CD 11 2E            CALL    SGNEXP          ; Get sign of exponent
3660+  380F CD 6A 28    EXPLP:  CALL    GETCHR          ; Get next character
3661+  3812 DA 64 38            JP      C,EDIGIT        ; Digit - Add to exponent
3662+  3815 14                  INC     D               ; Is sign negative?
3663+  3816 C2 21 38            JP      NZ,CONEXP       ; No - Scale number
3664+  3819 AF                  XOR     A
3665+  381A 93                  SUB     E               ; Negate exponent
3666+  381B 5F                  LD      E,A             ; And re-save it
3667+  381C 0C                  INC     C               ; Flag end of number
3668+  381D 0C          DPOINT: INC     C               ; Flag point passed
3669+  381E CA F9 37            JP      Z,MANLP         ; Zero - Get another digit
3670+  3821 E5          CONEXP: PUSH    HL              ; Save code string address
3671+  3822 7B                  LD      A,E             ; Get exponent
3672+  3823 90                  SUB     B               ; Subtract digits after point
3673+  3824 F4 3A 38    SCALMI: CALL    P,SCALPL        ; Positive - Multiply number
3674+  3827 F2 30 38            JP      P,ENDCON        ; Positive - All done
3675+  382A F5                  PUSH    AF              ; Save number of times to /10
3676+  382B CD 26 36            CALL    DIV10           ; Divide by 10
3677+  382E F1                  POP     AF              ; Restore count
3678+  382F 3C                  INC     A               ; Count divides
3679+  3830             
3680+  3830 C2 24 38    ENDCON: JP      NZ,SCALMI       ; More to do
3681+  3833 D1                  POP     DE              ; Restore code string address
3682+  3834 F1                  POP     AF              ; Restore sign of number
3683+  3835 CC 07 37            CALL    Z,INVSGN        ; Negative - Negate number
3684+  3838 EB                  EX      DE,HL           ; Code string address to HL
3685+  3839 C9                  RET
3686+  383A             
3687+  383A C8          SCALPL: RET     Z               ; Exit if no scaling needed
3688+  383B F5          MULTEN: PUSH    AF              ; Save count
3689+  383C CD C7 36            CALL    MLSP10          ; Multiply number by 10
3690+  383F F1                  POP     AF              ; Restore count
3691+  3840 3D                  DEC     A               ; Count multiplies
3692+  3841 C9                  RET
3693+  3842             
3694+  3842 D5          ADDIG:  PUSH    DE              ; Save sign of exponent
3695+  3843 57                  LD      D,A             ; Save digit
3696+  3844 78                  LD      A,B             ; Get digits after point
3697+  3845 89                  ADC     A,C             ; Add one if after point
3698+  3846 47                  LD      B,A             ; Re-save counter
3699+  3847 C5                  PUSH    BC              ; Save point flags
3700+  3848 E5                  PUSH    HL              ; Save code string address
3701+  3849 D5                  PUSH    DE              ; Save digit
3702+  384A CD C7 36            CALL    MLSP10          ; Multiply number by 10
3703+  384D F1                  POP     AF              ; Restore digit
3704+  384E D6 30               SUB     '0'             ; Make it absolute
3705+  3850 CD 59 38            CALL    RSCALE          ; Re-scale number
3706+  3853 E1                  POP     HL              ; Restore code string address
3707+  3854 C1                  POP     BC              ; Restore point flags
3708+  3855 D1                  POP     DE              ; Restore sign of exponent
3709+  3856 C3 F9 37            JP      MANLP           ; Get another digit
3710+  3859             
3711+  3859 CD 0F 37    RSCALE: CALL    STAKFP          ; Put number on stack
3712+  385C CD F0 36            CALL    FLGREL          ; Digit to add to FPREG
3713+  385F C1          PADD:   POP     BC              ; Restore number
3714+  3860 D1                  POP     DE
3715+  3861 C3 98 34            JP      FPADD           ; Add BCDE to FPREG and return
3716+  3864             
3717+  3864 7B          EDIGIT: LD      A,E             ; Get digit
3718+  3865 07                  RLCA                    ; Times 2
3719+  3866 07                  RLCA                    ; Times 4
3720+  3867 83                  ADD     A,E             ; Times 5
3721+  3868 07                  RLCA                    ; Times 10
3722+  3869 86                  ADD     A,(HL)          ; Add next digit
3723+  386A D6 30               SUB     '0'             ; Make it absolute
3724+  386C 5F                  LD      E,A             ; Save new digit
3725+  386D C3 0F 38            JP      EXPLP           ; Look for another digit
3726+  3870             
3727+  3870 E5          LINEIN: PUSH    HL              ; Save code string address
3728+  3871 21 98 23            LD      HL,INMSG        ; Output " in "
3729+  3874 CD B1 31            CALL    PRS             ; Output string at HL
3730+  3877 E1                  POP     HL              ; Restore code string address
3731+  3878 EB          PRNTHL: EX      DE,HL           ; Code string address to DE
3732+  3879 AF                  XOR     A
3733+  387A 06 98               LD      B,80H+24        ; 24 bits
3734+  387C CD F5 36            CALL    RETINT          ; Return the integer
3735+  387F 21 B0 31            LD      HL,PRNUMS       ; Print number string
3736+  3882 E5                  PUSH    HL              ; Save for return
3737+  3883 21 B9 41    NUMASC: LD      HL,PBUFF        ; Convert number to ASCII
3738+  3886 E5                  PUSH    HL              ; Save for return
3739+  3887 CD DE 36            CALL    TSTSGN          ; Test sign of FPREG
3740+  388A 36 20               LD      (HL),' '        ; Space at start
3741+  388C F2 91 38            JP      P,SPCFST        ; Positive - Space to start
3742+  388F 36 2D               LD      (HL),'-'        ; '-' sign at start
3743+  3891 23          SPCFST: INC     HL              ; First byte of number
3744+  3892 36 30               LD      (HL),'0'        ; '0' if zero
3745+  3894 CA 47 39            JP      Z,JSTZER        ; Return '0' if zero
3746+  3897 E5                  PUSH    HL              ; Save buffer address
3747+  3898 FC 07 37            CALL    M,INVSGN        ; Negate FPREG if negative
3748+  389B AF                  XOR     A               ; Zero A
3749+  389C F5                  PUSH    AF              ; Save it
3750+  389D CD 4D 39            CALL    RNGTST          ; Test number is in range
3751+  38A0 01 43 91    SIXDIG: LD      BC,9143H        ; BCDE - 99999.9
3752+  38A3 11 F8 4F            LD      DE,4FF8H
3753+  38A6 CD 59 37            CALL    CMPNUM          ; Compare numbers
3754+  38A9 B7                  OR      A
3755+  38AA E2 BE 38            JP      PO,INRNG        ; > 99999.9 - Sort it out
3756+  38AD F1                  POP     AF              ; Restore count
3757+  38AE CD 3B 38            CALL    MULTEN          ; Multiply by ten
3758+  38B1 F5                  PUSH    AF              ; Re-save count
3759+  38B2 C3 A0 38            JP      SIXDIG          ; Test it again
3760+  38B5             
3761+  38B5 CD 26 36    GTSIXD: CALL    DIV10           ; Divide by 10
3762+  38B8 F1                  POP     AF              ; Get count
3763+  38B9 3C                  INC     A               ; Count divides
3764+  38BA F5                  PUSH    AF              ; Re-save count
3765+  38BB CD 4D 39            CALL    RNGTST          ; Test number is in range
3766+  38BE CD 86 34    INRNG:  CALL    ROUND           ; Add 0.5 to FPREG
3767+  38C1 3C                  INC     A
3768+  38C2 CD 86 37            CALL    FPINT           ; F.P to integer
3769+  38C5 CD 1F 37            CALL    FPBCDE          ; Move BCDE to FPREG
3770+  38C8 01 06 03            LD      BC,0306H        ; 1E+06 to 1E-03 range
3771+  38CB F1                  POP     AF              ; Restore count
3772+  38CC 81                  ADD     A,C             ; 6 digits before point
3773+  38CD 3C                  INC     A               ; Add one
3774+  38CE FA DA 38            JP      M,MAKNUM        ; Do it in 'E' form if < 1E-02
3775+  38D1 FE 08               CP      6+1+1           ; More than 999999 ?
3776+  38D3 D2 DA 38            JP      NC,MAKNUM       ; Yes - Do it in 'E' form
3777+  38D6 3C                  INC     A               ; Adjust for exponent
3778+  38D7 47                  LD      B,A             ; Exponent of number
3779+  38D8 3E 02               LD      A,2             ; Make it zero after
3780+  38DA             
3781+  38DA 3D          MAKNUM: DEC     A               ; Adjust for digits to do
3782+  38DB 3D                  DEC     A
3783+  38DC E1                  POP     HL              ; Restore buffer address
3784+  38DD F5                  PUSH    AF              ; Save count
3785+  38DE 11 60 39            LD      DE,POWERS       ; Powers of ten
3786+  38E1 05                  DEC     B               ; Count digits before point
3787+  38E2 C2 EB 38            JP      NZ,DIGTXT       ; Not zero - Do number
3788+  38E5 36 2E               LD      (HL),'.'        ; Save point
3789+  38E7 23                  INC     HL              ; Move on
3790+  38E8 36 30               LD      (HL),'0'        ; Save zero
3791+  38EA 23                  INC     HL              ; Move on
3792+  38EB 05          DIGTXT: DEC     B               ; Count digits before point
3793+  38EC 36 2E               LD      (HL),'.'        ; Save point in case
3794+  38EE CC 34 37            CALL    Z,INCHL         ; Last digit - move on
3795+  38F1 C5                  PUSH    BC              ; Save digits before point
3796+  38F2 E5                  PUSH    HL              ; Save buffer address
3797+  38F3 D5                  PUSH    DE              ; Save powers of ten
3798+  38F4 CD 2A 37            CALL    BCDEFP          ; Move FPREG to BCDE
3799+  38F7 E1                  POP     HL              ; Powers of ten table
3800+  38F8 06 2F               LD      B, '0'-1        ; ASCII '0' - 1
3801+  38FA 04          TRYAGN: INC     B               ; Count subtractions
3802+  38FB 7B                  LD      A,E             ; Get LSB
3803+  38FC 96                  SUB     (HL)            ; Subtract LSB
3804+  38FD 5F                  LD      E,A             ; Save LSB
3805+  38FE 23                  INC     HL
3806+  38FF 7A                  LD      A,D             ; Get NMSB
3807+  3900 9E                  SBC     A,(HL)          ; Subtract NMSB
3808+  3901 57                  LD      D,A             ; Save NMSB
3809+  3902 23                  INC     HL
3810+  3903 79                  LD      A,C             ; Get MSB
3811+  3904 9E                  SBC     A,(HL)          ; Subtract MSB
3812+  3905 4F                  LD      C,A             ; Save MSB
3813+  3906 2B                  DEC     HL              ; Point back to start
3814+  3907 2B                  DEC     HL
3815+  3908 D2 FA 38            JP      NC,TRYAGN       ; No overflow - Try again
3816+  390B CD 3D 35            CALL    PLUCDE          ; Restore number
3817+  390E 23                  INC     HL              ; Start of next number
3818+  390F CD 1F 37            CALL    FPBCDE          ; Move BCDE to FPREG
3819+  3912 EB                  EX      DE,HL           ; Save point in table
3820+  3913 E1                  POP     HL              ; Restore buffer address
3821+  3914 70                  LD      (HL),B          ; Save digit in buffer
3822+  3915 23                  INC     HL              ; And move on
3823+  3916 C1                  POP     BC              ; Restore digit count
3824+  3917 0D                  DEC     C               ; Count digits
3825+  3918 C2 EB 38            JP      NZ,DIGTXT       ; More - Do them
3826+  391B 05                  DEC     B               ; Any decimal part?
3827+  391C CA 2B 39            JP      Z,DOEBIT        ; No - Do 'E' bit
3828+  391F 2B          SUPTLZ: DEC     HL              ; Move back through buffer
3829+  3920 7E                  LD      A,(HL)          ; Get character
3830+  3921 FE 30               CP      '0'             ; '0' character?
3831+  3923 CA 1F 39            JP      Z,SUPTLZ        ; Yes - Look back for more
3832+  3926 FE 2E               CP      '.'             ; A decimal point?
3833+  3928 C4 34 37            CALL    NZ,INCHL        ; Move back over digit
3834+  392B             
3835+  392B F1          DOEBIT: POP     AF              ; Get 'E' flag
3836+  392C CA 4A 39            JP      Z,NOENED        ; No 'E' needed - End buffer
3837+  392F 36 45               LD      (HL),'E'        ; Put 'E' in buffer
3838+  3931 23                  INC     HL              ; And move on
3839+  3932 36 2B               LD      (HL),'+'        ; Put '+' in buffer
3840+  3934 F2 3B 39            JP      P,OUTEXP        ; Positive - Output exponent
3841+  3937 36 2D               LD      (HL),'-'        ; Put '-' in buffer
3842+  3939 2F                  CPL                     ; Negate exponent
3843+  393A 3C                  INC     A
3844+  393B 06 2F       OUTEXP: LD      B,'0'-1         ; ASCII '0' - 1
3845+  393D 04          EXPTEN: INC     B               ; Count subtractions
3846+  393E D6 0A               SUB     10              ; Tens digit
3847+  3940 D2 3D 39            JP      NC,EXPTEN       ; More to do
3848+  3943 C6 3A               ADD     A,'0'+10        ; Restore and make ASCII
3849+  3945 23                  INC     HL              ; Move on
3850+  3946 70                  LD      (HL),B          ; Save MSB of exponent
3851+  3947 23          JSTZER: INC     HL              ;
3852+  3948 77                  LD      (HL),A          ; Save LSB of exponent
3853+  3949 23                  INC     HL
3854+  394A 71          NOENED: LD      (HL),C          ; Mark end of buffer
3855+  394B E1                  POP     HL              ; Restore code string address
3856+  394C C9                  RET
3857+  394D             
3858+  394D 01 74 94    RNGTST: LD      BC,9474H        ; BCDE = 999999.
3859+  3950 11 F7 23            LD      DE,23F7H
3860+  3953 CD 59 37            CALL    CMPNUM          ; Compare numbers
3861+  3956 B7                  OR      A
3862+  3957 E1                  POP     HL              ; Return address to HL
3863+  3958 E2 B5 38            JP      PO,GTSIXD       ; Too big - Divide by ten
3864+  395B E9                  JP      (HL)            ; Otherwise return to caller
3865+  395C             
3866+  395C 00 00 00 80 HALF:   .BYTE      00H,00H,00H,80H ; 0.5
3867+  3960             
3868+  3960 A0 86 01    POWERS: .BYTE      0A0H,086H,001H  ; 100000
3869+  3963 10 27 00            .BYTE      010H,027H,000H  ;  10000
3870+  3966 E8 03 00            .BYTE      0E8H,003H,000H  ;   1000
3871+  3969 64 00 00            .BYTE      064H,000H,000H  ;    100
3872+  396C 0A 00 00            .BYTE      00AH,000H,000H  ;     10
3873+  396F 01 00 00            .BYTE      001H,000H,000H  ;      1
3874+  3972             
3875+  3972 21 07 37    NEGAFT: LD  HL,INVSGN           ; Negate result
3876+  3975 E3                  EX      (SP),HL         ; To be done after caller
3877+  3976 E9                  JP      (HL)            ; Return to caller
3878+  3977             
3879+  3977 CD 0F 37    SQR:    CALL    STAKFP          ; Put value on stack
3880+  397A 21 5C 39            LD      HL,HALF         ; Set power to 1/2
3881+  397D CD 1C 37            CALL    PHLTFP          ; Move 1/2 to FPREG
3882+  3980             
3883+  3980 C1          POWER:  POP     BC              ; Get base
3884+  3981 D1                  POP     DE
3885+  3982 CD DE 36            CALL    TSTSGN          ; Test sign of power
3886+  3985 78                  LD      A,B             ; Get exponent of base
3887+  3986 CA C5 39            JP      Z,EXP           ; Make result 1 if zero
3888+  3989 F2 90 39            JP      P,POWER1        ; Positive base - Ok
3889+  398C B7                  OR      A               ; Zero to negative power?
3890+  398D CA 07 24            JP      Z,DZERR         ; Yes - ?/0 Error
3891+  3990 B7          POWER1: OR      A               ; Base zero?
3892+  3991 CA FF 34            JP      Z,SAVEXP        ; Yes - Return zero
3893+  3994 D5                  PUSH    DE              ; Save base
3894+  3995 C5                  PUSH    BC
3895+  3996 79                  LD      A,C             ; Get MSB of base
3896+  3997 F6 7F               OR      01111111B       ; Get sign status
3897+  3999 CD 2A 37            CALL    BCDEFP          ; Move power to BCDE
3898+  399C F2 AD 39            JP      P,POWER2        ; Positive base - Ok
3899+  399F D5                  PUSH    DE              ; Save power
3900+  39A0 C5                  PUSH    BC
3901+  39A1 CD B1 37            CALL    INT             ; Get integer of power
3902+  39A4 C1                  POP     BC              ; Restore power
3903+  39A5 D1                  POP     DE
3904+  39A6 F5                  PUSH    AF              ; MSB of base
3905+  39A7 CD 59 37            CALL    CMPNUM          ; Power an integer?
3906+  39AA E1                  POP     HL              ; Restore MSB of base
3907+  39AB 7C                  LD      A,H             ; but don't affect flags
3908+  39AC 1F                  RRA                     ; Exponent odd or even?
3909+  39AD E1          POWER2: POP     HL              ; Restore MSB and exponent
3910+  39AE 22 B6 41            LD      (FPREG+2),HL    ; Save base in FPREG
3911+  39B1 E1                  POP     HL              ; LSBs of base
3912+  39B2 22 B4 41            LD      (FPREG),HL      ; Save in FPREG
3913+  39B5 DC 72 39            CALL    C,NEGAFT        ; Odd power - Negate result
3914+  39B8 CC 07 37            CALL    Z,INVSGN        ; Negative base - Negate it
3915+  39BB D5                  PUSH    DE              ; Save power
3916+  39BC C5                  PUSH    BC
3917+  39BD CD 92 35            CALL    LOG             ; Get LOG of base
3918+  39C0 C1                  POP     BC              ; Restore power
3919+  39C1 D1                  POP     DE
3920+  39C2 CD D3 35            CALL    FPMULT          ; Multiply LOG by power
3921+  39C5             
3922+  39C5 CD 0F 37    EXP:    CALL    STAKFP          ; Put value on stack
3923+  39C8 01 38 81            LD      BC,08138H       ; BCDE = 1/Ln(2)
3924+  39CB 11 3B AA            LD      DE,0AA3BH
3925+  39CE CD D3 35            CALL    FPMULT          ; Multiply value by 1/LN(2)
3926+  39D1 3A B7 41            LD      A,(FPEXP)       ; Get exponent
3927+  39D4 FE 88               CP      80H+8           ; Is it in range?
3928+  39D6 D2 BA 36            JP      NC,OVTST1       ; No - Test for overflow
3929+  39D9 CD B1 37            CALL    INT             ; Get INT of FPREG
3930+  39DC C6 80               ADD     A,80H           ; For excess 128
3931+  39DE C6 02               ADD     A,2             ; Exponent > 126?
3932+  39E0 DA BA 36            JP      C,OVTST1        ; Yes - Test for overflow
3933+  39E3 F5                  PUSH    AF              ; Save scaling factor
3934+  39E4 21 81 35            LD      HL,UNITY        ; Point to 1.
3935+  39E7 CD 89 34            CALL    ADDPHL          ; Add 1 to FPREG
3936+  39EA CD CA 35            CALL    MULLN2          ; Multiply by LN(2)
3937+  39ED F1                  POP     AF              ; Restore scaling factor
3938+  39EE C1                  POP     BC              ; Restore exponent
3939+  39EF D1                  POP     DE
3940+  39F0 F5                  PUSH    AF              ; Save scaling factor
3941+  39F1 CD 95 34            CALL    SUBCDE          ; Subtract exponent from FPREG
3942+  39F4 CD 07 37            CALL    INVSGN          ; Negate result
3943+  39F7 21 05 3A            LD      HL,EXPTAB       ; Coefficient table
3944+  39FA CD 35 3A            CALL    SMSER1          ; Sum the series
3945+  39FD 11 00 00            LD      DE,0            ; Zero LSBs
3946+  3A00 C1                  POP     BC              ; Scaling factor
3947+  3A01 4A                  LD      C,D             ; Zero MSB
3948+  3A02 C3 D3 35            JP      FPMULT          ; Scale result to correct value
3949+  3A05             
3950+  3A05 08          EXPTAB: .BYTE      8                       ; Table used by EXP
3951+  3A06 40 2E 94 74         .BYTE      040H,02EH,094H,074H     ; -1/7! (-1/5040)
3952+  3A0A 70 4F 2E 77         .BYTE      070H,04FH,02EH,077H     ;  1/6! ( 1/720)
3953+  3A0E 6E 02 88 7A         .BYTE      06EH,002H,088H,07AH     ; -1/5! (-1/120)
3954+  3A12 E6 A0 2A 7C         .BYTE      0E6H,0A0H,02AH,07CH     ;  1/4! ( 1/24)
3955+  3A16 50 AA AA 7E         .BYTE      050H,0AAH,0AAH,07EH     ; -1/3! (-1/6)
3956+  3A1A FF FF 7F 7F         .BYTE      0FFH,0FFH,07FH,07FH     ;  1/2! ( 1/2)
3957+  3A1E 00 00 80 81         .BYTE      000H,000H,080H,081H     ; -1/1! (-1/1)
3958+  3A22 00 00 00 81         .BYTE      000H,000H,000H,081H     ;  1/0! ( 1/1)
3959+  3A26             
3960+  3A26 CD 0F 37    SUMSER: CALL    STAKFP          ; Put FPREG on stack
3961+  3A29 11 D1 35            LD      DE,MULT         ; Multiply by "X"
3962+  3A2C D5                  PUSH    DE              ; To be done after
3963+  3A2D E5                  PUSH    HL              ; Save address of table
3964+  3A2E CD 2A 37            CALL    BCDEFP          ; Move FPREG to BCDE
3965+  3A31 CD D3 35            CALL    FPMULT          ; Square the value
3966+  3A34 E1                  POP     HL              ; Restore address of table
3967+  3A35 CD 0F 37    SMSER1: CALL    STAKFP          ; Put value on stack
3968+  3A38 7E                  LD      A,(HL)          ; Get number of coefficients
3969+  3A39 23                  INC     HL              ; Point to start of table
3970+  3A3A CD 1C 37            CALL    PHLTFP          ; Move coefficient to FPREG
3971+  3A3D 06                  .BYTE      06H             ; Skip "POP AF"
3972+  3A3E F1          SUMLP:  POP     AF              ; Restore count
3973+  3A3F C1                  POP     BC              ; Restore number
3974+  3A40 D1                  POP     DE
3975+  3A41 3D                  DEC     A               ; Cont coefficients
3976+  3A42 C8                  RET     Z               ; All done
3977+  3A43 D5                  PUSH    DE              ; Save number
3978+  3A44 C5                  PUSH    BC
3979+  3A45 F5                  PUSH    AF              ; Save count
3980+  3A46 E5                  PUSH    HL              ; Save address in table
3981+  3A47 CD D3 35            CALL    FPMULT          ; Multiply FPREG by BCDE
3982+  3A4A E1                  POP     HL              ; Restore address in table
3983+  3A4B CD 2D 37            CALL    LOADFP          ; Number at HL to BCDE
3984+  3A4E E5                  PUSH    HL              ; Save address in table
3985+  3A4F CD 98 34            CALL    FPADD           ; Add coefficient to FPREG
3986+  3A52 E1                  POP     HL              ; Restore address in table
3987+  3A53 C3 3E 3A            JP      SUMLP           ; More coefficients
3988+  3A56             
3989+  3A56 CD DE 36    RND:    CALL    TSTSGN          ; Test sign of FPREG
3990+  3A59 21 E9 40            LD      HL,SEED+2       ; Random number seed
3991+  3A5C FA B7 3A            JP      M,RESEED        ; Negative - Re-seed
3992+  3A5F 21 0A 41            LD      HL,LSTRND       ; Last random number
3993+  3A62 CD 1C 37            CALL    PHLTFP          ; Move last RND to FPREG
3994+  3A65 21 E9 40            LD      HL,SEED+2       ; Random number seed
3995+  3A68 C8                  RET     Z               ; Return if RND(0)
3996+  3A69 86                  ADD     A,(HL)          ; Add (SEED)+2)
3997+  3A6A E6 07               AND     00000111B       ; 0 to 7
3998+  3A6C 06 00               LD      B,0
3999+  3A6E 77                  LD      (HL),A          ; Re-save seed
4000+  3A6F 23                  INC     HL              ; Move to coefficient table
4001+  3A70 87                  ADD     A,A             ; 4 bytes
4002+  3A71 87                  ADD     A,A             ; per entry
4003+  3A72 4F                  LD      C,A             ; BC = Offset into table
4004+  3A73 09                  ADD     HL,BC           ; Point to coefficient
4005+  3A74 CD 2D 37            CALL    LOADFP          ; Coefficient to BCDE
4006+  3A77 CD D3 35            CALL    FPMULT  ;       ; Multiply FPREG by coefficient
4007+  3A7A 3A E8 40            LD      A,(SEED+1)      ; Get (SEED+1)
4008+  3A7D 3C                  INC     A               ; Add 1
4009+  3A7E E6 03               AND     00000011B       ; 0 to 3
4010+  3A80 06 00               LD      B,0
4011+  3A82 FE 01               CP      1               ; Is it zero?
4012+  3A84 88                  ADC     A,B             ; Yes - Make it 1
4013+  3A85 32 E8 40            LD      (SEED+1),A      ; Re-save seed
4014+  3A88 21 BB 3A            LD      HL,RNDTAB-4     ; Addition table
4015+  3A8B 87                  ADD     A,A             ; 4 bytes
4016+  3A8C 87                  ADD     A,A             ; per entry
4017+  3A8D 4F                  LD      C,A             ; BC = Offset into table
4018+  3A8E 09                  ADD     HL,BC           ; Point to value
4019+  3A8F CD 89 34            CALL    ADDPHL          ; Add value to FPREG
4020+  3A92 CD 2A 37    RND1:   CALL    BCDEFP          ; Move FPREG to BCDE
4021+  3A95 7B                  LD      A,E             ; Get LSB
4022+  3A96 59                  LD      E,C             ; LSB = MSB
4023+  3A97 EE 4F               XOR     01001111B       ; Fiddle around
4024+  3A99 4F                  LD      C,A             ; New MSB
4025+  3A9A 36 80               LD      (HL),80H        ; Set exponent
4026+  3A9C 2B                  DEC     HL              ; Point to MSB
4027+  3A9D 46                  LD      B,(HL)          ; Get MSB
4028+  3A9E 36 80               LD      (HL),80H        ; Make value -0.5
4029+  3AA0 21 E7 40            LD      HL,SEED         ; Random number seed
4030+  3AA3 34                  INC     (HL)            ; Count seed
4031+  3AA4 7E                  LD      A,(HL)          ; Get seed
4032+  3AA5 D6 AB               SUB     171             ; Do it modulo 171
4033+  3AA7 C2 AE 3A            JP      NZ,RND2         ; Non-zero - Ok
4034+  3AAA 77                  LD      (HL),A          ; Zero seed
4035+  3AAB 0C                  INC     C               ; Fillde about
4036+  3AAC 15                  DEC     D               ; with the
4037+  3AAD 1C                  INC     E               ; number
4038+  3AAE CD E9 34    RND2:   CALL    BNORM           ; Normalise number
4039+  3AB1 21 0A 41            LD      HL,LSTRND       ; Save random number
4040+  3AB4 C3 36 37            JP      FPTHL           ; Move FPREG to last and return
4041+  3AB7             
4042+  3AB7 77          RESEED: LD      (HL),A          ; Re-seed random numbers
4043+  3AB8 2B                  DEC     HL
4044+  3AB9 77                  LD      (HL),A
4045+  3ABA 2B                  DEC     HL
4046+  3ABB 77                  LD      (HL),A
4047+  3ABC C3 92 3A            JP      RND1            ; Return RND seed
4048+  3ABF             
4049+  3ABF 68 B1 46 68 RNDTAB: .BYTE   068H,0B1H,046H,068H     ; Table used by RND
4050+  3AC3 99 E9 92 69         .BYTE   099H,0E9H,092H,069H
4051+  3AC7 10 D1 75 68         .BYTE   010H,0D1H,075H,068H
4052+  3ACB             
4053+  3ACB 21 15 3B    COS:    LD      HL,HALFPI       ; Point to PI/2
4054+  3ACE CD 89 34            CALL    ADDPHL          ; Add it to PPREG
4055+  3AD1 CD 0F 37    SIN:    CALL    STAKFP          ; Put angle on stack
4056+  3AD4 01 49 83            LD      BC,8349H        ; BCDE = 2 PI
4057+  3AD7 11 DB 0F            LD      DE,0FDBH
4058+  3ADA CD 1F 37            CALL    FPBCDE          ; Move 2 PI to FPREG
4059+  3ADD C1                  POP     BC              ; Restore angle
4060+  3ADE D1                  POP     DE
4061+  3ADF CD 34 36            CALL    DVBCDE          ; Divide angle by 2 PI
4062+  3AE2 CD 0F 37            CALL    STAKFP          ; Put it on stack
4063+  3AE5 CD B1 37            CALL    INT             ; Get INT of result
4064+  3AE8 C1                  POP     BC              ; Restore number
4065+  3AE9 D1                  POP     DE
4066+  3AEA CD 95 34            CALL    SUBCDE          ; Make it 0 <= value < 1
4067+  3AED 21 19 3B            LD      HL,QUARTR       ; Point to 0.25
4068+  3AF0 CD 8F 34            CALL    SUBPHL          ; Subtract value from 0.25
4069+  3AF3 CD DE 36            CALL    TSTSGN          ; Test sign of value
4070+  3AF6 37                  SCF                     ; Flag positive
4071+  3AF7 F2 01 3B            JP      P,SIN1          ; Positive - Ok
4072+  3AFA CD 86 34            CALL    ROUND           ; Add 0.5 to value
4073+  3AFD CD DE 36            CALL    TSTSGN          ; Test sign of value
4074+  3B00 B7                  OR      A               ; Flag negative
4075+  3B01 F5          SIN1:   PUSH    AF              ; Save sign
4076+  3B02 F4 07 37            CALL    P,INVSGN        ; Negate value if positive
4077+  3B05 21 19 3B            LD      HL,QUARTR       ; Point to 0.25
4078+  3B08 CD 89 34            CALL    ADDPHL          ; Add 0.25 to value
4079+  3B0B F1                  POP     AF              ; Restore sign
4080+  3B0C D4 07 37            CALL    NC,INVSGN       ; Negative - Make positive
4081+  3B0F 21 1D 3B            LD      HL,SINTAB       ; Coefficient table
4082+  3B12 C3 26 3A            JP      SUMSER          ; Evaluate sum of series
4083+  3B15             
4084+  3B15 DB 0F 49 81 HALFPI: .BYTE   0DBH,00FH,049H,081H     ; 1.5708 (PI/2)
4085+  3B19             
4086+  3B19 00 00 00 7F QUARTR: .BYTE   000H,000H,000H,07FH     ; 0.25
4087+  3B1D             
4088+  3B1D 05          SINTAB: .BYTE   5                       ; Table used by SIN
4089+  3B1E BA D7 1E 86         .BYTE   0BAH,0D7H,01EH,086H     ; 39.711
4090+  3B22 64 26 99 87         .BYTE   064H,026H,099H,087H     ;-76.575
4091+  3B26 58 34 23 87         .BYTE   058H,034H,023H,087H     ; 81.602
4092+  3B2A E0 5D A5 86         .BYTE   0E0H,05DH,0A5H,086H     ;-41.342
4093+  3B2E DA 0F 49 83         .BYTE   0DAH,00FH,049H,083H     ;  6.2832
4094+  3B32             
4095+  3B32 CD 0F 37    TAN:    CALL    STAKFP          ; Put angle on stack
4096+  3B35 CD D1 3A            CALL    SIN             ; Get SIN of angle
4097+  3B38 C1                  POP     BC              ; Restore angle
4098+  3B39 E1                  POP     HL
4099+  3B3A CD 0F 37            CALL    STAKFP          ; Save SIN of angle
4100+  3B3D EB                  EX      DE,HL           ; BCDE = Angle
4101+  3B3E CD 1F 37            CALL    FPBCDE          ; Angle to FPREG
4102+  3B41 CD CB 3A            CALL    COS             ; Get COS of angle
4103+  3B44 C3 32 36            JP      DIV             ; TAN = SIN / COS
4104+  3B47             
4105+  3B47 CD DE 36    ATN:    CALL    TSTSGN          ; Test sign of value
4106+  3B4A FC 72 39            CALL    M,NEGAFT        ; Negate result after if -ve
4107+  3B4D FC 07 37            CALL    M,INVSGN        ; Negate value if -ve
4108+  3B50 3A B7 41            LD      A,(FPEXP)       ; Get exponent
4109+  3B53 FE 81               CP      81H             ; Number less than 1?
4110+  3B55 DA 64 3B            JP      C,ATN1          ; Yes - Get arc tangnt
4111+  3B58 01 00 81            LD      BC,8100H        ; BCDE = 1
4112+  3B5B 51                  LD      D,C
4113+  3B5C 59                  LD      E,C
4114+  3B5D CD 34 36            CALL    DVBCDE          ; Get reciprocal of number
4115+  3B60 21 8F 34            LD      HL,SUBPHL       ; Sub angle from PI/2
4116+  3B63 E5                  PUSH    HL              ; Save for angle > 1
4117+  3B64 21 6E 3B    ATN1:   LD      HL,ATNTAB       ; Coefficient table
4118+  3B67 CD 26 3A            CALL    SUMSER          ; Evaluate sum of series
4119+  3B6A 21 15 3B            LD      HL,HALFPI       ; PI/2 - angle in case > 1
4120+  3B6D C9                  RET                     ; Number > 1 - Sub from PI/2
4121+  3B6E             
4122+  3B6E 09          ATNTAB: .BYTE   9                       ; Table used by ATN
4123+  3B6F 4A D7 3B 78         .BYTE   04AH,0D7H,03BH,078H     ; 1/17
4124+  3B73 02 6E 84 7B         .BYTE   002H,06EH,084H,07BH     ;-1/15
4125+  3B77 FE C1 2F 7C         .BYTE   0FEH,0C1H,02FH,07CH     ; 1/13
4126+  3B7B 74 31 9A 7D         .BYTE   074H,031H,09AH,07DH     ;-1/11
4127+  3B7F 84 3D 5A 7D         .BYTE   084H,03DH,05AH,07DH     ; 1/9
4128+  3B83 C8 7F 91 7E         .BYTE   0C8H,07FH,091H,07EH     ;-1/7
4129+  3B87 E4 BB 4C 7E         .BYTE   0E4H,0BBH,04CH,07EH     ; 1/5
4130+  3B8B 6C AA AA 7F         .BYTE   06CH,0AAH,0AAH,07FH     ;-1/3
4131+  3B8F 00 00 00 81         .BYTE   000H,000H,000H,081H     ; 1/1
4132+  3B93             
4133+  3B93             
4134+  3B93 C9          ARET:   RET                     ; A RETurn instruction
4135+  3B94             
4136+  3B94 D7          GETINP: RST	    10H             ;input a character
4137+  3B95 C9                  RET
4138+  3B96             
4139+  3B96             CLS: 
4140+  3B96 3E 0C               LD      A,CS            ; ASCII Clear screen
4141+  3B98 C3 D0 3C            JP      MONOUT          ; Output character
4142+  3B9B             
4143+  3B9B CD 39 34    WIDTH:  CALL    GETINT          ; Get integer 0-255
4144+  3B9E 7B                  LD      A,E             ; Width to A
4145+  3B9F 32 12 41            LD      (LWIDTH),A      ; Set width
4146+  3BA2 C9                  RET
4147+  3BA3             
4148+  3BA3 CD D8 2C    LINES:  CALL    GETNUM          ; Get a number
4149+  3BA6 CD 1D 29            CALL    DEINT           ; Get integer -32768 to 32767
4150+  3BA9 ED 53 16 41         LD      (LINESC),DE     ; Set lines counter
4151+  3BAD ED 53 18 41         LD      (LINESN),DE     ; Set lines number
4152+  3BB1 C9                  RET
4153+  3BB2             
4154+  3BB2 CD 1D 29    DEEK:   CALL    DEINT           ; Get integer -32768 to 32767
4155+  3BB5 D5                  PUSH    DE              ; Save number
4156+  3BB6 E1                  POP     HL              ; Number to HL
4157+  3BB7 46                  LD      B,(HL)          ; Get LSB of contents
4158+  3BB8 23                  INC     HL
4159+  3BB9 7E                  LD      A,(HL)          ; Get MSB of contents
4160+  3BBA C3 93 30            JP      ABPASS          ; Return integer AB
4161+  3BBD             
4162+  3BBD CD D8 2C    DOKE:   CALL    GETNUM          ; Get a number
4163+  3BC0 CD 1D 29            CALL    DEINT           ; Get integer -32768 to 32767
4164+  3BC3 D5                  PUSH    DE              ; Save address
4165+  3BC4 CD E0 26            CALL    CHKSYN          ; Make sure ',' follows
4166+  3BC7 2C                  .BYTE      ','
4167+  3BC8 CD D8 2C            CALL    GETNUM          ; Get a number
4168+  3BCB CD 1D 29            CALL    DEINT           ; Get integer -32768 to 32767
4169+  3BCE E3                  EX      (SP),HL         ; Save value,get address
4170+  3BCF 73                  LD      (HL),E          ; Save LSB of value
4171+  3BD0 23                  INC     HL
4172+  3BD1 72                  LD      (HL),D          ; Save MSB of value
4173+  3BD2 E1                  POP     HL              ; Restore code string address
4174+  3BD3 C9                  RET
4175+  3BD4             
4176+  3BD4             
4177+  3BD4             ; HEX$(nn) Convert 16 bit number to Hexadecimal string
4178+  3BD4             
4179+  3BD4 CD DB 2C    HEX: 	CALL	TSTNUM          ; Verify it's a number
4180+  3BD7 CD 1D 29            CALL	DEINT           ; Get integer -32768 to 32767
4181+  3BDA C5                  PUSH	BC              ; Save contents of BC
4182+  3BDB 21 B9 41            LD	    HL,PBUFF
4183+  3BDE 7A                  LD	    A,D             ; Get high order into A
4184+  3BDF FE 00               CP      $0
4185+  3BE1 28 0C       		JR      Z,HEX2          ; Skip output if both high digits are zero
4186+  3BE3 CD 0C 3C            CALL    BYT2ASC         ; Convert D to ASCII
4187+  3BE6 78          		LD      A,B
4188+  3BE7 FE 30       		CP      '0'
4189+  3BE9 28 02       		JR      Z,HEX1          ; Don't store high digit if zero
4190+  3BEB 70                  LD	    (HL),B          ; Store it to PBUFF
4191+  3BEC 23                  INC	    HL              ; Next location
4192+  3BED 71          HEX1:   LD	    (HL),C          ; Store C to PBUFF+1
4193+  3BEE 23                  INC     HL              ; Next location
4194+  3BEF 7B          HEX2:   LD	    A,E             ; Get lower byte
4195+  3BF0 CD 0C 3C            CALL    BYT2ASC         ; Convert E to ASCII
4196+  3BF3 7A          		LD      A,D
4197+  3BF4 FE 00               CP      $0
4198+  3BF6 20 05       		JR      NZ,HEX3         ; If upper byte was not zero then always print lower byte
4199+  3BF8 78          		LD      A,B
4200+  3BF9 FE 30       		CP      '0'             ; If high digit of lower byte is zero then don't print
4201+  3BFB 28 02       		JR      Z,HEX4
4202+  3BFD 70          HEX3:   LD      (HL),B          ; to PBUFF+2
4203+  3BFE 23                  INC     HL              ; Next location
4204+  3BFF 71          HEX4:   LD      (HL),C          ; to PBUFF+3
4205+  3C00 23                  INC     HL              ; PBUFF+4 to zero
4206+  3C01 AF                  XOR     A               ; Terminating character
4207+  3C02 77                  LD      (HL),A          ; Store zero to terminate
4208+  3C03 23                  INC     HL              ; Make sure PBUFF is terminated
4209+  3C04 77                  LD      (HL),A          ; Store the double zero there
4210+  3C05 C1                  POP     BC              ; Get BC back
4211+  3C06 21 B9 41            LD      HL,PBUFF        ; Reset to start of PBUFF
4212+  3C09 C3 41 31            JP      STR1            ; Convert the PBUFF to a string and return it
4213+  3C0C             
4214+  3C0C 47          BYT2ASC	LD      B,A             ; Save original value
4215+  3C0D E6 0F               AND     $0F             ; Strip off upper nybble
4216+  3C0F FE 0A               CP      $0A             ; 0-9?
4217+  3C11 38 02               JR      C,ADD30         ; If A-F, add 7 more
4218+  3C13 C6 07               ADD     A,$07           ; Bring value up to ASCII A-F
4219+  3C15 C6 30       ADD30	ADD     A,$30           ; And make ASCII
4220+  3C17 4F                  LD      C,A             ; Save converted char to C
4221+  3C18 78                  LD      A,B             ; Retrieve original value
4222+  3C19 0F                  RRCA                    ; and Rotate it right
4223+  3C1A 0F                  RRCA
4224+  3C1B 0F                  RRCA
4225+  3C1C 0F                  RRCA
4226+  3C1D E6 0F               AND     $0F             ; Mask off upper nybble
4227+  3C1F FE 0A               CP      $0A             ; 0-9? < A hex?
4228+  3C21 38 02               JR      C,ADD301        ; Skip Add 7
4229+  3C23 C6 07               ADD     A,$07           ; Bring it up to ASCII A-F
4230+  3C25 C6 30       ADD301	ADD     A,$30           ; And make it full ASCII
4231+  3C27 47                  LD      B,A             ; Store high order byte
4232+  3C28 C9                  RET	
4233+  3C29             
4234+  3C29             ; Convert "&Hnnnn" to FPREG
4235+  3C29             ; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
4236+  3C29             ; Char is in A, NC if char is ;<=>?@ A-z, CY is set if 0-9
4237+  3C29 EB          HEXTFP  EX      DE,HL           ; Move code string pointer to DE
4238+  3C2A 21 00 00            LD      HL,$0000        ; Zero out the value
4239+  3C2D CD 42 3C            CALL    GETHEX          ; Check the number for valid hex
4240+  3C30 DA 62 3C            JP      C,HXERR         ; First value wasn't hex, HX error
4241+  3C33 18 05               JR      HEXLP1          ; Convert first character
4242+  3C35 CD 42 3C    HEXLP   CALL    GETHEX          ; Get second and addtional characters
4243+  3C38 38 1F               JR      C,HEXIT         ; Exit if not a hex character
4244+  3C3A 29          HEXLP1  ADD     HL,HL           ; Rotate 4 bits to the left
4245+  3C3B 29                  ADD     HL,HL
4246+  3C3C 29                  ADD     HL,HL
4247+  3C3D 29                  ADD     HL,HL
4248+  3C3E B5                  OR      L               ; Add in D0-D3 into L
4249+  3C3F 6F                  LD      L,A             ; Save new value
4250+  3C40 18 F3               JR      HEXLP           ; And continue until all hex characters are in
4251+  3C42             
4252+  3C42 13          GETHEX  INC     DE              ; Next location
4253+  3C43 1A                  LD      A,(DE)          ; Load character at pointer
4254+  3C44 FE 20               CP      ' '
4255+  3C46 CA 42 3C            JP      Z,GETHEX        ; Skip spaces
4256+  3C49 D6 30               SUB     $30             ; Get absolute value
4257+  3C4B D8                  RET     C               ; < "0", error
4258+  3C4C FE 0A               CP      $0A
4259+  3C4E 38 05               JR      C,NOSUB7        ; Is already in the range 0-9
4260+  3C50 D6 07               SUB     $07             ; Reduce to A-F
4261+  3C52 FE 0A               CP      $0A             ; Value should be $0A-$0F at this point
4262+  3C54 D8                  RET     C               ; CY set if was :            ; < = > ? @
4263+  3C55 FE 10       NOSUB7  CP      $10             ; > Greater than "F"?
4264+  3C57 3F                  CCF
4265+  3C58 C9                  RET                     ; CY set if it wasn't valid hex
4266+  3C59                 
4267+  3C59 EB          HEXIT   EX      DE,HL           ; Value into DE, Code string into HL
4268+  3C5A 7A                  LD      A,D             ; Load DE into AC
4269+  3C5B 4B                  LD      C,E             ; For prep to 
4270+  3C5C E5                  PUSH    HL
4271+  3C5D CD 92 30            CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
4272+  3C60 E1                  POP     HL
4273+  3C61 C9                  RET
4274+  3C62             
4275+  3C62 1E 4B       HXERR:  LD      E,HX            ; ?HEX Error
4276+  3C64 C3 1E 24            JP      ERROR
4277+  3C67             
4278+  3C67             ; BIN$(NN) Convert integer to a 1-16 char binary string
4279+  3C67 CD DB 2C    BIN:    CALL    TSTNUM          ; Verify it's a number
4280+  3C6A CD 1D 29            CALL    DEINT           ; Get integer -32768 to 32767
4281+  3C6D C5          BIN2:   PUSH    BC              ; Save contents of BC
4282+  3C6E 21 B9 41            LD      HL,PBUFF
4283+  3C71 06 11               LD      B,17            ; One higher than max char count
4284+  3C73             ZEROSUP:                        ; Suppress leading zeros
4285+  3C73 05                  DEC     B               ; Max 16 chars
4286+  3C74 78                  LD      A,B
4287+  3C75 FE 01               CP      $01
4288+  3C77 28 08               JR      Z,BITOUT        ; Always output at least one character
4289+  3C79 CB 13               RL      E
4290+  3C7B CB 12               RL      D
4291+  3C7D 30 F4               JR      NC,ZEROSUP
4292+  3C7F 18 04               JR      BITOUT2
4293+  3C81             BITOUT:      
4294+  3C81 CB 13               RL      E
4295+  3C83 CB 12               RL      D               ; Top bit now in carry
4296+  3C85             BITOUT2:
4297+  3C85 3E 30               LD      A,'0'           ; Char for '0'
4298+  3C87 CE 00               ADC     A,0             ; If carry set then '0' --> '1'
4299+  3C89 77                  LD      (HL),A
4300+  3C8A 23                  INC     HL
4301+  3C8B 05                  DEC     B
4302+  3C8C 20 F3               JR      NZ,BITOUT
4303+  3C8E AF                  XOR     A               ; Terminating character
4304+  3C8F 77                  LD      (HL),A          ; Store zero to terminate
4305+  3C90 23                  INC     HL              ; Make sure PBUFF is terminated
4306+  3C91 77                  LD      (HL),A          ; Store the double zero there
4307+  3C92 C1                  POP     BC
4308+  3C93 21 B9 41            LD      HL,PBUFF
4309+  3C96 C3 41 31            JP      STR1
4310+  3C99             
4311+  3C99             ; Convert "&Bnnnn" to FPREG
4312+  3C99             ; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
4313+  3C99 EB          BINTFP: EX      DE,HL           ; Move code string pointer to DE
4314+  3C9A 21 00 00            LD      HL,$0000        ; Zero out the value
4315+  3C9D CD B6 3C            CALL    CHKBIN          ; Check the number for valid bin
4316+  3CA0 DA C4 3C            JP      C,BINERR        ; First value wasn't bin, HX error
4317+  3CA3 D6 30       BINIT:  SUB     '0'
4318+  3CA5 29                  ADD     HL,HL           ; Rotate HL left
4319+  3CA6 B5                  OR      L
4320+  3CA7 6F                  LD      L,A
4321+  3CA8 CD B6 3C            CALL    CHKBIN          ; Get second and addtional characters
4322+  3CAB 30 F6               JR      NC,BINIT        ; Process if a bin character
4323+  3CAD EB                  EX      DE,HL           ; Value into DE, Code string into HL
4324+  3CAE 7A                  LD      A,D             ; Load DE into AC
4325+  3CAF 4B                  LD      C,E             ; For prep to 
4326+  3CB0 E5                  PUSH    HL
4327+  3CB1 CD 92 30            CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
4328+  3CB4 E1                  POP     HL
4329+  3CB5 C9                  RET
4330+  3CB6             
4331+  3CB6             ; Char is in A, NC if char is 0 or 1
4332+  3CB6 13          CHKBIN: INC     DE
4333+  3CB7 1A                  LD      A,(DE)
4334+  3CB8 FE 20               CP      ' '
4335+  3CBA CA B6 3C            JP      Z,CHKBIN        ; Skip spaces
4336+  3CBD FE 30               CP      '0'             ; Set C if < '0'
4337+  3CBF D8                  RET     C
4338+  3CC0 FE 32               CP      '2'
4339+  3CC2 3F                  CCF                     ; Set C if > '1'
4340+  3CC3 C9                  RET
4341+  3CC4             
4342+  3CC4 1E 4E       BINERR: LD      E,BN            ; ?BIN Error
4343+  3CC6 C3 1E 24            JP      ERROR
4344+  3CC9             
4345+  3CC9             
4346+  3CC9             JJUMP1: 
4347+  3CC9 DD 21 FF FF         LD      IX,-1           ; Flag cold start
4348+  3CCD C3 11 20            JP      CSTART          ; Go and initialise
4349+  3CD0             
4350+  3CD0             MONOUT: 
4351+  3CD0 C3 08 00            JP      $0008           ; output a char
4352+  3CD3             
4353+  3CD3             
4354+  3CD3             MONITR: 
4355+  3CD3 C3 00 00            JP      $0000           ; Restart (Normally Monitor Start)
4356+  3CD6             
4357+  3CD6             
4358+  3CD6 3E 00       INITST: LD      A,0             ; Clear break flag
4359+  3CD8 32 1D 41            LD      (BRKFLG),A
4360+  3CDB C3 18 20            JP      B_INIT
4361+  3CDE             
4362+  3CDE ED 45       ARETN:  RETN                    ; Return from NMI
4363+  3CE0             
4364+  3CE0             
4365+  3CE0 F5          TSTBIT: PUSH    AF              ; Save bit mask
4366+  3CE1 A0                  AND     B               ; Get common bits
4367+  3CE2 C1                  POP     BC              ; Restore bit mask
4368+  3CE3 B8                  CP      B               ; Same bit set?
4369+  3CE4 3E 00               LD      A,0             ; Return 0 in A
4370+  3CE6 C9                  RET
4371+  3CE7             
4372+  3CE7 CD EB 26    OUTNCR: CALL    OUTC            ; Output character in A
4373+  3CEA C3 13 2B            JP      PRNTCRLF        ; Output CRLF
4374+  3CED             
4375+  3CED             .end
4376+  3CED             
2245   3CED             
tasm: Number of errors = 0
